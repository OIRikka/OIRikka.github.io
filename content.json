{"meta":{"title":"Veibae CN","subtitle":"","description":"Veibae CN","author":"Veibae","url":"https://ve1bae.github.io","root":"/"},"pages":[{"title":"My friends","date":"2022-11-13T08:07:28.389Z","updated":"2022-11-13T08:07:28.389Z","comments":true,"path":"friends/index.html","permalink":"https://ve1bae.github.io/friends/index.html","excerpt":"æœºæˆ¿å…„è´µï¼","text":"æœºæˆ¿å…„è´µï¼"},{"title":"log","date":"2022-09-14T08:50:58.000Z","updated":"2022-11-09T08:35:47.883Z","comments":true,"path":"log/index.html","permalink":"https://ve1bae.github.io/log/index.html","excerpt":"","text":"2022-10-30 æ–°æ–‡ç«  csp2022åˆå¯„ 2022-10-9 æ–°æ–‡ç«  fan_si_gui_hua 2022-10-1 è«é˜Ÿå­¦ä¹ ç¬”è®° æ›´æ–° æ ‘ä¸Šè«é˜Ÿ 2022-9-24 ä¿®æ”¹äº† äºŒæ¬¡å‰©ä½™ ä¸­çš„ä¸€äº›é”™è¯¯æ¯æ—¥æ€»ç»“ æ›´æ–° 9.14~9.23 2022-9-21 æ–°æ–‡ç«  emojiè«é˜Ÿå­¦ä¹ ç¬”è®° æ›´æ–° å›æ»šè«é˜Ÿ 2022-9-14 æ¯æ—¥æ€»ç»“ æ›´æ–° 9.11~9.13 2022-9.14 æ¯æ—¥æ€»ç»“ æ›´æ–° 9.6~9.9 2022-9.07 è¯„è®ºç³»ç»Ÿæ›´æ¢ä¸º giscus 2022-9.04 æ¯æ—¥æ€»ç»“ æ›´æ–° 9.1~9.3 2022-8.22 æ·»åŠ äº† Waline è¯„è®ºç³»ç»Ÿ"},{"title":"about","date":"2022-08-07T12:55:41.000Z","updated":"2022-09-21T13:42:36.000Z","comments":true,"path":"about/index.html","permalink":"https://ve1bae.github.io/about/index.html","excerpt":"","text":"Veibae æ˜¯ä¸€ä¸ªå¾ˆå¯çˆ±çš„è‹±æ–‡ Vtuber ï¼Œä½†æˆ‘å’Œå¥¹ä¸€ç‚¹å…³ç³»éƒ½æ²¡æœ‰ï¼Œå“¦ä¸å¯¹ï¼Œå¥¹æ˜¯æˆ‘çš„ä¸»äººğŸ˜ğŸ˜å˜¿å˜¿ğŸ˜‹æˆ‘çš„VeibaeğŸ˜ğŸ˜‹ğŸ˜‹ qq: 1161668282"},{"title":"tags","date":"2022-08-01T08:30:45.000Z","updated":"2022-08-23T08:48:02.000Z","comments":true,"path":"tags/index.html","permalink":"https://ve1bae.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"11æœˆæ¯æ—¥æ€»ç»“","slug":"11æœˆæ¯æ—¥æ€»ç»“","date":"2022-11-04T13:28:42.000Z","updated":"2022-11-14T12:56:17.553Z","comments":true,"path":"2022/11/04/11æœˆæ¯æ—¥æ€»ç»“/","link":"","permalink":"https://ve1bae.github.io/2022/11/04/11%E6%9C%88%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/","excerpt":"æ—¥å¤ä¸€æ—¥ï¼Œå¿…æœ‰ç²¾è¿›ï¼Ÿï¼Ÿï¼Ÿï¼Ÿ","text":"æ—¥å¤ä¸€æ—¥ï¼Œå¿…æœ‰ç²¾è¿›ï¼Ÿï¼Ÿï¼Ÿï¼Ÿ 11.1 T1 æœ‰ nnn ä¸ªé€‰æ°‘ï¼Œç¼–å·ä¸º 1âˆ¼n1 \\sim n1âˆ¼n ï¼Œå®ƒä»¬ä¸­æœ‰çš„äººæ”¯æŒAliceï¼Œæœ‰çš„äººæ”¯æŒBobï¼Œè¿˜æœ‰çš„äººä¿æŒä¸­ç«‹ã€‚ ç°åœ¨ä½ éœ€è¦æŠŠé€‰æ°‘åˆ†æˆè‹¥å¹²ä¸ªåŒºé—´ï¼Œæ¯ä¸ªåŒºé—´çš„é•¿åº¦åœ¨ [l,r][l,r][l,r] ä¸­ã€‚å¦‚æœä¸€ä¸ªåŒºé—´ä¸­æ”¯æŒAliceçš„äººæ¯”æ”¯æŒBobçš„äººå¤šï¼Œé‚£ä¹ˆAliceå¾—ä¸€ç¥¨ï¼Œ Bobå¤šåˆ™Bobå¾—ä¸€ç¥¨ã€‚ è¯·ä½ åˆç†åœ°åˆ†åŒºé—´ï¼Œä½¿å¾—Aliceè·èƒœã€‚ å¯ä»¥æƒ³åˆ°ä¸€ä¸ªæ¯”è¾ƒæš´åŠ›çš„ DP ä»¤ fif_ifiâ€‹ ä¸ºåˆ° iii è¿™ä¸ªä½ç½®çš„æœ€å¤§æ”¶ç›Š fi=maxâ¡j=lrfjâˆ’1+get(j,i)f_i = \\max\\limits_{j = l}^r f_{j-1} + get(j, i)fiâ€‹=j=lmaxrâ€‹fjâˆ’1â€‹+get(j,i) å…¶ä¸­ l,rl, rl,r æŒ‡çš„æ˜¯åœ¨ iii å·¦ä¾§ï¼Œèƒ½å’Œ iii åˆ’æˆä¸€ä¸ªåŒºé—´çš„æœ€è¿œå’Œæœ€è¿‘çš„ä½ç½®ã€‚ get(i,j)get(i, j)get(i,j) æŒ‡ [i,j][i, j][i,j] çš„åŒºé—´å†…ï¼Œé€‰ç¥¨çš„å¢å‡æƒ…å†µï¼Œä¹Ÿå°±æ˜¯åŒºé—´å’Œçš„ç¬¦å· é‚£ä¹ˆè€ƒè™‘æ€ä¹ˆä¼˜åŒ–ï¼Œä½¿ç”¨çº¿æ®µæ ‘ç§‘æŠ€, å¯¹äº sumsumsum ä¸ºä¸‹æ ‡ç»´æŠ¤ fff ä¼˜åŒ– T2 å°è±¡æœ‰ nnn å¼ å¡ç‰‡ï¼Œç¬¬ iii å¼ å¡ç‰‡ä¸Šæœ‰ä¸€ä¸ªæ•°å­— aia_iaiâ€‹ ã€‚Aliceå’ŒBobè½®æµé€‰æ‹©å¡ç‰‡ (ä¸èƒ½é‡å¤)ï¼Œå¦‚æœæŸæ¬¡é€‰æ‹©åå·²é€‰æ‹©å¡ç‰‡ä¸Šçš„æ•°å­—çš„æœ€å¤§å…¬çº¦æ•°ä¸º 111 æˆ–è€…æ²¡æœ‰å¡ç‰‡å¯ä»¥é€‰æ‹©ï¼Œé‚£ä¹ˆå½“å‰è§’è‰²å¤±è´¥ã€‚ ä½ éœ€è¦æ±‚å‡ºï¼š1ã€å¦‚æœåŒæ–¹éƒ½é€‰æ‹©æœ€ä¼˜ç­–ç•¥ï¼Œè°ä¼šè·èƒœï¼›2ã€å¦‚æœåŒæ–¹éƒ½éšæœºé€‰å–ï¼ŒAliceè·èƒœçš„æ¦‚ç‡ã€‚ ç›´æ¥çŠ¶å‹å¡ç‰‡é€‰ä¸é€‰ï¼ŒTLE + MLE åªè®°å½•å½“å‰ gcd å’Œ å·²é€‰å¡ç‰‡æ•°é‡ TLE ã€‚ æœ‰å‘ç°å¯ä»¥æŠŠ aia_iaiâ€‹ ä¸­ç›¸åŒçš„å› æ•°å»æ‰ã€‚çŠ¶æ€æ•°å‡å°‘ 11.2 æˆ‘çˆ¹ AK äº† 11.3 T1 ç»™å®šä¸€ä¸ª nâˆ—mn * mnâˆ—m çš„æ£‹ç›˜ã€‚ qqq æ¬¡è¯¢é—®ï¼Œ è¯¢é—®ä¸€ä¸ªå®½åº¦ä¸º www çš„ä¸œè¥¿èƒ½ä¸èƒ½ä»ä¸€ä¸ªåæ ‡åˆ°è¾¾å¦ä¸€ä¸ªåæ ‡ã€‚ å¯ä»¥äºŒåˆ†é¢„å¤„ç†å‡ºæ¯ä¸ªç‚¹èƒ½æ”¾å¾—ä¸‹çš„æœ€å¤§å®½åº¦ã€‚ å¯¹è¯¢é—®ç¦»çº¿ï¼ŒæŒ‰å®½åº¦é€’å‡æ’åºï¼Œå¹¶æŸ¥é›†ç»´æŠ¤è¿é€šæ€§ã€‚å®½åº¦å‡å°æ‰©å±•å¹¶æŸ¥é›†å°±è¡Œã€‚ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;#define MAXN 2005#define MXXN 1000005using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; &#125; template &lt;typename T&gt; inline void print(T x) &#123; if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x; if (x &gt; 9) print(x / 10); putchar(x%10 + &#x27;0&#x27;); &#125; template &lt;typename T, typename ...TT&gt; inline void read(T &amp;x, TT &amp;...y) &#123; read(x); read(y...); &#125; #define p_ putchar(&#x27; &#x27;); #define pn putchar(&#x27;\\n&#x27;); #define print_(x) print(x), putchar(&#x27; &#x27;); #define printn(x) print(x), putchar(&#x27;\\n&#x27;);&#125;using namespace OCTANE;int n, m, q;#define pos(x, y) (((x) - 1) * n + (y))namespace Union_set&#123; int fa[MXXN], siz[MXXN]; void init(int n) &#123; for (int i = 1; i &lt;= n; i++) fa[i] = i, siz[i] = 1; &#125; int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]); &#125; bool merge(int x, int y) &#123; int fx = find(x), fy = find(y); if (fx == fy) return false; if (siz[x] &gt; siz[y]) swap(x, y); fa[fx] = fy; siz[fy] += siz[fx]; return true; &#125;&#125;struct query &#123; int sx, sy, tx, ty, w, id; &#125;que[100005];bool cmp(query a, query b)&#123; return a.w &gt; b.w;&#125;char mp[MAXN][MAXN];int sum[MAXN][MAXN];int mxz[MAXN][MAXN];int get(int lx, int rx, int ly, int ry)&#123; return sum[rx][ry] - sum[lx-1][ry] - sum[rx][ly-1] + sum[lx-1][ly-1];&#125;vector &lt;pair&lt;int, int&gt;&gt; vr[MAXN];int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;void Linkstart(int now)&#123; for (auto v : vr[now]) &#123; int p = pos(v.first, v.second); for (int i = 0; i &lt; 4; i++) &#123; int X = v.first + dx[i], Y = v.second + dy[i]; if (X &gt; 0 &amp;&amp; Y &gt; 0 &amp;&amp; X &lt;= n &amp;&amp; Y &lt;= m) if (mxz[X][Y] &gt;= now) Union_set::merge(p, pos(X, Y)); &#125; &#125;&#125;int ans[100005];int main()&#123; // freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;vei.out&quot;, &quot;w&quot;, stdout); read(n, m, q); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, mp[i] + 1); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + (mp[i][j]^48); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) if (mp[i][j] == &#x27;0&#x27;) &#123; int l = 1, r = min(i, j) + 1; int res = 1; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (!get(i - mid + 1, i, j - mid + 1, j)) res = mid, l = mid + 1; else r = mid; &#125; mxz[i][j] = res; vr[res].emplace_back(i, j); &#125; &#125; int now = 0; for (int i = 1; i &lt;= q; i++) &#123; int sx, sy, tx, ty, w; read(sx, sy, tx, ty, w); now = max(now, w); que[i] = &#123;sx, sy, tx, ty, w, i&#125;; &#125; sort(que + 1, que + 1 + q, cmp); Union_set :: init(n * m); for (int i = 1; i &lt;= q; i++) &#123; while (now &gt;= que[i].w) Linkstart(now--); if (mxz[que[i].sx][que[i].sy] &lt; que[i].w || mxz[que[i].tx][que[i].ty] &lt; que[i].w) ans[que[i].id] = false; else ans[que[i].id] = (Union_set::find(pos(que[i].sx, que[i].sy)) == Union_set::find(pos(que[i].tx, que[i].ty))); &#125; for (int i = 1; i &lt;= q; i++) puts(ans[i] ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; 11.4 T1 ä¸¤ç»„ç©å®¶ï¼Œç¬¬ä¸€ç»„ç©å®¶çš„èƒ½åŠ›å€¼ä¸º ai,â€¦ana_i, \\dots a_naiâ€‹,â€¦anâ€‹ ã€‚ç¬¬äºŒç»„ç©å®¶çš„èƒ½åŠ›å€¼ä¸º b1,â€¦b2b_1, \\dots b_2b1â€‹,â€¦b2â€‹ ã€‚ç©å®¶ä¹‹é—´ä¸¤ä¸¤è¿›è¡Œæ¸¸æˆã€‚AAA ç»„ç©å®¶åœ¨ä¸€åœºæ¸¸æˆä¸­è·èƒœçš„æ¦‚ç‡æ˜¯ ai/(ai+bi)a_i / (a_i + b_i)aiâ€‹/(aiâ€‹+biâ€‹) ã€‚ è¯¢é—® AAA ç»„æ¯ä¸ªç©ï¼‹è·èƒœçš„æœŸæœ›ã€‚ai,biâˆˆ[1,2]a_i, b_i \\in [1, 2]aiâ€‹,biâ€‹âˆˆ[1,2] å¯¹äºæ¯ä¸ª aaa æ±‚ âˆ‘i=1maa+bi\\sum\\limits_{i=1}^{m} \\dfrac{a}{a + b_i}i=1âˆ‘mâ€‹a+biâ€‹aâ€‹ è½¬åŒ–ä¸€ä¸‹ âˆ‘i=1maa+bi=mâˆ’âˆ‘i=1mbia+bi\\sum_{i=1}^{m} \\dfrac{a}{a+b_i}\\\\ =m-\\sum_{i=1}^{m}\\frac{b_i}{a+b_i} i=1âˆ‘mâ€‹a+biâ€‹aâ€‹=mâˆ’i=1âˆ‘mâ€‹a+biâ€‹biâ€‹â€‹ å¯¹åé¢çš„åˆ†å¼è¿›è¡Œä¸€ä¸ªæ³°å‹’çš„å±•å¼€ã€‚ f(x)=âˆ‘i=0âˆf(i)x0i!(xâˆ’x0)if(x) = \\sum_{i=0}^{\\infty } \\frac{f^{(i)}{x_0}}{i!} (x - x_0)^i f(x)=i=0âˆ‘âˆâ€‹i!f(i)x0â€‹â€‹(xâˆ’x0â€‹)i ååœ¨ x=1.5x = 1.5x=1.5 å¤„å±•å¼€åé¢çš„ xâˆ’x0x - x_0xâˆ’x0â€‹ å°±å·²ç»å¯ä»¥å¿½ç•¥äº† T2 ä¸€æ£µå¸¦æƒæ ‘ï¼Œæ¯æ¬¡ç»™ä¸¤ä¸ªäººä¸¤æ¡è·¯å¾„ï¼Œé€Ÿåº¦ä¸º 111 ï¼Œ åˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸€ä¸ªæ—¶åˆ»ï¼Œä¸¤ä¸ªäººåœ¨ä¸€æ¡è¾¹ä¸Šï¼ˆä¸ç®—é¡¶ç‚¹ï¼‰ åˆ†æƒ…å†µè®¨è®ºï¼Œåˆ¤æ–­è·¯å¾„äº¤ä¸äº¤å…ˆï¼Œæœ‰äº¤åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š åŒå‘æ—¶ï¼Œå¦‚æœä»–ä»¬åˆ°è¾¾è·¯å¾„äº¤çš„æ—¶é—´å·® å°äº äº¤ä¸Šæœ€é•¿çš„ä¸€æ¡è¾¹å°±è¡Œã€‚ç»´æŠ¤åŒºé—´max ç›¸å‘æ—¶ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯åœ¨ç‚¹ä¸Šç›¸é‡ã€‚äºŒåˆ†æˆ–è€…å€å¢è·³ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270// æˆ‘å‘ä½ èµ°ğŸš¶â€â™‚ï¸äº† 99 æ­¥, ä½†çœ‹åˆ°ä½ ğŸ’ƒåé€€ 1 æ­¥åï¼Œæˆ‘å°±æ— æ³•åœ¨å‘å‰äº†ğŸ˜­ğŸƒâ€â™‚ï¸ğŸƒâ€â™‚ï¸#include &lt;bits/stdc++.h&gt;#define MAXN 10005using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; &#125; template &lt;typename T&gt; inline void print(T x) &#123; if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x; if (x &gt; 9) print(x / 10); putchar(x%10 + &#x27;0&#x27;); &#125; template &lt;typename T, typename ...TT&gt; inline void read(T &amp;x, TT &amp;...y) &#123; read(x); read(y...); &#125; #define p_ putchar(&#x27; &#x27;); #define pn putchar(&#x27;\\n&#x27;); #define print_(x) print(x), putchar(&#x27; &#x27;); #define printn(x) print(x), putchar(&#x27;\\n&#x27;);&#125;using namespace OCTANE;int n, m;int cnte = 1, head[MAXN];struct edge&#123; int to, nxt, dis;&#125;e[MAXN&lt;&lt;1];void adde(int u, int v, int w)&#123; e[++cnte].to = v; e[cnte].dis = w; e[cnte].nxt = head[u]; head[u] = cnte;&#125;int fa[MAXN], siz[MAXN], dep[MAXN], son[MAXN];int top[MAXN], dis[MAXN];#define v (e[i].to)void dfs1(int u, int dad)&#123; fa[u] = dad; siz[u] = 1; dep[u] = dep[dad] + 1; for (int i = head[u]; i; i = e[i].nxt) if (v != dad) &#123; dis[v] = dis[u] + e[i].dis; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if (son[u]) dfs2(son[u], tup); for (int i = head[u]; i; i = e[i].nxt) if (v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v); &#125;#undef vint LCA(int u, int v)&#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;int dwd[MAXN], cnt1, qwq[MAXN], cnt2;bool vis[MAXN];int pos[MAXN];void get_path(int u, int &amp;t, int to, int op)&#123; dwd[++cnt1] = u; qwq[cnt1] = t; vis[u] = 1; pos[u] = cnt1; if (u == to) return; if (op) t = t - dis[u] + dis[fa[u]]; else t = t + dis[u] - dis[fa[u]]; get_path(fa[u], t, to, op);&#125;void got_path(int u, int t, int to, int op)&#123; if (u == to) return; if (op == 1) got_path(fa[u], t + (dis[u] - dis[fa[u]]), to, op); else got_path(fa[u], t + (dis[u] - dis[fa[u]]), to, op); dwd[++cnt1] = u; qwq[cnt1] = t; vis[u] = 1; pos[u] = cnt1;&#125;void walk(int u, int v, int t)&#123; for (int i = 1; i &lt;= cnt1; i++) vis[dwd[i]] = 0; int lca = LCA(u, v), op = 0; if (dep[u] &lt; dep[v]) &#123; t += dis[u] + dis[v] - 2 * dis[lca]; swap(u, v); op = 1; &#125; cnt1 = 0; get_path(u, t, lca, op); if (op == 1) t = t - dis[v] + dis[lca]; else t = t + dis[v] - dis[lca]; got_path(v, t, lca, op);&#125;bool flag = 0;void get_poth(int u, int &amp;t, int to, int op)&#123; // cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; t &lt;&lt; &#x27;\\n&#x27;; if (flag || u == to) return; int v = fa[u], fat; if (op) fat = t - dis[u] + dis[fa[u]]; else fat = t + dis[u] - dis[fa[u]]; if (vis[u] &amp;&amp; vis[v]) &#123; int id = pos[u], fid = pos[v]; if ((qwq[id] - qwq[fid]) * (t - fat) &gt; 0) &#123; if (qwq[id] &gt; qwq[fid]) &#123; if (!(t &lt; qwq[fid] || fat &gt; qwq[id])) return flag = 1, void(); &#125; else &#123; if (!(t &gt; qwq[fid] || fat &lt; qwq[id])) return flag = 1, void(); &#125; &#125; else &#123; if (qwq[id] &gt; t &amp;&amp; qwq[fid] &lt; fat || t &gt; qwq[id] &amp;&amp; fat &lt; qwq[fid]) return flag = 1, void(); &#125; &#125; t = fat; get_poth(fa[u], t, to, op);&#125;void got_poth(int u, int t, int to, int op)&#123; // cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; t &lt;&lt; &#x27;\\n&#x27;; if (flag || u == to) return; int v = fa[u], fat; if (op == 1) fat = t + dis[u] - dis[fa[u]]; else fat = t - dis[u] + dis[fa[u]]; if (vis[v] &amp;&amp; vis[u]) &#123; int id = pos[u], fid = pos[v]; if ((qwq[id] - qwq[fid]) * (t - fat) &gt; 0) &#123; if (qwq[id] &gt; qwq[fid]) &#123; if (!(t &lt; qwq[fid] || fat &gt; qwq[id])) return flag = 1, void(); &#125; else &#123; if (!(t &gt; qwq[fid] || fat &lt; qwq[id])) return flag = 1, void(); &#125; &#125; else &#123; if (qwq[id] &gt; t &amp;&amp; qwq[fid] &lt; fat || t &gt; qwq[id] &amp;&amp; fat &lt; qwq[fid]) return flag = 1, void(); &#125; &#125; got_poth(fa[u], fat, to, op);&#125;bool check(int u, int v, int t)&#123; int lca = LCA(u, v); int op = 0; if (dep[u] &lt; dep[v]) &#123; t += dis[u] + dis[v] - 2 * dis[lca]; swap(u, v); op = 1; &#125; get_poth(u, t, lca, op); if (flag) return 1; if (op) t = t - dis[v] + dis[lca]; else t = t - dis[v] + dis[lca]; got_poth(v, t, lca, op); if (flag) return 1; return 0;&#125;int main()&#123; read(n, m); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; read(u, v, w); adde(u, v, w); adde(v, u, w); &#125; dis[1] = 0; dfs1(1, 0); dfs2(1, 1); for (int i = 1; i &lt;= m; i++) &#123; flag = 0; int u, v, t; read(u, v, t); walk(u, v, t); // for (int j = 1; j &lt;= cnt1; j++) // cout &lt;&lt; dwd[j] &lt;&lt; &#x27; &#x27; &lt;&lt; qwq[j] &lt;&lt; &#x27;\\n&#x27;; read(u, v, t); puts(check(u, v, t) ? &quot;YES&quot; : &quot;NO&quot;); &#125; return 0;&#125;/*8 61 2 31 3 11 4 22 5 52 6 15 7 25 8 45 3 2 7 4 28 6 1 1 7 64 5 1 4 5 107 8 3 3 4 56 7 6 5 1 22 1 10 8 3 3*/ T3 kkk ç»´ç©ºé—´éšæœºæ¸¸èµ°ï¼Œæ¯ç»´ä¸¤ä¸ªæ–¹å‘ï¼Œèµ° nnn æ­¥åˆ°è¾¾çš„ä¸åŒä½ç½®çš„æœŸæœ›ã€‚ fff è¡¨ç¤º nnn æ­¥ä¹‹åå›åˆ°è¿™ä¸ªä½ç½®çš„æ–¹æ¡ˆæ•°ï¼ˆå¯ä»¥ç»è¿‡å¤šæ¬¡ï¼‰ hhh è¡¨ç¤º nnn æ­¥ä¹‹åå›åˆ°è¿™ä¸ªä½ç½®çš„æ–¹æ¡ˆæ•°ï¼ˆä¸é‡å¤ï¼‰ Code 1234567891011121314151617181920212223242526272829303132333435363738int main()&#123; freopen(&quot;qaq.in&quot;, &quot;r&quot;, stdin); freopen(&quot;qaq.out&quot;, &quot;w&quot;, stdout); read(n, k, mod); m = n / 2; C[0][0] = ppw[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; ppw[i] = ppw[i-1] * 2 * k%mod; C[i][0] = 1; for (int j = 1; j &lt;= i; j++) C[i][j] = (C[i-1][j] + C[i-1][j-1])%mod; &#125; f[0] = 1; for (int i = 1; i &lt;= k; i++) &#123; memcpy(g, f, sizeof(f)); memset(f, 0, sizeof(f)); for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; j + k &lt;= m; k++) f[j + k] = (f[j + k] + g[j] * C[(j + k)*2][k * 2]%mod * C[k * 2][k])%mod; &#125; &#125; for (int i = 0; i &lt;= m; i++) &#123; h[i] = f[i]; for (int j = 1; j &lt; i; j++) h[i] = (h[i] - h[j] * f[i-j]%mod +mod)%mod; &#125; ans = (n + 1) * ppw[n] %mod; for (int i = 1; i &lt;= m; i++) ans = (ans - h[i] * ppw[n-i*2]%mod * (n - i * 2 + 1)%mod +mod)%mod; print(ans); return 0;&#125; 11.5 T1 ç»™å®šä¸€ä¸ªåæ ‡ (x,y)(x, y)(x,y) ï¼Œè¯¢é—®ä»åŸç‚¹è·³ åˆ°è¿™ä¸ªç‚¹çš„æœ€çŸ­æ­¥æ•°å’Œæ–¹æ¡ˆï¼Œæ¯æ¬¡åªèƒ½ç§»åŠ¨åˆ°æ›¼å“ˆé¡¿è·ç¦»ä¸º kkk çš„ç‚¹ æ„é€ ï¼Œå½“ x,yx, yx,y æœ‰ä¸€ä¸ªå¤§äº kkk å°±ç›´æ¥èµ°ï¼Œå¦åˆ™æˆ‘å»ºè®®ä½ çœ‹ä»£ç  Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int, int&gt; pir; int k; pir f(int x, int y)&#123; if (x &gt; y) &#123; pir tmp = f(y, x); return &#123;tmp.second, tmp.first&#125;; &#125; if (x &lt; 0) &#123; pir tmp = f(-x, y); return &#123;-tmp.first, tmp.second&#125;; &#125; if (x + y &gt;= 2 * k) &#123; return &#123;x, y - k&#125;; &#125; if (x + y == k) return &#123;0, 0&#125;; int t = k - (x + y) / 2; return &#123;-t, y - k + x + t&#125;;&#125; stack &lt;pir, vector&lt;pir&gt; &gt; st; int x, y; int main()&#123; scanf(&quot;%d %d %d&quot;, &amp;k, &amp;x, &amp;y); if (!(k &amp; 1)) if ((x &amp; 1) != (y &amp; 1)) return puts(&quot;-1&quot;), 0; st.emplace(x, y); for (; x || y; x = st.top().first, y = st.top().second) st.emplace(f(x, y)); st.pop(); printf(&quot;%d\\n&quot;, st.size()); while (st.size()) &#123; printf(&quot;%d %d\\n&quot;, st.top().first, st.top().second); st.pop(); &#125; return 0;&#125; T2 nnn ä¸ªç‰©å“ã€‚ mmm ä¸ªå•†åº—ã€‚ åœ¨ç¬¬ jjj ä¸ªå•†åº—ä¹°ç¬¬ iii ä¸ªç‰©å“çš„è´¹ç”¨æ˜¯ ai,ja_{i,j}ai,jâ€‹ ã€‚åœ¨ iii ä¸ªå•†åº—ä¹°ä¸œè¥¿éœ€è¦ bib_ibiâ€‹ çš„èŠ±è´¹ã€‚ å¯ä»¥çŠ¶å‹å•†åº—ä¹°ä¸ä¹°ï¼Œç„¶åæ‰‹ç©å‘ç°ç­”æ¡ˆæ˜¯å­é›†ã€‚é«˜ç»´å‰ç¼€å’Œæ•´å­é›† Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f3f3f3f3f#define ll long long#define MAXN 100005#define MXLG 26using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; &#125; template &lt;typename T&gt; inline void print(T x) &#123; if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x; if (x &gt; 9) print(x / 10); putchar(x%10 + &#x27;0&#x27;); &#125; template &lt;typename T, typename ...TT&gt; inline void read(T &amp;x, TT &amp;...y) &#123; read(x); read(y...); &#125; #define p_ putchar(&#x27; &#x27;); #define pn putchar(&#x27;\\n&#x27;); #define print_(x) print(x), putchar(&#x27; &#x27;); #define printn(x) print(x), putchar(&#x27;\\n&#x27;);&#125;using namespace OCTANE;#define lowbit(x) (x &amp; (-x))struct node &#123; int val, id; &#125;a[MAXN][MXLG];ll b[1&lt;&lt;25], f[1&lt;&lt;25];int main()&#123; int n, m; read(n, m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; m; j++) read(a[i][j].val), a[i][j].id = j; sort(a[i], a[i] + m, [&amp;](node x, node y) &#123; return x.val &lt; y.val; &#125;); int s = 0; for (int j = 0; j &lt; m; j++) &#123; f[s] += a[i][j].val - a[i][j - 1].val; s |= 1 &lt;&lt; a[i][j].id; &#125; &#125; int S = (1 &lt;&lt; m) - 1; for (int i = 0; i &lt; m; i++) for (int s = 1; s &lt;= S; s++) if ((s &gt;&gt; i) &amp; 1) f[s] += f[s ^ (1 &lt;&lt; i)]; for (int i = 0; i &lt; m; i++) read(b[1 &lt;&lt; i]); ll ans = INF; for (int s = 1; s &lt;= S; s++) &#123; if (s == lowbit(s)) continue; b[s] = b[lowbit(s)] + b[s ^ lowbit(s)]; &#125; for (int s = 0; s &lt; S; s++) ans = min(ans, f[s] + b[s ^ S]); print(ans); return 0;&#125; 11.7 æˆ‘çˆ¹ Ak äº† 11.8 T1 ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„01ä¸²ï¼Œä¸‹æ ‡ 0âˆ¼nâˆ’10 \\sim n-10âˆ¼nâˆ’1 ã€‚æœ‰ä¸¤ç§æ“ä½œï¼š A: é€‰æ‹©ä¸€ä¸ª xxx ï¼Œå°†åºåˆ—å¾ªç¯å·¦ç§» xxx ä½ã€‚ä¹Ÿå°±æ˜¯æ–°åºåˆ—çš„ç¬¬ (i+x) mod n(i+x) \\bmod n(i+x)modn ä½å¯¹åº”åŸåºåˆ—çš„ç¬¬ iii ä½ã€‚ B: é€‰æ‹©ä¸€ä¸ª xxx , æ»¡è¶³åºåˆ—çš„ç¬¬ xxx ä¸ªä½ç½®ä¸º 111 , ä¸”ç¬¬ (x+1) mod n(x+1) \\bmod n(x+1)modn ä½ç½®ä¸ä¸º 111 , äº¤æ¢åºåˆ—çš„ç¬¬ $x $ ä¸ªä½ç½®å’Œç¬¬ (x+1) mod n(x+1) \\bmod n(x+1)modn ä¸ªä½ç½®çš„å­—ç¬¦ã€‚ æ„é€ ä¸€ä¸ªç”± lll ä¸ªé•¿åº¦ä¸º nnn çš„01ä¸²æ„æˆçš„åºåˆ— sss ï¼Œä½¿å¾—åºåˆ—ä¸­æ¯ä¸ªä¸²æ°å¥½æœ‰ kkk ä¸ª 111 ã€‚ä¸”å¯¹äº 0â‰¤i&lt;lâˆ’10 \\leq i&lt;l-10â‰¤i&lt;lâˆ’1 , s[i] æ—¢å¯ä»¥é€šè¿‡ä¸€ç§ A ç±»å‹çš„æ“ä½œ, ä¹Ÿå¯ä»¥é€šè¿‡ä¸€ç§ B ç±»å‹çš„æ“ä½œ, å˜ä¸º s[i+1] ã€‚ è®¾ sss ä¸­æ‰€æœ‰ 111 ä¸‹æ ‡ä¹‹å’Œä¸º www å¯¹äºç¬¬ä¸€ä¸ªæ“ä½œï¼Œé‚£ä¹ˆæ•´ä½“å·¦ç§»ä¸€ä½ä¹Ÿå°±æ˜¯è¯´æœ‰ä¸€ä¸ª xxx ä½¿å¾— wi+xÃ—kâ‰¡wi+1 mod nw_i + x\\times k \\equiv w_{i+1} \\bmod nwiâ€‹+xÃ—kâ‰¡wi+1â€‹modn å¯¹äºç¬¬äºŒä¸ªæ“ä½œï¼Œé‚£ä¹ˆå°±æ˜¯è¯´ wi+1â‰¡wi+1 mod nw_i + 1\\equiv w_{i+1} \\bmod nwiâ€‹+1â‰¡wi+1â€‹modn é‚£ä¹ˆ nÃ—kâ‰¡1 mod nn \\times k \\equiv 1 \\bmod nnÃ—kâ‰¡1modn ï¼Œä¹Ÿå°±æ˜¯è¯´ kkk åœ¨ mod n\\bmod \\; nmodn æœ‰é€†å…ƒ xxx ï¼Œæ‰€ä»¥ n,kn, kn,k äº’è´¨ ç„¶åæ„é€ æ–¹æ¡ˆçš„è¯ï¼Œä½¿ s[i]çš„ ik,i+1k,â‹¯ ,k+iâˆ’1k\\frac{i}{k}, \\frac{i+1}{k}, \\cdots, \\frac{k+i-1}{k}kiâ€‹,ki+1â€‹,â‹¯,kk+iâˆ’1â€‹ ä¸º 111 å°±è¡Œ T2 nnn ä¸ªå­—ç¬¦ä¸²ï¼Œä»æ¯ä¸ªå­—ç¬¦ä¸²é‡Œé€‰å‡ºä¸€ä¸ªä»»æ„ä¸€ä¸ªéç©ºå‰ç¼€æŒ‰ä»»æ„é¡ºåºç»„æˆä¸€ä¸ªæ–°å­—ç¬¦ä¸²ã€‚ä½¿å¾—è¿™ä¸ªå­—ç¬¦ä¸²æœ€å° æ­£è§£å¬éš¾æƒ³çš„ï¼Œå› ä¸º nnn å¾ˆå° , é•¿åº¦ä¹Ÿå¾ˆå°ã€‚ä½¿ç”¨æœºæˆ¿ :: çš„éšæœºåŒ–ç®—æ³•ï¼Œéšæœºé€‰å– nnn ä¸ªä¸²çš„é¡ºåºå¼€æœ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 55;int n;string s[MAXN];string dfs(int x)&#123; if (x == n) return s[x].substr(1, 1); string ans = dfs(x + 1); vector &lt;string&gt; tmp; for (int i = 1; i &lt; s[x].size(); i++) tmp.push_back(s[x].substr(1, i) + ans); sort(tmp.begin(), tmp.end()); return tmp[0];&#125;string ans;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i], s[i] = &quot; &quot; + s[i]; ans = dfs(1); sort(s + 1, s + 1 + n); int tim = 4500; while (tim--) &#123; int l = rand()% n + 1; int r = rand()% n + 1; swap(s[l], s[r]); string tmp = dfs(1); if (tmp &lt; ans) ans = tmp; else swap(s[l], s[r]); &#125; cout &lt;&lt; ans; return 0;&#125; T3 ä¸€æ£µ 111 ä¸ºæ ¹çš„æ ‘ï¼Œä» 111 å‡ºå‘, æ¯æ¡è¾¹éœ€è¦ä¸€å®šçš„ä»·å€¼æ‰èƒ½å¼€é€šï¼Œåˆ°è¾¾é™¤ 111 å¤–çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥è·å¾—ä¸€å®šçš„ä»·å€¼ï¼Œè¯¢é—®è¦åˆ°è¾¾æŸä¸ªå¶å­èŠ‚ç‚¹å¼€å§‹éœ€è¦å‡†å¤‡çš„æœ€å°ä»·å€¼ã€‚ æŒºç»å…¸çš„æ‰“æ€ªé—®é¢˜ã€‚ å…ˆè€ƒè™‘å¦‚æœæ˜¯ä¸€ä¸ªåºåˆ—çš„è¯ã€‚èƒ½èµšçš„æ”¾åœ¨å‰è¾¹ï¼Œèƒ½èµšçš„é‡Œè¦é’±å°‘çš„æ”¾åœ¨å‰è¾¹ï¼Œä¼šäºçš„æ”¾åœ¨åè¾¹ï¼Œä¼šäºçš„é‡Œå›è¡€å¤šçš„æ”¾åœ¨å‰é¢ã€‚ æ—¢ç„¶åœ¨æ ‘ä¸Šï¼Œæˆ‘ä»¬å°±æ‰¾åˆ°è¿™æ ·æ’åœ¨æœ€å‰è¾¹çš„èŠ‚ç‚¹ï¼Œä»ä»–å›åˆ° 111 ï¼Œç›´åˆ°èƒ½å¤Ÿåˆ°è¾¾è¯¢é—®çš„èŠ‚ç‚¹ã€‚ å…·ä½“å¯ä»¥å¯¹æ¯ä¸ªç»“ç‚¹ç»´æŠ¤ä¸€ä¸ª set ç„¶ååˆå¹¶åˆ°æ ¹èŠ‚ç‚¹ã€‚ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline bool read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); if (ch == EOF) return false; while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; return true; &#125; template &lt;typename T&gt; inline void print(T x) &#123; if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x; if (x &gt; 9) print(x / 10); putchar(x%10 + &#x27;0&#x27;); &#125; template &lt;typename T, typename ...TT&gt; inline void print(T x, char c) &#123; print(x); putchar(c); &#125; template &lt;typename T, typename ...TT&gt; inline int read(T &amp;x, TT &amp;...y) &#123; return read(x) + read(y...); &#125;&#125;using namespace OCTANE;#define ll long long#define pir pair&lt;ll, ll&gt;const int MAXN = 2e5 + 10;const ll INF = 0x3f3f3f3f3f3f3f3f;int n;multiset &lt;pir&gt; s[MAXN];vector &lt;int&gt; e[MAXN];ll val[MAXN], cost[MAXN];void dfs(int u)&#123; for (int v : e[u]) &#123; dfs(v); if (s[u].size() &lt; s[v].size()) s[u].swap(s[v]); s[u].insert(s[v].begin(), s[v].end()); s[v].clear(); &#125; ll cst = cost[u], w = val[u] - cost[u]; while (!s[u].empty() &amp;&amp; (w &lt;= 0 || cst &gt;= s[u].begin()-&gt;first)) &#123; auto tmp = *s[u].begin(); cst += max(0ll, tmp.first - cst - w); w += tmp.second; s[u].erase(s[u].begin()); &#125; if (w &gt; 0) s[u].emplace(cst, w);&#125;int main()&#123; read(n); cost[1] = INF; for (int i = 2; i &lt;= n; i++) &#123; int f; read(f, val[i], cost[i]); f++; e[f].push_back(i); if (val[i] == -1) val[i] = INF &lt;&lt; 1; &#125; dfs(1); cout &lt;&lt; s[1].begin()-&gt;first - INF; return 0;&#125; 11.9 T1 nnn ä¸ªç‚¹çš„æ ‘ï¼Œæœ‰ç‚¹æƒï¼Œæ‚¨æœ‰è¡€é‡ï¼Œåˆ°è¾¾ä¸€ä¸ªç‚¹å°±ä¼šè·å¾—è¿™ä¸ªç‚¹çš„ç‚¹æƒï¼Œå¦‚æœè¡€é‡å°äº 000 å°±å¯„ã€‚æ¯æ¬¡ç»™å‡ºåˆå§‹è¡€é‡ï¼Œè¯¢é—®èƒ½å¦ä» sss èµ°åˆ° ttt ç‚¹ã€‚å¯ä»¥ç»è¿‡åˆ«çš„çš„ç‚¹ï¼Œä¹Ÿå¯ä»¥å¤šæ¬¡ç»è¿‡ä¸€ä¸ªç‚¹ï¼Œæ²¡ç»è¿‡ä¸€æ¬¡éƒ½ä¼šè·å¾—ç›¸åº”çš„ç‚¹æƒ èƒ½è¡Œæ˜¯è¿™ä¸¤ç§æƒ…å†µã€‚ ç›´æ¥èµ°ï¼Œæˆ–è€…å»åˆ°è·¯å¾„å¤–çš„åœ°æ–¹åŠ è¡€ã€‚ å¦‚æœç›¸é‚»ä¸¤ä¸ªç‚¹çš„å€¼åŠ èµ·æ¥æ˜¯æ­£çš„ï¼Œé‚£ä¹ˆå°±å¯ä»¥åœ¨è¿™ä¸¤ä¸ªç‚¹åŠ å¾ˆå¤šè¡€é‡ã€‚ ç¬¬ä¸€ç§æƒ…å†µç»´æŠ¤å‰ç¼€å’Œæœ€å°å€¼ï¼Œç¬¬äºŒç§æƒ…å†µ DP æ±‚æ¯ä¸ªç‚¹åˆ°è¾¾ç‰¹æ®Šç‚¹éœ€è¦çš„æœ€å°‘è¡€é‡ã€‚ T2 å¯¹äºä¸€ä¸ª 1,â€¦,n1,â€¦,n1,\\dots,n1,â€¦,n1,â€¦,n1,â€¦,n çš„æ’åˆ— a1,â€¦,ana_1,\\dots,a_na1â€‹,â€¦,anâ€‹ ï¼Œå®šä¹‰ iii å¤„çš„é¡ºåºå¯¹æ•° f(i)f(i)f(i) ä¸ºæ»¡è¶³ $ 1\\leq j$ ä¸” aj&lt;aia_j &lt; a_iajâ€‹&lt;aiâ€‹ çš„ jjj çš„æ•°é‡ï¼Œç»™å®š nnn ï¼Œå¯¹äºæ¯ä¸ª k=0,1,â€¦,nâˆ’1k=0,1,\\dots,n-1k=0,1,â€¦,nâˆ’1 æ±‚å‡ºæ»¡è¶³ maxâ¡i=1nâˆ£f(i)âˆ’g(i)âˆ£=k\\max_{i=1}^n |f(i) - g(i)| = kmaxi=1nâ€‹âˆ£f(i)âˆ’g(i)âˆ£=k çš„æ•°é‡æ¨¡ 109+710^9+7109+7 ä¸€ä¸ªä¸€ä¸ªç®—ä¸å¥½æ•´ï¼Œæˆ‘ä»¬æŠŠç­‰å·å˜æˆå°äºå·ï¼Œç„¶åå·®åˆ†å¾—åˆ°ç­”æ¡ˆã€‚ 11.10 T1 âˆ‘inâˆ‘jm[gcd(i,j)â‰¤a]lcm(i,j)\\sum_{i}^{n} \\sum_{j}^{m} \\left [ gcd(i,j) \\le a \\right ] lcm(i, j) iâˆ‘nâ€‹jâˆ‘mâ€‹[gcd(i,j)â‰¤a]lcm(i,j) nâ‰¤105n \\le 10^5nâ‰¤105 å¹¶ä¸” 10410^4104 æ¬¡è¯¢é—®ã€‚ \\begin{align} &amp;\\sum_{i}^{n} \\sum_{j}^{m} \\left [ gcd(i,j) \\le a \\right ] lcm(i, j) \\nonumber\\\\ =&amp;\\sum_{i}^{n} \\sum_{j}^{m} \\left [ gcd(i,j) \\le a \\right ] \\frac{ij}{gcd(i,j)} \\nonumber\\\\ \\end{align} æšä¸¾ gcdgcdgcd , i/ki / ki/k æ›¿æ¢ iii , j/kj / kj/k æ›¿æ¢ jjj âˆ‘kakâˆ‘iâŒŠnkâŒ‹âˆ‘jâŒŠmkâŒ‹[gcd(i,j)=1]ij\\sum_{k}^{a} k\\sum_{i}^{\\left \\lfloor \\frac{n}{k}\\right \\rfloor} \\sum_{j}^{\\left \\lfloor \\frac{m}{k}\\right \\rfloor} \\left [ gcd(i,j) = 1 \\right ]ij kâˆ‘aâ€‹kiâˆ‘âŒŠknâ€‹âŒ‹â€‹jâˆ‘âŒŠkmâ€‹âŒ‹â€‹[gcd(i,j)=1]ij å¼€å§‹ç»å…¸è«å \\begin{align} &amp;\\sum_{k}^{a} k \\sum_{i}^{\\frac{n}{k}} \\sum_{j}^{\\frac{m}{k}} \\left [ gcd(i,j) = 1 \\right ]ij \\nonumber\\\\ =&amp;\\sum_{k}^{a} k \\sum_{d}^{\\left \\lfloor \\frac{lim}{k}\\right \\rfloor} \\mu(d) d^2\\sum_{i}^{\\left \\lfloor \\frac{n}{kd}\\right \\rfloor} \\sum_{j}^{\\left \\lfloor \\frac{m}{kd}\\right \\rfloor} ij \\nonumber\\\\ =&amp;\\sum_{k}^{a} k \\sum_{d}^{\\left \\lfloor \\frac{lim}{k}\\right \\rfloor} \\mu(d) d^2\\sum_{i}^{\\left \\lfloor \\frac{n}{kd}\\right \\rfloor} \\times \\sum_{j}^{\\left \\lfloor \\frac{m}{kd}\\right \\rfloor} \\nonumber\\\\ \\end{align} ç°åœ¨åé¢ä¸¤ä¸ª O(1)O(1)O(1) ç­‰å·®æ•°åˆ—æ•´ å‰é¢è°ƒå’Œçº§æ•° å•æ¬¡è¯¢é—® O(nlogn)O(nlogn)O(nlogn) ç°åœ¨å¯ä»¥æ•´é™¤åˆ†å— kkk å’Œ ddd ã€‚å•æ¬¡è¯¢é—®æ˜¯æ¥è¿‘ O(n)O(n)O(n) ã€‚ éƒ½åªèƒ½50pts æ‰€ä»¥è¿˜éœ€ä¼˜åŒ– æ³¨æ„åˆ°ç­”æ¡ˆéš aaa å•è°ƒå¢ å¯ä»¥å…ˆæŠŠè¯¢é—®ç¦»çº¿ä¸‹æ¥ï¼ŒæŒ‰ä»å°åˆ°å¤§æ’åºã€‚æ–°åŠ å…¥ä¸€ä¸ª aaa å°±åŠ å…¥åé¢é‚£ä¸€å¨å¯¹åº”äº†ç­”æ¡ˆã€‚å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;#define ll long longconst ll mod = 1e9 + 7;const ll inv2 = 500000004;const int MAXN = 1e5 + 5;const int maxn = 1e5;using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline bool read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); if (ch == EOF) return false; while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; return true; &#125; template &lt;typename T&gt; inline void print(T x) &#123; if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x; if (x &gt; 9) print(x / 10); putchar(x%10 + &#x27;0&#x27;); &#125; template &lt;typename T, typename ...TT&gt; inline void print(T x, char c) &#123; print(x); putchar(c); &#125; template &lt;typename T, typename ...TT&gt; inline int read(T &amp;x, TT &amp;...y) &#123; return read(x) + read(y...); &#125;&#125;using namespace OCTANE;#define cntp prime[0]bool pis[MAXN];int prime[MAXN];ll mu[MAXN];struct Bit&#123; #define lowbit(i) (i &amp; -i) ll t[MAXN], lim; void add(int i, ll val) &#123; if (!i) return; for (; i &lt;= lim; i += lowbit(i)) t[i] = (t[i] + val)%mod; &#125; ll query(int i) &#123; ll res = 0; for (; i; i -= lowbit(i)) res = (res + t[i])%mod; return res; &#125; ll query(int l, int r) &#123; return (query(r) - query(l-1) +mod)%mod; &#125;&#125;t;void get_prime(int n)&#123; pis[1] = mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!pis[i]) &#123; prime[++cntp] = i; mu[i] = -1; &#125; for (int j = 1; j &lt;= cntp &amp;&amp; i * prime[j] &lt;= n; j++) &#123; pis[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125;&#125;struct que &#123; int n, m, a, id; &#125;q[MAXN];ll S(ll x, ll y) &#123; return (x + y) * (y - x + 1)%mod * inv2%mod; &#125;void add(int x)&#123; for (int i = x; i &lt;= maxn; i += x) &#123; t.add(i, 1LL*i * 1LL*i / x%mod * mu[i / x]%mod); &#125;&#125;ll work(int n, int m)&#123; ll res = 0; int N = min(n, m); for (int l = 1, r; l &lt;= N; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); res = (res + S(1LL, (ll)(n / l)) * S(1LL, (ll)(m / l))%mod * t.query(l, r)%mod) %mod; &#125; return res;&#125;ll ans[MAXN];int main()&#123; t.lim = maxn; get_prime(maxn); int T; read(T); for (int i = 1; i &lt;= T; i++) &#123; int n, m, a; read(n, m, a) ; q[i] = &#123; n, m, a, i &#125;; &#125; sort(q + 1, q + 1 + T, [&amp;](que a, que b) &#123; return a.a &lt; b.a; &#125;); int now = 1; for (int i = 1; i &lt;= T; i++) &#123; while (now &lt;= q[i].a) add(now++); ans[q[i].id] = work(q[i].n, q[i].m); &#125; for (int i = 1; i &lt;= T; i++) print(ans[i], &#x27;\\n&#x27;); return 0;&#125; T2 ä¸€å¼ è”é€šçš„å¹³é¢å›¾ï¼Œä¸¤ç§æ“ä½œï¼š åˆ å»è¾¹ (x,y)(x, y)(x,y) ï¼Œå¹¶ä¸”è¯¢é—®å‡ ä¸ªè¿é€šå— è¯¢é—®ç‚¹ x,yx, yx,y æ˜¯å¦åœ¨åŒä¸€è¿é€šå—å†… è¿™æ˜¯ä¸€å¼ å¹³é¢å›¾ã€‚å°±å»ºå‡ºå®ƒçš„å¯¹å¶å›¾æ¥ æˆ‘ä»¬æ¯åˆ å»ä¸€æ¡è¾¹ï¼Œå°±æŠŠå®ƒåœ¨å¯¹å¶å›¾å¯¹åº”çš„è¾¹è¿èµ·æ¥ã€‚å½“å¯¹å¶å›¾çš„è¾¹æŠŠä¸€ä¸ªéƒ¨åˆ†å›´èµ·æ¥æ—¶ï¼Œè¿™ä¸ªéƒ¨åˆ†å°±å½¢æˆäº†ä¸€ä¸ªæ–°çš„è¿é€šå—ã€‚ å¯¹äºç¬¬äºŒç§è¯¢é—®ï¼Œæˆ‘ä»¬åœ¨å½¢æˆä¸€ä¸ªæ–°è¿é€šå—ä¸­ï¼Œå¯ä»¥å¯¹æ–°çš„è¿é€šå—é‡æ–°ç¼–å·ã€‚ä½†æ˜¯å°½é‡éå†å°‘çš„ç‚¹ä¿è¯æ—¶é—´å¤æ‚åº¦ï¼Œæˆ‘ä»¬å°±é€‰æ‹©å¤§å°å°çš„è”é€šå—æ¥æ ‡å·ã€‚ 11.11 T1 ç»™å®šä¸€ä¸ªåºåˆ—ï¼Œæ¯ä¸ªæ•°éƒ½æ˜¯ç”±ä¸¤ä¸ªä¸ç›¸åŒçš„è´¨æ•°çš„ä¹˜ç§¯ã€‚è‹¥ a=p1âˆ—q1(p1&lt;q1),b=p2âˆ—q2(p2&lt;q2)a=p_{1} * q_{1}\\left(p_{1}&lt;q_{1}\\right), b=p_{2} * q_{2}\\left(p_{2}&lt;q_{2}\\right)a=p1â€‹âˆ—q1â€‹(p1â€‹&lt;q1â€‹),b=p2â€‹âˆ—q2â€‹(p2â€‹&lt;q2â€‹) ï¼Œ q1=p2q_1 = p_2q1â€‹=p2â€‹ æ—¶ï¼Œ bbb èƒ½æ¥åœ¨ aaa åã€‚æœ€é•¿èƒ½æ¥å¤šé•¿ï¼Ÿã€‚ å¯¹äºæ¯ä¸ªæ•°ï¼Œå‘ ppp çš„å€¼å’Œå®ƒçš„ qqq ç›¸ç­‰çš„è¿è¾¹ï¼Œè¡¨ç¤ºå®ƒä¿©èƒ½æ¥èµ·æ¥ã€‚ æœ€åå»ºå‡ºæ¥æ˜¯ä¸€å¼  DAG ã€‚åœ¨ä¸Šé¢æ‰¾æœ€é•¿é“¾å³å¯ã€‚ T2 nnn ä¸ªç‚¹ mmm æ¡è¾¹ï¼Œç»™ä¸€ä¸ªç”Ÿæˆæ ‘ï¼Œå¯ä»¥æŠŠä¸€æ¡è¾¹æƒå‡ä¸€ï¼Œè¯¢é—®è¦å¤šå°‘æ“ä½œæ‰èƒ½ä½¿ä»–æˆä¸ºæœ€å°ç”Ÿæˆæ ‘ã€‚ ä¸¤ä¸ªç‚¹åœ¨å¦‚æœæœ‰è·¯å¾„çš„è¯ï¼Œé‚£ä¹ˆç”Ÿæˆæ ‘çš„è·¯å¾„ä¸Šçš„æ¯ä¸€æ¡è¾¹çš„è¾¹æƒéƒ½ä¸èƒ½å¤§äºå®ƒæ‰èƒ½æˆä¸ºæœ€å°ç”Ÿæˆæ ‘ã€‚ æ‰€ä»¥æšä¸¾æ¯æ¡éæ ‘è¾¹ï¼Œå¯¹æ ‘ä¸Šè·¯å¾„è¿›è¡Œæœ€å°å€¼è¦†ç›–ã€‚æœ€åè¾¹æƒå‡å°‘äº†å¤šå°‘å°±æ˜¯ç­”æ¡ˆã€‚ T3 ç»™å®šä¸¤ä¸ªæ•° AAA , BBB ã€‚é—®æœ‰å¤šå°‘åºåˆ—æ»¡è¶³ï¼š åºåˆ—é€’å¢ å€¼åŸŸ âˆˆ[A,B]\\in [A, B]âˆˆ[A,B] æ‰€æœ‰æ•°å­—ä¸¤ä¸¤äº’è´¨ã€‚ è™½ç„¶ A,BA, BA,B æ˜¯ 101810^{18}1018 çº§åˆ«ï¼Œä½†æ˜¯ Bâˆ’Aâ‰¤100B - A \\le 100Bâˆ’Aâ‰¤100 ï¼Œé‚£ä¹ˆå¯ä»¥çŠ¶å‹ 100100100 ä»¥å†…çš„è´¨æ•°æ¥ DPDPDP ã€‚ åªå‡ºç°ä¸€æ¬¡ä¹Ÿæ²¡å½±å“ï¼Œé‚£ä¹ˆçŠ¶å‹åªå‡ºç°å¤šæ¬¡çš„è´¨å› å­å°±è¡Œäº†ã€‚ DP å°±æ˜¯æšä¸¾è¡¥é›†çš„å­é›†æ›´æ–°ã€‚ T4 ç»™å®šä¸€ä¸ªåºåˆ—ï¼Œè¯¢é—®åºåˆ—çš„æœ€é•¿å­ä¸²ã€‚èƒ½å¤Ÿæœ€å¤šåŠ  kkk ä¸ªæ•°æ„æˆå…¬å·®ä¸º ddd çš„ç­‰å·®æ•°åˆ—ã€‚ è€ƒè™‘èƒ½æ„æˆç­‰å·®æ•°åˆ—çš„è¯ï¼Œé‚£ä¹ˆå­—ä¸²é‡Œçš„æ¯ä¸ªæ•° mod d\\bmod dmodd éƒ½ç›¸ç­‰ã€‚æ‰€ä»¥åˆ¤æ–­æ¡ä»¶å°±æ˜¯ mod çš„\\bmod çš„modçš„ ç›¸ç­‰å¹¶ä¸”é™¤çš„æå·® âˆ’-âˆ’ åŒºé—´é•¿åº¦ä¸è¶…è¿‡ kkk ã€‚ å³ç«¯ç‚¹ç¡®å®šï¼Œå·¦ç«¯ç‚¹å…·æœ‰å•è°ƒæ€§ã€‚æ‰€ä»¥æšä¸¾å³ç«¯ç‚¹ï¼Œçº¿æ®µæ ‘ç»´æŠ¤æ¯ä¸ªå·¦ç«¯ç‚¹çš„æå·®ã€‚ æšä¸¾æ•´ä¿©å•è°ƒæ ˆï¼Œç„¶ååœ¨çº¿æ®µæ ‘ä¸ŠäºŒåˆ†æ‰¾ç­”æ¡ˆã€‚ 11.12 T1 ä¸€é¢—å¸¦æƒæ ‘ï¼Œæ ‘ä¸Šæœ‰é»‘ç‚¹å’Œç™½ç‚¹ï¼Œæ±‚å‰²æ‰ä¸€äº›è¾¹ï¼ŒæŠŠé»‘ç‚¹å’Œç™½ç‚¹åˆ†å¼€éœ€è¦çš„æœ€å°ä»£ä»·ã€‚ fu,0/1f_{u, 0/1}fu,0/1â€‹ è¡¨ç¤ºåœ¨ uuu å¼ºåˆ¶ä¸º é»‘ç‚¹/ç™½ç‚¹ æ—¶çš„ç­”æ¡ˆã€‚ å’Œå„¿å­ä¸ä¸€æ ·å°±è¦å‰²æ‰è¿™æ¡è¾¹ã€‚ä¸åˆæ³•æƒ…å†µèµ‹æå°å€¼ T2 nnn é“é¢˜ç›®ï¼Œæ¯é“é¢˜æ‚¨éœ€è¦ aia_iaiâ€‹ çš„æ—¶é—´æ¥ A æ‰ã€‚åš mmm é“é¢˜æ‚¨å°±èƒ½ AuAuAu ï¼Œä½†æ˜¯æ‚¨ä¸çŸ¥é“æ¯ä¸ªé¢˜çš„éš¾åº¦ï¼ŒåªçŸ¥é“æ‰¾äººå†™é¢˜ç›®çš„éš¾åº¦æ„æˆ aaa è¿™ä¸ªåºåˆ—ã€‚æ±‚ä½¿ç”¨æœ€ä¼˜ç­–ç•¥æœ€åè¦å¤šé•¿æ—¶é—´æ‰èƒ½ AuAuAu ã€‚ å› ä¸ºæ˜¯æœ€åï¼Œæ‰€ä»¥åšçš„é¢˜çš„éš¾åº¦ä¸€å®šæ˜¯ä¸‹é™çš„ã€‚ä¹Ÿå°±æ˜¯è¯´é¢˜ç›®éš¾åº¦å’Œæ—¶é—´æ˜¯ä¸€ä¸ªä¸‹é™çš„ç›´çº¿ã€‚ é‚£ä¹ˆè¦ A ä¸€é“é¢˜ä¸€å®šæ˜¯æ¯æ¬¡éƒ½ç”¨è¿™é“é¢˜çš„æ—¶é—´åšï¼Œç„¶åå‘ç°æ²¡A ï¼Œå°±æ¢ä¸‹ä¸€é“é¢˜ï¼ŒçŸ¥é“ A æ‰è¿™é“é¢˜ã€‚ è®¾ fi,jf_{i, j}fi,jâ€‹ è¡¨ç¤ºåšåˆ°ç¬¬ iii é“é¢˜ï¼Œå·²ç» A äº† jjj åˆ°éœ€è¦çš„æ—¶é—´ã€‚ fi,j=fk,jâˆ’1+(iâˆ’k)âˆ—aif_{i,j} = f_{k, j-1} + (i-k) * a_ifi,jâ€‹=fk,jâˆ’1â€‹+(iâˆ’k)âˆ—aiâ€‹ å‘ç°å¯ä»¥æ–œç‡ä¼˜åŒ–ã€‚ 11.14 T1 å¹³é¢ç›´è§’åæ ‡ç³»ä¸Šï¼Œä» (a,b)(a, b)(a,b)ï¼Œæ¯æ¬¡å¯ä»¥ä¸Šä¸‹å·¦å³èµ°ä¸€ä¸ªå•ä½(ä¿è¯åæ ‡éè´Ÿ)ã€‚èµ°åˆ° (c,d)(c,d)(c,d)ã€‚ç–²åŠ³å€¼åˆå§‹å€¼ä¸º 000ã€‚å¦‚æœå½“å‰ä½ç½® (x,y)(x,y)(x,y) æ»¡è¶³ x andâ¡ y&gt;0x \\, \\operatorname{and} \\, y &gt; 0xandy&gt;0ï¼Œç–²åŠ³å€¼å°±è¦åŠ  111ï¼Œå¦åˆ™ç–²åŠ³å€¼ä¸å¢åŠ ã€‚æ±‚æœ€å°ç–²åŠ³å€¼ã€‚ æ‰“ä¸ªè¡¨å¯ä»¥å‘ç°ï¼Œxandâ¡y=0x \\operatorname{and} y = 0xandy=0 çš„ä½ç½®ç»„æˆäº†ä¸€ä¸ªè°¢å°”å®¾æ–¯åŸºä¸‰è§’å½¢ã€‚ è€Œä¸”æ˜¯å››è”é€šçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ä» (a,b)(a,b)(a,b) èµ°åˆ° (c,d)(c,d)(c,d) å°±æœ‰ä¸¤ç§å¯èƒ½æ˜¯æœ€ä¼˜çš„æ–¹æ¡ˆï¼š éƒ½èµ°åˆ°è´¹ç”¨ä¸º 000 çš„ç‚¹ã€‚ ç›´æ¥èµ° é‚£ä¸ªä¸‰è§’å½¢çœ‹ä¸Šå»æŒºé€’å½’çš„ï¼Œæˆ‘ä»¬ä¹Ÿé€’å½’æ±‚ã€‚ æ‰¾åˆ°è¦†ç›– (x, y) çš„ä¸‰è§’å½¢ã€‚ç”±äº dis(x,y)=dis(y,x)dis(x, y) = dis(y, x)dis(x,y)=dis(y,x) ï¼Œè®¾ xâ‰¤yx \\le yxâ‰¤yã€‚ è®¾ä¸‰è§’å½¢çš„è¾¹é•¿ä¸º LLL ã€‚ å¦‚æœ x+yâ‰¥Lx + y \\ge Lx+yâ‰¥L ï¼Œè¯´æ˜ (x,y)(x, y)(x,y) ä½äºè¯¥æ­£æ–¹å½¢å³ä¸‹éƒ¨åˆ†çš„ç­‰è…°ç›´è§’ä¸‰è§’å½¢ï¼Œèµ°åˆ°ä¸‰è§’å½¢ä¸‰è¾¹çš„ç–²åŠ³å€¼åˆ†åˆ«æ˜¯ x+yâˆ’L,Lâˆ’xâˆ’1,Lâˆ’yâˆ’1x + y - L, L - x - 1, L - y - 1x+yâˆ’L,Lâˆ’xâˆ’1,Lâˆ’yâˆ’1ï¼Œå–æœ€å°å€¼ å¦åˆ™ (x,y)(x, y)(x,y) åœ¨è¯¥æ­£æ–¹å½¢å³ä¸Šéƒ¨åˆ†ã€‚æŠŠ å‘å·¦å¹³ç§» L/2L / 2L/2 é•¿åº¦ä¸æ”¹å˜ç­”æ¡ˆï¼Œæ‰€ä»¥ç›´æ¥å¹³ç§»é€’å½’ä¸‹å»ã€‚ T2 ç»™ä½ ä¸€ä¸ªåªåŒ…å«å­—ç¬¦ a å’Œ b çš„å­—ç¬¦ä¸² sssï¼Œä½ éœ€è¦æ±‚å‡ºæœ€å¤šæœ‰å¤šå°‘ä¸ç›¸äº¤çš„å­åºåˆ— ababã€‚ ä¸ç›¸äº¤çš„å®šä¹‰ä¸ºï¼šå¯¹äº sss ç§çš„æ¯ä¸ªå­—ç¬¦ï¼Œå…¶æœ€å¤šå¤„äºä¸€ä¸ªå­åºåˆ—ä¸­ã€‚ Solution å‘ç° abab å¯ä»¥æ‹†æˆä¸¤ä¸ª abï¼Œé—®é¢˜å°±å˜æˆäº†å»é™¤å°½å¯èƒ½å¤šçš„ä¸ç›¸äº¤çš„ ab ã€‚ ä¸èƒ½åŒæ—¶é€‰çš„ ab å­˜åœ¨ä¸€ä¸ªåˆ†ç•Œç‚¹ pâˆˆ[1,n]p \\in [1,n]pâˆˆ[1,n]ï¼Œä½¿å¾—æ‰€æœ‰ a çš„ä½ç½®å°äºç­‰äº pppï¼Œæ‰€æœ‰ bbb çš„ä½ç½®å¤§äºç­‰äº pppã€‚ è®¾ä¸èƒ½åŒæ—¶é€‰çš„ ab çš„æœ€å¤§å€¼ä¸º mxmxmxï¼Œå…±æœ‰ cntcntcnt å¯¹ abï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ minâ¡(âŒŠcnt2âŒ‹,cntâˆ’mx)\\min(\\lfloor \\frac{cnt}{2} \\rfloor, cnt-mx)min(âŒŠ2cntâ€‹âŒ‹,cntâˆ’mx)ã€‚ ç°åœ¨å°±éœ€è¦ä½¿ mxmxmx æœ€å°åŒ–ï¼Œè¿™ä¸ªå¯ä»¥ä½¿æ¯ä¸ª bbb å»åŒ¹é…å®ƒå‰é¢æœ€è¿‘çš„æœªè¢«åŒ¹é…çš„ aaaï¼Œè¿™æ ·å¯ä»¥ä½¿è¿™ä¸€å¯¹ ab åŒ…å«çš„å…¶ä»– ab æœ€å°‘ï¼Œæ‰€ä»¥ç”¨ä¸€ä¸ªæ ˆåšä¸€ä¸‹æ‹¬å·åŒ¹é…å°±è¡Œäº†ã€‚ T3 ç”¨ 000 ä»£è¡¨ç©ºæ ‘ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­æ ‘ï¼Œé‚£ä¹ˆè®¤ä¸ºå®ƒçš„å·¦å­æ ‘æ˜¯ç©ºæ ‘(å³å­æ ‘åŒç†)ã€‚å¯¹ä»»æ„äºŒå‰æ ‘ AAAï¼Œ0â‰¤A0 \\le A0â‰¤A æˆç«‹ï¼›å¯¹ä»»æ„éç©ºäºŒå‰æ ‘ AAAï¼ŒAâ‰¤0A \\le 0Aâ‰¤0 ä¸æˆç«‹ï¼Œåˆ™å¯¹äºéç©ºäºŒå‰æ ‘ A,BA,BA,Bï¼ŒAâ‰¤BA \\le BAâ‰¤B å½“ä¸”ä»…å½“ lsâ¡(A)â‰¤lsâ¡(B)\\operatorname{ls}(A) \\le \\operatorname{ls}(B)ls(A)â‰¤ls(B) ä¸” rsâ¡(B)â‰¤rsâ¡(A)\\operatorname{rs}(B) \\le \\operatorname{rs}(A)rs(B)â‰¤rs(A)ã€‚ é—®æœ‰å¤šå°‘ä¸åŒåœ¨ AAA ä¸ŠåŠ  mmm ä¸ªç‚¹çš„ BBB ï¼Œæ»¡è¶³ Aâ‰¤BA \\le BAâ‰¤Bã€‚ æˆ‘ä»¬åªèƒ½åœ¨ç‰¹å®šçš„èŠ‚ç‚¹æ”¾ï¼Œå¯ä»¥ä¸€æ¬¡ dfsdfsdfs æ±‚å‡ºã€‚ æœ‰ ccc ä¸ªäº’ç›¸ç‹¬ç«‹çš„ä½ç½®ï¼Œæ”¾ä¸Š mmm ä¸ªèŠ‚ç‚¹ï¼Œé—®æœ€ç»ˆå½¢æˆçš„äºŒå‰æ ‘æ£®æ—æœ‰å‡ ç§ã€‚ è®¾ f(c,m)f(c,m)f(c,m) è¡¨ç¤ºä¸Šè¿°é—®é¢˜çš„ç­”æ¡ˆã€‚ f(c,m)=f(c+1,mâˆ’1)+f(câˆ’1,m)f(c,m) = f(c+1,m-1) + f(c-1, m)f(c,m)=f(c+1,mâˆ’1)+f(câˆ’1,m) ï¼Œå› ä¸º å¦‚æœæœ‰ä¸€ä¸ªèŠ‚ç‚¹æŒ‚åœ¨ç¬¬ ccc ä¸ªä½ç½®ï¼ŒèŠ‚ç‚¹æ•°å‡å°‘ 111ï¼Œäº’ç›¸ç‹¬ç«‹çš„ä½ç½®æ•°åè€Œå¢åŠ äº† 111ï¼ŒçŠ¶æ€è½¬ç§»ä¸º f(c+1,mâˆ’1)f(c+1,m-1)f(c+1,mâˆ’1)ã€‚ å¦‚æœæ²¡æœ‰èŠ‚ç‚¹æŒ‚åœ¨ç¬¬ ccc ä¸ªä½ç½®ï¼Œä¹Ÿå°±æ˜¯å†ä¹Ÿä¸ç”¨ä½ç½® cccï¼ŒçŠ¶æ€è½¬ç§»ä¸º f(câˆ’1,m)f(c-1,m)f(câˆ’1,m)ã€‚ è¿™ä¸ªå¼å­å¯ä»¥è½¬åŒ–ä¸ºè·¯å¾„è®¡æ•°ï¼š å¦‚æœä½ç½®åœ¨ (x,y)(x,y)(x,y)ï¼Œä¸‹ä¸€æ­¥å¯ä»¥èµ°åˆ° (xâˆ’1,y+1)(x-1,y+1)(xâˆ’1,y+1) æˆ– (x+1,y)(x+1,y)(x+1,y)ï¼Œä½†å§‹ç»ˆä¿è¯ x&gt;0x &gt; 0x&gt;0ï¼Œæ±‚ä» (1,0)(1,0)(1,0) èµ°åˆ° (c,m)(c,m)(c,m) çš„è·¯å¾„æ¡æ•°ã€‚ æŠŠåæ ‡å˜æ¢ä¸º (x+y,y)(x+y, y)(x+y,y)ï¼Œå¾—åˆ°æ›´ç†Ÿæ‚‰çš„å½¢å¼ï¼š å¦‚æœä½ç½®åœ¨ (x,y)(x,y)(x,y)ï¼Œä¸‹ä¸€æ­¥å¯ä»¥èµ°åˆ° (x,y+1)(x,y+1)(x,y+1) æˆ– (x+1,y)(x+1,y)(x+1,y)ï¼Œä½†å§‹ç»ˆä¿è¯ x&gt;yx &gt; yx&gt;yï¼Œæ±‚ä» (1,0)(1,0)(1,0) èµ°åˆ° (c+m,m)(c+m,m)(c+m,m) çš„è·¯å¾„æ¡æ•°ã€‚ ç­”æ¡ˆä¸º Cc+2mâˆ’1mâˆ’Cc+2mâˆ’1cC_{c+2m-1}^{m} - C_{c+2m-1}^{c}Cc+2mâˆ’1mâ€‹âˆ’Cc+2mâˆ’1câ€‹","categories":[],"tags":[]},{"title":"csp 2022æ¸¸è®°","slug":"csp-2022æ¸¸è®°","date":"2022-10-30T06:13:06.000Z","updated":"2022-11-08T10:40:12.419Z","comments":true,"path":"2022/10/30/csp-2022æ¸¸è®°/","link":"","permalink":"https://ve1bae.github.io/2022/10/30/csp-2022%E6%B8%B8%E8%AE%B0/","excerpt":"æˆ‘æ˜¯ fwfwfwfw å·²ç»åšå¥½é€€å½¹å‡†å¤‡äº†å—· ğŸƒğŸƒğŸƒ","text":"æˆ‘æ˜¯ fwfwfwfw å·²ç»åšå¥½é€€å½¹å‡†å¤‡äº†å—· ğŸƒğŸƒğŸƒ day -8 æ¥åˆ°çŸ³å®¶åº„éš”ç¦»ï¼Œçˆ½çœ‹ day 0 æ™šä¸Šçˆ½çœ‹ day 1 ä¸Šåˆçˆ½çœ‹ ä¸‹åˆå¯„ è¿›åœºå¼€è€ƒ wcå¥”è…¾ç”µè„‘ dev æŠŠæˆ‘ ğŸ‘€ æ•´çäº†å—· T1 å¼€è€ƒå…ˆçœ‹äº†å°†è¿‘ä¸€ä¸ªåŠå°æ—¶ è¿˜æ˜¯ä¸€ç‚¹å„¿æ€è·¯éƒ½æ²¡ï¼Œè¿ n4n^4n4 éƒ½ä¸ä¼šï¼Œçˆ½å¯„ å¯èƒ½æ˜¯ä¸ª DP ? ä½†æ˜¯å¤ªç¦»è°±äº†æ²¡æ³•å†™å§ æœ€åè¿˜æ˜¯è§‰å¾—çˆ†æœæœ€å¯¹å‘³è¾£ ğŸ˜… æ¶¦æ¶¦æ¶¦ ğŸƒ T2 ä¸€çœ¼é¡¶é’ˆé‰´å®šä¸ºå¤§åŠ›åˆ†ç±»è®¨è®º çº¿æ®µæ ‘ç»´æŠ¤ä¹±ä¸ƒå…«ç³Ÿæœ€å€¼å¼€ç  ä»£ç èƒ½åŠ›è¿˜æ˜¯æ‹‰ï¼Œdeäº†ä¸€æ®µæ—¶é—´bug 40min æ¶¦ã€‚ ğŸƒ å†™å®Œä¸Šä¸ªå•æ‰€å¯»æ‰¾æ€è·¯ T3 çœ‹ä¸Šå»åº”è¯¥æ˜¯è¦åˆ¤ä¸ªç¯ä»€ä¹ˆçš„ï¼Œæ²¡ä»€ä¹ˆæ€è·¯ æœ€åæš´åŠ›æ²¡æ—¶é—´å†™äº†ï¼Œçˆ½å¯„ ğŸƒğŸƒğŸƒ T4 å…ˆå†™äº†ä¸ª k = 1 ï¼Œä¸ä¼šæ ‘ä¸Šå·®åˆ†æ‰€ä»¥ æ ‘å‰– + çº¿æ®µæ ‘å¼€ç  ç„¶åè§‰å¾—è‚¯å®šæ˜¯åœ¨é€‰åœ¨é“¾ä¸Šçš„ç‚¹ï¼ŒæŠŠé“¾æ‹‰å‡ºæ¥ å†™äº†ä¸ª nqnqnq DP è°ƒåˆ°ç»“æŸåˆšè¿‡å°æ ·ä¾‹ã€‚æ¶¦äº† ğŸƒ æœ€åéƒ½æ²¡æ—¶é—´æ²¡æ•´å‹ç¼©æ–‡ä»¶æ€¥æ­»æˆ‘äº† ğŸƒğŸƒğŸƒ èµ›å å‡ºè€ƒåœºä½¬å‘Šè¯‰æˆ‘ nmè™šæ‹Ÿæœºæœ‰ nm Vscode è¿˜æœ‰nm cpptools é€†å¤§å¤©ã€‚ è¯´ä¸å®šè¿™æ˜¯å”¯ä¸€ä¸€æ¬¡èƒ½åœ¨åœºä¸Šå¼€æŒ‚çš„æœºä¼šåŠ› ä¼°åˆ† 40 + 100 + 0 + 52 = 192 æœºæˆ¿ä½¬å…¨éƒ½ 300+ã€‚è¿˜æ˜¯æˆ‘å¤ªèœäº† æ™šä¸Šçˆ½çœ‹ å¯„å¯„å¯„å¯„ã€‚ day2 å›å­¦ç¬‘äº† æ°‘é—´æ•°æ® 45 + 90 + 0 + 16 = 151 T2 æŒ‚äº† 10åˆ† T4 DP å¯„äº†ã€‚èµ›åå‘ç°è¿å¤§æ ·ä¾‹éƒ½æ²¡è¿‡ åŸæ¥æ›´èœå•Š æ»šå›æœºæˆ¿çˆ½ç¿ â€¦å“ˆå“ˆæ²¡å†™è¿‡å¯¹æ‹ï¼Œä¸çŸ¥é“æ€ä¹ˆ fc ï¼Œç”¨ ğŸ‘€ æµ‹å¤§æ ·ä¾‹äº† é€†å¤©å§æ§½ï¼Œ T2 90åˆ† åŸæ¥æ˜¯ä¸€ç§æƒ…å†µè¾“å‡ºæ¯æ¢è¡Œå§æ§½ï¼ï¼ è¦æŒ‚æˆ 0 ğŸ¥š äº† ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ åŸæ¥æ°‘é—´æ•°æ®æ˜¯çœŸæ°‘é—´å•Š åŸæ¥å®˜æ–¹æ•°æ®æ—¶æ›´æ°‘é—´å•Š 55 + 65 + 0 + 20 = 140 ğŸ˜†ğŸ˜†ğŸ˜†ğŸ˜†ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ å¸Œæœ› noip æˆ‘ä¸ä¼šè¾“å‡º NO ä¹Ÿèƒ½æ‹¿45åˆ† èµç¾","categories":[],"tags":[{"name":"æ€»ç»“","slug":"æ€»ç»“","permalink":"https://ve1bae.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"fan_si_gui_hua","slug":"fan-si-gui-hua","date":"2022-10-09T13:46:28.000Z","updated":"2022-11-08T10:40:24.451Z","comments":true,"path":"2022/10/09/fan-si-gui-hua/","link":"","permalink":"https://ve1bae.github.io/2022/10/09/fan-si-gui-hua/","excerpt":"","text":"åæ€çš„è¯æ²¡ä»€ä¹ˆå¥½è¯´æ¯•ç«Ÿå·²ç»è¾¾åˆ°æé™äº†çš„ä»Šåä¹Ÿè¦æ›´åŠ åŠªåŠ›çš„å¥–åŠ±è‡ªå·± ç›®å‰çš„äººç”Ÿè§„åˆ’æ˜¯AKå›½é™…åˆä¸­ç”Ÿä¿¡æ¯å­¦ç«èµ›ç„¶åé¡ºåŠ¿å»å…«å¹¡å¸‚ç«é€‰å¸‚é•¿è¿å¨¶å‰ä»»å¸‚é•¿çš„å¥³å„¿è®©å¥¹å›åˆ°å·²ç»è¢«æˆ‘ç”¨æ‘©æ‹‰æ”¶è´­çš„äº¬é˜¿å°¼æ‹…ä»»ç›‘ç£åœ¨åŠ¨ç”¨å¦»å­çš„å…³ç³»è¦åˆ°å±±ç”°å°šå­çš„ç­¾åæœ€ç»ˆçš„ç›®çš„æ˜¯è·ªåœ¨å¥¹çš„è„šè¾¹æ±‚å¥¹èƒ½å¤Ÿå¼ºåŠ¿å›å½’æˆ–è€…è®©æˆ‘æŠŠäº¬é˜¿å°¼é€ç»™å¥¹ä¹Ÿæ²¡äº‹æ¯•ç«Ÿæ˜¯ç¥åæ­£åªè¦åšå‡ºäº¬å¹ä¸‰åªç»™æˆ‘ä¸€ä¸ªäººçœ‹å°±è¡Œäº†","categories":[],"tags":[{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://ve1bae.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"è´ªå¿ƒ","slug":"è´ªå¿ƒ","permalink":"https://ve1bae.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"10æœˆæ¯æ—¥æ€»ç»“","slug":"10æœˆæ¯æ—¥æ€»ç»“","date":"2022-10-08T00:55:25.000Z","updated":"2022-11-11T10:47:47.776Z","comments":true,"path":"2022/10/08/10æœˆæ¯æ—¥æ€»ç»“/","link":"","permalink":"https://ve1bae.github.io/2022/10/08/10%E6%9C%88%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/","excerpt":"æ—¥ã€…ç§ãŸã¡ãŒéã”ã—ã¦ã„ã‚‹æ—¥å¸¸ã¯ã€å®Ÿã¯ã€å¥‡è·¡ã®é€£ç¶šãªã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚ æˆ‘ä»¬æ‰€ç»å†çš„æ¯ä¸ªå¹³å‡¡çš„æ—¥å¸¸ï¼Œä¹Ÿè®¸å°±æ˜¯è¿ç»­å‘ç”Ÿçš„å¥‡è¿¹ã€‚ â€”â€”ã€Šæ—¥å¸¸ã€‹","text":"æ—¥ã€…ç§ãŸã¡ãŒéã”ã—ã¦ã„ã‚‹æ—¥å¸¸ã¯ã€å®Ÿã¯ã€å¥‡è·¡ã®é€£ç¶šãªã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚ æˆ‘ä»¬æ‰€ç»å†çš„æ¯ä¸ªå¹³å‡¡çš„æ—¥å¸¸ï¼Œä¹Ÿè®¸å°±æ˜¯è¿ç»­å‘ç”Ÿçš„å¥‡è¿¹ã€‚ â€”â€”ã€Šæ—¥å¸¸ã€‹ 10.1 T1 æœ‰ä¸€æ¬¾æ¸¸æˆï¼Œå®ƒæœ‰ nnn ä¸ªå…³å¡ï¼Œç¬¬ nnn ä¸ªå…³å¡çš„éš¾åº¦æ˜¯ pip_ipiâ€‹ï¼Œå·²çŸ¥ nnn æ˜¯ 1,â€¦,n1,\\dots,n1,â€¦,n çš„ä¸€ä¸ªæ’åˆ—ã€‚ç©å®¶ä¸å¿…æŒ‰ç…§ 111 åˆ° nnn çš„é¡ºåºé€šè¿‡è¿™ nnn ä¸ªå…³å¡ï¼Œä»–ä»¬å¯ä»¥è‡ªå·±é€‰æ‹©é—¯å…³çš„é¡ºåºã€‚å¯¹äºæ¯ä¸€ä¸ªå…³å¡ï¼Œæ¸¸æˆå®šä¹‰äº†ä¸€ä¸ªé‡è¦åº¦ did_idiâ€‹ ï¼Œä¸º ppp çš„å‰ç¼€æœ€å°å€¼ï¼Œå°kæ¯æ¬¡æƒ é€‰æ‹© ddd æœ€ä½çš„å…³å¡é—¯å…³ï¼Œç‰¹æ®Šåœ°ï¼Œå¦‚æœè¿™æ ·çš„å…³å¡æœ‰å¾ˆå¤šä¸ªï¼Œé‚£ä¹ˆä»–ä¼šé€‰æ‹©ç¼–å·æœ€å°çš„é‚£ä¸€ä¸ªã€‚ç»™å‡ºå°k é€šå…³çš„é¡ºåºï¼Œæ±‚å‡ºæ‰€æœ‰å¯èƒ½çš„éš¾åº¦ä¸­å­—å…¸åºæœ€å°çš„ ç®€å•æ„é€ ã€‚å…ˆæ„é€  ddd ï¼Œå¿…è¦çš„æ—¶å€™åŠ ä¸€ï¼Œä¹Ÿå°±æ˜¯è¯´ aaa çš„ä¸‹æ ‡æ¯” bbb çš„ä¸‹æ ‡æ›´é å‰ï¼Œå´å…ˆæ‰“äº† bbb ï¼Œé‚£ä¹ˆ aaa çš„é‡è¦åº¦ä¸€å®šæ˜¯æ›´é«˜çš„ ç„¶åæ ¹æ® ddd æ„é€  ppp å³å¯ T2æ´›è°· P3616 å°Pçš„å®¶é—¨å‰æœ‰ä¸€æ¡æ²³ï¼Œå®ƒæ¯å¤©è¦è§‚å¯Ÿè¿™æ¡æ²³ï¼Œå¹¶ä¸”ç»Ÿè®¡æ²³ä¸­å²›å±¿çš„ä¸ªæ•°ã€‚æ²³åºŠçš„åœ°å½¢å¯ä»¥æŠ½è±¡ä¸ºä¸€ä¸ªé•¿åº¦ä¸º nnn çš„æ•°åˆ— ai{a_i}aiâ€‹ï¼Œç¬¬ iii ä½çš„æ•°å­—ä»£è¡¨æ²³åºŠå¯¹åº”ä½ç½®çš„é«˜åº¦ã€‚å½“æ°´ä½ä¸º hhh æ—¶ï¼Œæ‰€æœ‰é«˜åº¦ä½äº hhh çš„ä½ç½®éƒ½ä¼šè¢«æ°´è¦†ç›–ï¼Œé«˜åº¦å¤§äºç­‰äº hhh çš„åœ°å½¢å°±éœ²å‡ºæ°´é¢ï¼Œè¿æˆäº†å²›å±¿ã€‚è¯·ä½ ååŠ©å° P ç»Ÿè®¡æ¯ä¸€å¤©çš„å²›å±¿çš„ä¸ªæ•°ã€‚æ²³åºŠæ¯ä¸ªä½ç½®çš„é«˜åº¦å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ï¼Œè€Œä¸”æ°´ä½ä¹Ÿä¼šå‘ç”Ÿå˜åŒ–ã€‚ å¦‚æœå½¢æˆäº†å²›å±¿ä¸€å®šæ˜¯ hiâ‰¥h,hi+1&lt;hh_i \\ge h, h_{i+1} &lt; hhiâ€‹â‰¥h,hi+1â€‹&lt;h é‚£ä¹ˆä»¥ hih_ihiâ€‹ ä¸ºæ¨ªåæ ‡ï¼Œhi+1h_{i+1}hi+1â€‹ ä¸ºçºµåæ ‡æ„å»ºä¸€ä¸ªäºŒç»´å¹³é¢é‚£ä¹ˆç­”æ¡ˆåº”è¯¥æ˜¯è¿™éƒ¨åˆ† ä½¿ç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤ T3 ç»™å®šä¸€ä¸ªåªç”±éè´Ÿæ•´æ•°å’ŒåŠ å‡å·ç»„æˆçš„ç®—å¼ã€‚å®ƒæƒ³ç»™è¿™ä¸ªç®—å¼æ·»åŠ åˆæ³•çš„æ‹¬å·ï¼Œä½¿å¾—ç®—å¼çš„ç»“æœæœ€å¤§ï¼Œæ‹¬å·å¯ä»¥åµŒå¥—ã€‚ çº¿æ€§ dp fi,jf_{i, j}fi,jâ€‹ è¡¨ç¤ºå‰ iii ä¸ªæ•°ï¼Œç¼ºäº† jjj ä¸ªå³æ‹¬å·éœ€è¦é…å¯¹çš„æœ€å¤§ç­”æ¡ˆï¼Œæ ¹æ®å½“å‰ä½ç½®åŠ ä»€ä¹ˆæ‹¬å·è½¬ç§» Code 1234567891011121314f[0][0] = 0;f[0][1] = f[0][2]=-1e18;for (int i = 1; i &lt;= n; i++) if (a[i] &lt; 0)&#123; f[i][0] = f[i-1][0] + a[i]; f[i][2] = max(f[i-1][1], f[i-1][2]) - a[i]; f[i][1] = max(max(f[i-1][0], f[i-1][1]), f[i-1][2]) + a[i];&#125;else&#123; f[i][0] = max(max(f[i-1][0], f[i-1][1]), f[i-1][2]) + a[i]; f[i][1] = max(f[i-1][1], f[i-1][2]) - a[i]; f[i][2] = f[i-1][2] + a[i];&#125; 10.2 T1 æœ‰ä¸¤ç±»å¥‡ç‰¹çš„ç”Ÿç‰© A å’Œ Bï¼Œå…¶åŸºå› åºåˆ—åªç”± l å’Œ t ä¸¤ç§å­—æ¯ç»„æˆã€‚ä¸€å¼€å§‹ï¼Œä¸¤ç±»ç”Ÿç‰©ä½“å†…çš„åŸºå› åºåˆ—éƒ½æ˜¯ä¸€ä¸ª lï¼ŒA ç±»ç”Ÿç‰©ä½“å†…çš„ l åŸºå› å¯èƒ½çªå˜ä¸º lt å’Œ ltlï¼ŒB ç±»ç”Ÿç‰©ä½“çš„ l åŸºå› åˆ™å¯èƒ½çªå˜ä¸º ltl,lt å’Œ tlã€‚ç»™å®šä¸€äº›ç”Ÿç‰©çš„åŸºå› åºåˆ—ï¼Œåˆ¤æ–­æ˜¯å¦å¯èƒ½å±äº A ç±» å’Œ B ç±» é¦–å…ˆä¸å¯èƒ½å‡ºç°è¿ç»­çš„ä¸¤ä¸ª l å¯¹äº A ç±»æ¥è¯´ï¼Œå®é™…ä¸Šæ˜¯åœ¨ l åæ’å…¥ t æˆ– tlï¼Œé‚£ä¹ˆç»å¯¹ä¸å¯èƒ½æœ‰ t å‰é¢æ²¡æœ‰ l T2 ç»™å®šä¸€æ£µ nnn ä¸ªç»“ç‚¹æ„æˆçš„æ ‘ã€‚ä½ éœ€è¦ç»™æ ‘ä¸Šçš„ nnn ä¸ªç»“ç‚¹è¿›è¡Œç¼–å·ï¼Œå…¶ä¸­æœ‰ aaa ä¸ªç»“ç‚¹éœ€è¦ç¼–å·ä¸º 1,2,â€¦,a1,2,\\dots,a1,2,â€¦,a ä¸­çš„ä¸é‡å¤çš„ç¼–å·ä½œä¸ºç™½ç‚¹ï¼›å‰©ä¸‹çš„ bbb ä¸ªç»“ç‚¹éœ€è¦ç¼–å·ä¸º âˆ’1,âˆ’2,â€¦,âˆ’b-1,-2,\\dots,-bâˆ’1,âˆ’2,â€¦,âˆ’b ä¸­çš„ä¸é‡å¤çš„ç¼–å·ï¼Œä½œä¸ºé»‘ç‚¹ç°åœ¨æœ‰ä¸€ä¸ªç¨‹åºï¼Œå®ƒä¼šå¯¹è¿™æ£µæ ‘è¿è¡Œ æ¬¡å¦‚ä¸‹æ­¥éª¤ï¼šä»é»‘è‰²å’Œç™½è‰²ä¸­éšæœºä¸€ä¸ªé¢œè‰²ï¼Œä¸”éœ€è¦ä¿è¯ç›®å‰å›¾ä¸Šä»ç„¶å­˜åœ¨è¿™ç§é¢œè‰²çš„ç‚¹ã€‚å¦‚æœéšæœºåˆ°çš„æ˜¯ç™½è‰²ï¼Œç¨‹åºå°†ä¼šåˆ é™¤ç¼–å·ç»å¯¹å€¼æœ€å°çš„ç™½ç‚¹ï¼Œå¹¶åˆ é™¤ä¸ä¹‹ç›¸è¿çš„æ‰€æœ‰è¾¹ï¼›å¦‚æœéšæœºåˆ°çš„æ˜¯é»‘è‰²ï¼Œç¨‹åºå°†ä¼šåˆ é™¤ç¼–å·ç»å¯¹å€¼æœ€å°çš„é»‘ç‚¹ï¼Œå¹¶åˆ é™¤ä¸ä¹‹ç›¸è¿çš„æ‰€æœ‰è¾¹ã€‚è¯·ç»™è¿™äº›ç‚¹åˆé€‚çš„ç¼–å·ï¼Œä½¿å¾—ä»»ä½•æƒ…å†µä¸‹ï¼Œç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­éƒ½ä¸ä¼šå‡ºç°å‰©ä½™æœªè¢«åˆ é™¤çš„ç‚¹ä¸è¿é€šçš„æƒ…å†µ æˆ‘ä»¬æŠŠæ•´æ£µæ ‘åˆ†ä¸ºå¤§å°åˆ†åˆ«ä¸º aaa å’Œ bbb çš„ä¸¤éƒ¨åˆ†ï¼Œä»å¶å­èŠ‚ç‚¹åˆ†åˆ«å‘ä¸Šæ ‡å·å³å¯ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int siz[MAXN], fa[MAXN];void dfs1(int u, int dad)&#123; siz[u] = 1; fa[u] = dad; for (int v : e[u]) if (v != dad) &#123; dfs1(v, u); siz[u] += siz[v]; &#125;&#125;void worka(int u, int dad)&#123; for (int v : e[u]) if (v != dad) &#123; worka(v, u); &#125; num[u] = ++cnta;&#125;void workb(int u, int dad)&#123; for (int v : e[u]) if (v != dad) &#123; workb(v, u); &#125; num[u] = --cntb;&#125;int main()&#123; dfs1(1, 0); for (int i = 1; i &lt;= n; i++) &#123; if (siz[i] == a) &#123; flag = 1; worka(i, fa[i]); workb(fa[i], i); break; &#125; if (siz[i] == b) &#123; flag = 1; workb(i, fa[i]); worka(fa[i], i); break; &#125; &#125;&#125; T3 æœ‰ä¸€æ£µ nnn ä¸ªç»“ç‚¹çš„æ ‘ï¼Œç¼–å·ä¸º 111 åˆ° nnn ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªé¢œè‰²ï¼Œé¢œè‰²ç¼–å·çš„èŒƒå›´æ˜¯ 111 åˆ° mmmï¼Œä¿è¯æ¯ç§é¢œè‰²è‡³å°‘å‡ºç°ä¸€æ¬¡ã€‚ ä½ éœ€è¦é€‰æ‹©ä¸€ä¸ªç»“ç‚¹ä½œä¸ºæ ¹ï¼ŒåŒæ—¶æ‰¾ä¸€ä¸ªæ ‘ä¸ŠèŠ‚ç‚¹çš„éç©ºå­é›† TTT ï¼Œæ»¡è¶³æ¯ç§é¢œè‰²éƒ½è‡³å°‘åœ¨ TTT ä¸­å‡ºç°ä¸€æ¬¡ï¼Œå¹¶ä¸” TTT ä¸­æ‰€æœ‰ç‚¹çš„ LCALCALCA çš„æ·±åº¦æœ€å¤§ã€‚å®šä¹‰ä½ é€‰çš„æ ¹æ·±åº¦ä¸º 111 ï¼Œå„¿å­çš„æ·±åº¦æ˜¯çˆ¶äº²æ·±åº¦ +1+1+1 ã€‚ æšä¸¾ LCALCALCA ï¼Œé—®é¢˜å®é™…ä¸Šå˜ä¸ºäº†é€‰å– LCALCALCA çš„æŸäº›å­æ ‘ä½œä¸ºç‚¹é›†ï¼Œåœ¨å‰©ä¸‹çš„å­æ ‘ä¸­æ‰¾ä»¥ LCALCALCA ä¸ºä¸€ç«¯çš„æœ€é•¿é“¾ï¼Œä»¥å¦ä¸€ç«¯ä½œä¸ºæ ¹ ä½¿ç”¨ dsu on tree ç»´æŠ¤ç‚¹é›†é¢œè‰²å³å¯ 10.3 T1 å° C ç”Ÿæ´»çš„åŸå¸‚å¯ä»¥ç”¨ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„çº¿æ®µæ¥è¡¨ç¤ºã€‚çº¿æ®µä¸Šï¼ˆåŒ…å«ç«¯ç‚¹ï¼‰å¹³å‡åˆ†å¸ƒç€ n+1n+1n+1 ä¸ªç‚¹ï¼Œä»å·¦åˆ°å³ç¼–å·ä¸º 1,â€¦,n+11,\\dots,n+11,â€¦,n+1 ã€‚ ä»–å°†ç¬¬ iii ä¸ªç‚¹ç§°ä¸º AiA_iAiâ€‹ ï¼Œçº¿æ®µ AiAi+1(iâ‰¤iâ‰¤n)A_iA_{i+1} (i \\leq i \\leq n)Aiâ€‹Ai+1â€‹(iâ‰¤iâ‰¤n) ç§°ä¸ºç¬¬ iii ä¸ªåŒºã€‚ç¬¬ iii ä¸ªåŒºçš„äººå¯¹æ™´å¤©çš„æ¸´æœ›åº¦å½¢å¼åŒ–æˆ sis_isiâ€‹ã€‚ æ™´å¤©çš„èŒƒå›´ä¸èƒ½è¦†ç›–æ•´ä¸ªåŸå¸‚ï¼Œå½¢å¼åŒ–åœ°è¯´ï¼Œè‹¥ ApA_pApâ€‹ ä¸ºè¦†ç›–èŒƒå›´çš„ä¸­å¿ƒï¼Œé‚£ä¹ˆå½“ä¸”ä»…å½“ç¬¬ iii ä¸ªåŒºå’Œ ApA_pApâ€‹ ä¹‹é—´éš”ç€çš„åŒºåŸŸå°‘äº ddd ä¸ªï¼ˆä¸åŒ…æ‹¬ç¬¬ iii ä¸ªåŒºæœ¬èº«ï¼‰ï¼Œç¬¬ iii ä¸ªåŒºä¼šè¢«æ™´å¤©è¦†ç›–ã€‚ å¦‚æœç¬¬ iii ä¸ªåŒºåœ¨æ™´å¤©çš„è¦†ç›–èŒƒå›´å†…ï¼Œå¹¶ä¸”å’Œæ™´å¤©ä¸­å¿ƒè¿˜éš”ç€ xxx ä¸ªåŒºï¼Œé‚£ä¹ˆè¿™ä¸ªåŒºçš„äººçš„å¼€å¿ƒå€¼ä¸º (dâˆ’x)2Ã—si(d-x)^2 \\times s_i(dâˆ’x)2Ã—siâ€‹ ã€‚è¿™ä¸ªåŸå¸‚çš„å¼€å¿ƒå€¼ä¸ºæ¯ä¸€ä¸ªåŒºçš„å¼€å¿ƒå€¼ä¹‹å’Œã€‚ å° C æƒ³çŸ¥é“å¦‚æœæ™´å¤©çš„åœ°ç‚¹å¯ä»¥ä»»é€‰ï¼Œé‚£ä¹ˆæœ€ååŸå¸‚çš„å¼€å¿ƒå€¼æœ€å¤§æ˜¯å¤šå°‘ã€‚ æˆ‘ä»¬åˆ†åˆ«å¤„ç†ä¸­å¿ƒå·¦å³ä¸¤ä¾§çš„è´¡çŒ® å‡å¦‚ d=3d = 3d=3 ï¼Œé‚£ä¹ˆå‘¨å›´è¿™äº›åŒºçš„è´¡çŒ®çš„ç³»æ•°ä¸º 9,4,1ï¼Œ09, 4, 1ï¼Œ09,4,1ï¼Œ0 ï¼Œä¸­å¿ƒå‘åç§»åŠ¨ä¸€ä¸ªç‚¹ï¼Œç³»æ•°å˜ä¸º 0,9,4,10, 9, 4, 10,9,4,1 ï¼Œå˜åŒ–äº† 5,3,15, 3, 15,3,1 ï¼Œç»´æŠ¤ä¸­å¿ƒç§»åŠ¨çš„å˜åŒ– O(n)O(n)O(n) æ‰«ä¸€é éœ€è¦ O(1)O(1)O(1) ç»´æŠ¤å˜åŒ–ï¼ŒåŠ¨æ€ç»´æŠ¤ ddd é¡¹çš„å’Œã€‚ Code 12345678910111213141516171819202122232425262728293031for (int i = 1; i &lt;= d; i++) &#123; ans1[1] += (d - i + 1) * (d - i + 1) * a[i]; if (i &gt; 1) tmp += (d - i + 1) * a[i];&#125;for (int i = 1; i &lt;= n; i++) &#123; int l = max(1, i), r = min(n, i + d); ans1[i + 1] = (ans1[i] - d * d * a[i] + tmp * 2 + sum[r] - sum[l]); tmp += sum[r] - sum[l]; tmp -= a[i + 1] * d;&#125;reverse(a + 1, a + 1 + n);for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a[i];tmp = 0;for (int i = 1; i &lt;= d; i++) &#123; ans2[1] += (d - i + 1) * (d - i + 1) * a[i]; if (i &gt; 1) tmp += (d - i + 1) * a[i];&#125;for (int i = 1; i &lt;= n; i++) &#123; int l = max(1, i), r = min(n, i + d); ans2[i + 1] = (ans2[i] - d * d * a[i] + tmp * 2 + sum[r] - sum[l]); tmp += sum[r] - sum[l]; tmp -= a[i + 1] * d;&#125;reverse(ans2 + 1, ans2 + 2 + n);for (int i = 1; i &lt;= n + 1; i++) &#123; ans = max(ans, ans1[i] + ans2[i]);&#125; T2 ç»™ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— AAA ï¼Œä½ å¯ä»¥åˆ å»åŸåºåˆ—çš„ä¸€äº›æ•°ï¼Œæˆ–è€…ä¸€ä¸ªæ•°éƒ½ä¸åˆ é™¤ï¼Œå°†å‰©ä¸‹çš„æ•°æŒ‰ç…§åŸæ¥çš„é¡ºåºç»„æˆæ–°çš„é•¿åº¦ä¸º m(1â‰¥mâ‰¥n)m(1 \\ge m \\ge n)m(1â‰¥mâ‰¥n) çš„åºåˆ— ã€‚ ç°åœ¨ä½ æƒ³çŸ¥é“ï¼Œå¯¹äºæ‰€æœ‰åˆæ³•çš„åºåˆ— BBB ï¼Œâˆ‘i=1m[Bi=i]\\sum_{i=1}^{m}\\left[B_{i}=i\\right]âˆ‘i=1mâ€‹[Biâ€‹=i] çš„æœ€å¤§å€¼æ˜¯å¤šå°‘ã€‚ å…ˆè€ƒè™‘æš´åŠ›DP fif_{i}fiâ€‹ è¡¨ç¤º å‰ iii ä¸ªæ•° ï¼Œä»¥ iii ç»“å°¾çš„ç­”æ¡ˆ f(i)=maxâ¡{f(j)+1âˆ£j&lt;i,aj&lt;ai,aiâˆ’aj&lt;iâˆ’j}f(i)=\\max \\left\\{f(j)+1 \\mid j&lt;i, a_{j}&lt;a_{i}, a_{i}-a_{j}&lt;i-j\\right\\} f(i)=max{f(j)+1âˆ£j&lt;i,ajâ€‹&lt;aiâ€‹,aiâ€‹âˆ’ajâ€‹&lt;iâˆ’j} é‚£ä¹ˆè½¬ç§»çš„æ¡ä»¶å°±æ˜¯ : j&lt;ij &lt; ij&lt;i aj&lt;aia_j &lt; a_iajâ€‹&lt;aiâ€‹ aiâˆ’aj&lt;iâˆ’ja_i - a_j &lt; i - jaiâ€‹âˆ’ajâ€‹&lt;iâˆ’j å°†åºåˆ—æŒ‰ç…§ aia_iaiâ€‹ æ’åºï¼Œç„¶åæ±‚â¼€ä¸ªæœ€â»“çš„ iâˆ’aii - a_iiâˆ’aiâ€‹ ä¸ä¸‹é™çš„â¼¦åºåˆ—â»“åº¦å³å¯ 10.4 div.1 T1 å° A å’Œå° B ç«é€‰ç­é•¿æµç¨‹å¦‚ä¸‹ï¼š åœ¨ [1,n][1, n][1,n] ä¸­éšæœºé€‰å–ä¸€ä¸ªåŒºé—´ [l,r][l, r][l,r] ï¼Œç»Ÿè®¡åŒºé—´å†…åŒå­¦çš„æŠ•ç¥¨æƒ…å†µï¼Œå¦‚æœäºŒäººç¥¨æ•°ä¹‹å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ kkk ï¼Œé‚£ä¹ˆå¹³å±€ï¼Œéƒ½æ˜¯ç­é•¿ï¼›å¦åˆ™ç¥¨æ•°é«˜çš„åŒå­¦å½“é€‰ã€‚å° A æ‹…å¿ƒè½é€‰ï¼Œå‡†å¤‡æ”¶ä¹°ä¸€äº›åŒå­¦ï¼Œä½¿å¾—åœ¨ä»»ä½•æƒ…å†µä¸‹è‡ªå·±éƒ½èƒ½æˆä¸ºç­é•¿ã€‚å·²çŸ¥æ”¶ä¹°ç¼–å·ä¸º iii çš„åŒå­¦çš„èŠ±è´¹ä¸º 2i2^i2iï¼Œè¯·é—®å° A çš„æœ€å°‘èŠ±è´¹æ˜¯å¤šå°‘ è¿›è¡Œä¸€ä¸ªè´ªå¿ƒï¼Œæ¯æ¬¡åœ¨ä¸æ»¡è¶³çš„æƒ…å†µä¸‹é€‰å–ä¸‹æ ‡æœ€å°çš„äººæ”¶ä¹°ï¼Œæ‰€ä»¥å€’åºæšä¸¾ï¼Œä¸è¡Œå°±æ”¶ä¹°ä¸€ä¸‹ T2 æœ‰ nnn ä¸ªè¢«æŠ½è±¡æˆçŸ©å½¢çš„åŒå­¦åœ¨æ‹ç…§ã€‚å…¶ä¸­ç¬¬ iii ä¸ªåŒå­¦å®½ä¸º wiw_iwiâ€‹ ï¼Œé«˜ä¸º hih_ihiâ€‹ ã€‚ éœ€è¦å®½ä¸ºæ‰€æœ‰ www ä¹‹å’Œï¼Œé«˜ä¸ºæ‰€æœ‰ hhh æœ€å¤§å€¼çš„ç›¸æ¡†æ‰èƒ½å®¹ä¸‹æ‰€æœ‰çš„åŒå­¦ã€‚ ä¸ºäº†ç¼©å°ç›¸æ¡†çš„é¢ç§¯ï¼Œä½ å¯ä»¥è®©ä¸€éƒ¨åˆ†åŒå­¦èººä¸‹ã€‚ç¬¬ iii ä¸ªåŒå­¦èººä¸‹ä¹‹åï¼Œä»–çš„å®½å˜æˆ hih_ihiâ€‹ ï¼Œé«˜å˜æˆ wiw_iwiâ€‹ã€‚ åŒæ—¶ï¼Œå¤ªå¤šäººèººç€ä¸å¥½çœ‹ï¼Œæ‰€ä»¥æœ€å¤šåªèƒ½æœ‰ âŒŠn2âŒ‹\\left \\lfloor \\frac{n}{2} \\right \\rfloorâŒŠ2nâ€‹âŒ‹ ä¸ªåŒå­¦èººä¸‹ã€‚ æˆ‘ä»¬æšä¸¾æœ€åç›¸æ¡†çš„é«˜åº¦ hhhï¼Œå¯¹äºç¬¬ iii ä¸ªäººï¼Œæœ‰ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š hiâ‰¤h,wiâ‰¤hh_i \\leq h, w_i \\leq hhiâ€‹â‰¤h,wiâ€‹â‰¤h ï¼Œèººä¸èººéƒ½å¯ hiâ‰¥h,wiâ‰¤hh_i \\ge h, w_i \\leq hhiâ€‹â‰¥h,wiâ€‹â‰¤h ï¼Œä¸€å®šè¦èºº hiâ‰¤h,wiâ‰¥hh_i \\leq h, w_i \\ge hhiâ€‹â‰¤h,wiâ€‹â‰¥h ï¼Œä¸€å®šä¸èƒ½èºº hiâ‰¥h,wiâ‰¥hh_i \\ge h, w_i \\ge hhiâ€‹â‰¥h,wiâ€‹â‰¥h ï¼Œè¯´æ˜ hhh ä¸åˆæ³• é‚£ä¹ˆåªæœ‰ç¬¬ä¸€ç§æƒ…å†µçš„äººæœ‰æ“ä½œç©ºé—´ï¼Œå¦‚æœèººä¸‹çš„è¯ï¼Œå®½åº¦ä¼šå‡å° wiâˆ’hiw_i - h_iwiâ€‹âˆ’hiâ€‹ ï¼ŒæŒ‰è¿™ä¸ªå€¼æ’åºå–æœ€ä¼˜çš„å³å¯ T3 æ±‚å‡ºæ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„ nÃ—mn \\times mnÃ—m çŸ©é˜µä¸ªæ•°: å¯¹äºæ¯ä¸€è¡Œæœ‰ li,ril_i, r_iliâ€‹,riâ€‹ ï¼Œè¡¨ç¤º 1âˆ¼li1 \\sim l_i1âˆ¼liâ€‹ æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª 111 ï¼Œriâˆ¼mr_i \\sim mriâ€‹âˆ¼m æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª 111 , å…¶ä½™å…¨ä¸º 000 æ¯ä¸€åˆ—æœ€å¤šæœ‰ä¸€ä¸ª 111 å› ä¸ºæ¯åˆ—æœ€å¤šéƒ½åªèƒ½æœ‰ä¸€ä¸ª 111ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸€æ¯ä¸€åˆ—åˆ’åˆ†çŠ¶æ€æ¥ DP ã€‚ æŠŠæ¯ä¸€è¡Œçš„é™åˆ¶ä¸ºå‰ç¼€å’Œåç¼€ä¸¤ä¸ªï¼Œä¸€å…±æœ‰ 2n2n2n ä¸ªé™åˆ¶ï¼Œæ¯ä¸€åˆ—åªèƒ½æ»¡è¶³è¿™ 2n2n2n ä¸ªé™åˆ¶ä¸­çš„ä¸€ä¸ª preliprel_ipreliâ€‹ è¡¨ç¤º lâˆˆ[1,i]l \\in[1, i]lâˆˆ[1,i] çš„è¡Œæœ‰å¤šå°‘ä¸ªï¼Œpreriprer_ipreriâ€‹ è¡¨ç¤º râˆˆ[1,i]r \\in[1, i]râˆˆ[1,i] çš„è¡Œæœ‰å¤šå°‘ä¸ªã€‚ f(i,j)f(i,j)f(i,j) è¡¨ç¤ºå‰ iii åˆ—ï¼Œæœ‰ jjj åˆ—ç”¨æ¥æ»¡è¶³ râˆˆ[i,i]r \\in [i, i]râˆˆ[i,i] çš„åç¼€é™åˆ¶çš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆ f(i,j)=f(iâˆ’1,j)+f(iâˆ’1,jâˆ’1)Ã—(preriâˆ’j+1)f(i, j) = f(i-1,j) + f(i-1,j-1) \\times (prer_i - j + 1) f(i,j)=f(iâˆ’1,j)+f(iâˆ’1,jâˆ’1)Ã—(preriâ€‹âˆ’j+1) ä»¥åŠ l=il = il=i çš„å‰ç¼€é™åˆ¶ f(i,j)=f(i,j)Ã—(iâˆ’preliâˆ’1âˆ’j)!(iâˆ’preliâˆ’j)!f(i,j) = f(i,j) \\times \\frac{\\left(i-prel_{i-1}-j\\right) !}{\\left(i- prel_i-j\\right)!} f(i,j)=f(i,j)Ã—(iâˆ’preliâ€‹âˆ’j)!(iâˆ’preliâˆ’1â€‹âˆ’j)!â€‹ div.2 T1 æœŸæœ›ä¸ä¼š T2 ç»™å®šä¸€äº›é•¿åº¦çš„è¾¹ï¼Œæ±‚ç”¨è¿™äº›è¾¹çš„å…¶ä¸­ä¸€äº›ç»„æˆ kkk ä¸ªä¸‰è§’å½¢çš„æœ€å¤§è¾¹é•¿å’Œ è´ªå¿ƒï¼Œå°½é‡é€‰è¾¹é•¿å¤§çš„ã€‚ å…·ä½“æ¥è¯´å°±æ˜¯å…ˆé¢„å¤„ç†å‡ºä¸€ç»„æœ€å¤§çš„è¾¹é•¿ï¼Œç„¶åæŒ‰é•¿åº¦é€’å‡æšä¸¾ï¼Œa,b,ca, b, ca,b,c ä¸ºå½“å‰æšä¸¾çš„ä¸€ç»„ï¼Œ x,y,zx, y, zx,y,z ä¸ºä¸Šä¸€ç»„ å¦‚æœ x,y,zx, y, zx,y,z ï¼Œæ»¡è¶³æ„æˆä¸‰è§’å½¢çš„æ¡ä»¶ï¼Œç›´æ¥æ›´æ–°ï¼Œæ¥ç€æšä¸¾ å¦åˆ™è€ƒè™‘æ‹†å¼€ a,b,ca, b, ca,b,c ï¼Œ ä½¿å¾— x,y,zx, y, zx,y,z ä¹Ÿå¯ä»¥è¢«é€‰ï¼Œæšä¸¾ä¸€ä¸‹å‡ ç§æƒ…å†µï¼š (a,x,y)(a, x, y)(a,x,y) å’Œ (b,c,z)(b, c, z)(b,c,z) (a,b,x)(a, b, x)(a,b,x) å’Œ (c,y,z)(c, y, z)(c,y,z) (a,c,x)(a, c, x)(a,c,x) å’Œ (j,y,z)(j, y, z)(j,y,z) éƒ½ä¸è¡Œæ¥ç€æšä¸¾ (x,y,z)(x, y, z)(x,y,z) 10.5 T1 æœ‰ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— AAA å’Œæ¨¡æ•° pppï¼ŒAiA_iAiâ€‹ è¡¨ç¤º aiâˆ’1a^{i-1}aiâˆ’1 , ä½†æ˜¯ä¸çŸ¥é“ aaa æ˜¯å¤šå°‘çš„ï¼Œæ±‚å‡º aaa å¥½åƒæ­£è§£æŒºå¤æ‚çš„ï¼Œä½†æ˜¯äººç±»æ™ºæ…§æ•´å‡ºæ¥äº†å’ŒT1ç›¸åŒ¹é…çš„éš¾åº¦ã€‚ mulmulmul è¡¨ç¤ºæ•´ä¸ªåºåˆ—çš„ä¹˜ç§¯ï¼Œ sumsumsum è¡¨ç¤ºæ•´ä¸ªåºåˆ—çš„å’Œ mul=anâˆ’12mul = a^{\\frac{n-1}{2}}mul=a2nâˆ’1â€‹ ï¼Œsumsumsum ä½¿ç”¨ç­‰æ¯”æ•°åˆ—æ±‚å’Œå…¬å¼ï¼Œ æšä¸¾ aaa æ¥ check å³å¯ T2 å°Sè¢«è€å¸ˆå®‰æ’å»æ’ä¸€ä¸ªæ–°ç­çº§çš„åº§ä½ã€‚æ–°ç­çº§æœ‰ nnn ä½åŒå­¦ï¼Œä»–ä»¬çš„æˆç»©æŒ‰é¡ºåºåˆ†åˆ«ä¸º a1,a2,â€¦,an,(aiâ‰¤ai+1)a_1,a_2,\\dots,a_n ,(a_i\\leq a_{i+1})a1â€‹,a2â€‹,â€¦,anâ€‹,(aiâ€‹â‰¤ai+1â€‹) ã€‚ä¸ºä¿ƒè¿›äº’å¸®äº’åŠ©ï¼Œä¸€å¯¹åŒæ¡Œçš„æˆç»©ä¹‹å·®çš„ç»å¯¹å€¼å¿…é¡»å¤§äºç­‰äºç»™å®šçš„ KKKï¼Œä½†è¿™æ ·ä¼šå¯¼è‡´ä¸€äº›åŒå­¦æ²¡æœ‰åŒæ¡Œï¼Œæ‰€ä»¥è¯·ä½ æ±‚å‡ºä»–æœ€å¤šèƒ½æ’å‡ºå‡ å¯¹åŒæ¡Œ å¯¹äºæ¯ä¸ªæ•°ï¼Œè´ªå¿ƒé…å¯¹å³å¯ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ T3 å°kåœ¨ä¸‹é£è¡Œæ£‹ï¼Œæ£‹ç›˜æ˜¯ä¸€è¡Œå…± nnn ä¸ªæ ¼å­ï¼Œç¼–å·ä¾æ¬¡ä¸º 1âˆ¼n1 \\sim n1âˆ¼n ã€‚å°Kæœ‰å¤–æŒ‚ï¼Œæ‰€ä»¥ä»–ä¼šé€šè¿‡å¤–æŒ‚æ¥å‰è¿›ï¼Œä»–å…±æœ‰ mmm ä¸ªå¤–æŒ‚ï¼Œç¬¬ iii ä¸ªå¤–æŒ‚èƒ½è®©ä»–ä»ç¬¬ lil_iliâ€‹ æ ¼ç¬ç§»åˆ°ç¬¬ rir_iriâ€‹ â€‹æ ¼ï¼Œå¹¶èŠ±è´¹ 111 çš„æ—¶é—´ï¼Œå¹¶ä¸”å°Kå¾ˆDï¼Œæ‰€ä»¥ä»–ä¸éœ€è¦å¤–æŒ‚å°±èƒ½å¾€å›èµ°ï¼Œä¸”å¾€å›èµ°ä¸éœ€è¦æ—¶é—´ã€‚ ä½†æ˜¯å°Kçš„ rp ä¸å¤ªå¥½ï¼Œç°åœ¨å‘ç”Ÿäº† qqq æ¬¡äº‹ä»¶ï¼Œæ¯æ¬¡äº‹ä»¶ä¸­ï¼Œå°Kçš„æŸä¸€ä¸ªæŒ‚ä¼šåï¼ˆè¿™æ¬¡äº‹ä»¶ç»“æŸååˆä¼šæ¢å¤ï¼‰ï¼Œè€Œä½ éœ€è¦å¸®ä»–æ±‚å‡ºæ­¤æ—¶ä»–ä» sss èµ°åˆ° ttt è¦èŠ±è´¹çš„æœ€å°æ—¶é—´ å€å¢è·³ï¼Œç»´æŠ¤ç¬¬ iii ä¸ªä½ç½®å‡ºå‘çš„æœ€å¤§å€¼å’Œæ¬¡å¤§å€¼ã€‚æŒ‚å¤±æ•ˆäº†å°±é‡æ–°è·³ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define MXBT 19using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; &#125; template &lt;typename T, typename ... TT&gt; void read(T &amp;x, TT &amp;... xx) &#123; read(x); read(xx...); &#125;&#125;using namespace OCTANE;struct node&#123; int to, id;&#125;;struct nood&#123; node mxz, mxxz; void change(node a) &#123; if(a.to &gt; mxz.to) mxxz = mxz, mxz = a; else if(a.id != mxz.id and a.to &gt; mxxz.to) &#123; mxxz = a; &#125; &#125;&#125;a[MAXN];int n, m, q;int l[MAXN], r[MAXN];int f[MAXN][20];int g[MAXN][20];int main()&#123; read(n, m); for (int i = 1; i &lt;= m; i++) &#123; read(l[i], r[i]); a[l[i]].change(&#123;r[i], i&#125;); &#125; for (int i = 1; i &lt;= n; i++) &#123; a[i].change(a[i-1].mxz); a[i].change(a[i-1].mxxz); f[i][0] = a[i].mxz.to; g[i][0] = a[i].mxxz.to; &#125; for (int j = 1; j &lt;= MXBT; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; f[i][j] = f[f[i][j-1]][j-1]; if (a[g[i][j-1]].mxz.id == a[i].mxz.id) g[i][j] = g[g[i][j-1]][j-1]; else g[i][j] = f[g[i][j-1]][j-1]; &#125; &#125; read(q); while(q--) &#123; int id, s, t, ans = 0; if (t &lt; l[id]) id = 0; if (s &lt; l[id]) &#123; for (int i = MXBT; ~i; i--) &#123; if (f[s][i] &lt; l[id]) ans += (1 &lt;&lt; i), s = f[s][i]; &#125; ans++; s = f[s][0]; &#125; if (s &gt;= t) &#123; printf(&quot;%d\\n&quot;, ans); continue; &#125; for(int i = MXBT; i &gt;= 0; i--) &#123; if (a[s].mxz.id == id) &#123; if (g[s][i] &lt; t) ans += (1 &lt;&lt; i), s = g[s][i]; &#125; else &#123; if (f[s][t] &lt; t) ans += (1 &lt;&lt; i), s = f[s][i]; &#125; &#125; ans++; if (a[s].mxz.id == id) s = g[s][0]; else s = f[s][0]; if (s &lt; t) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; T4 æ•™ç»ƒç»™å°Zå¸ƒç½®äº†ä¸€ä¸ªä½œä¸šï¼Œæ•™ç»ƒç»™å‡ºäº† nnn ä¸ªå‘½é¢˜ï¼Œè®©ä»–è¯æ˜ nnn ä¸ªå‘½é¢˜å…¨éƒ¨ä¸ºçœŸã€‚ä½†æ˜¯å°Zéå¸¸çš„æ‡’ï¼Œä¸€æ—¦éœ€è¦è¯æ˜çš„å‘½é¢˜æ•°é‡å¤§äº kkkï¼Œå°Zå°±ä¼šæ‘†çƒ‚ä¸å®Œæˆä½œä¸šã€‚å› æ­¤å°Zå‘ä»–çš„å¥½æœ‹å‹é»‘æ¶å·æ€ªå°Læ±‚åŠ©ã€‚å°Lå¸®å°Zè¯æ˜äº† mmm ä¸ªç­‰ä»·å…³ç³»ï¼Œå³å¯¹äº 1â‰¤iâ‰¤m1\\leq i \\leq m1â‰¤iâ‰¤m ï¼Œå°Lè¯æ˜äº† uiu_iuiâ€‹ â€‹å’Œ viv_iviâ€‹ æ˜¯ç­‰ä»·çš„ã€‚å°LæŠŠä»–çš„æˆæœå‘ç»™äº†å°Zï¼Œä½†æ˜¯ç½‘ç»œè´¨é‡ä¸ä½³ï¼Œå°Zåªæ”¶åˆ°äº†ä¸€ä¸ªåŒºé—´çš„ç­‰ä»·å…³ç³»è¯æ˜ã€‚â€‹ ç°åœ¨æœ‰ qqq æ¡æ—¶é—´çº¿ï¼Œä½ éœ€è¦å¯¹äºæ¯æ¡æ—¶é—´çº¿ï¼Œæ±‚å‡ºå‡å¦‚å°Zæ”¶åˆ°äº†ç¬¬ lâˆ¼rl \\sim rlâˆ¼r ä¸ªç­‰ä»·å…³ç³»çš„è¯æ˜ï¼Œå°Zæ˜¯å¦èƒ½å¤Ÿå®Œæˆä½œä¸š ç»´æŠ¤ä¸€ä¸ª fif_ifiâ€‹ è¡¨ç¤ºä»¥ iii ä¸º å·¦ç«¯ç‚¹ï¼Œèƒ½å¤Ÿå®Œæˆéœ€è¦çš„æœ€è¿‘çš„ rrr ä½¿ç”¨å¹¶æŸ¥é›†ç»´æŠ¤è”é€šæ€§ã€‚ç”¨çº¿æ®µæ ‘åˆ†æ²»å¤„ç†æ—¶é—´æ®µï¼Œå› ä¸º fff ä» mmm å¼€å§‹æšä¸¾ï¼Œæ‰€ä»¥å…ˆå¤„ç†å³å„¿å­ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;int n, m, k, Type, q;namespace union_set&#123; struct node &#123; int x, y, add; &#125;; int fa[MAXN], siz[MAXN], cnt; node sta[MAXN &lt;&lt; 2]; int top; void init() &#123; for (int i = 1; i &lt;= n; i++) &#123; fa[i] = i; siz[i] = 1; cnt = n; &#125; &#125; int find(int x) &#123; return x == fa[x] ? x : find(fa[x]); &#125; void merge(int x, int y) &#123; int fx = find(x), fy = find(y); if (fx == fy) return; if (siz[fx] &gt; siz[fy]) swap(fx, fy); siz[fy] += siz[fx]; fa[fx] = fy; cnt--; sta[++top] = &#123;fx, fy, 1&#125;; &#125; void eko(int x, int y, int z) &#123; fa[x] = x; siz[y] -= siz[x]; cnt += z; &#125;&#125;using namespace union_set;#define ls(i) (i &lt;&lt; 1)#define rs(i) (i &lt;&lt; 1 | 1)struct nood&#123; int x, y;&#125;e[MAXN];vector &lt;int&gt; v[MAXN &lt;&lt; 2];int f[MAXN], now;void add(int i, int l, int r, int L, int R, int u)&#123; if (l &gt;= L &amp;&amp; r &lt;= R) &#123; v[i].push_back(u); return; &#125; int mid = (l + r) &gt;&gt; 1; if (mid &gt;= L) add(ls(i), l, mid, L, R, u); if (mid+1 &lt;= R) add(rs(i), mid+1, r, L, R, u);&#125;void solve(int u, int l, int r)&#123; int last = top; for (auto k : v[u]) merge(e[k].x, e[k].y); if (l == r) &#123; while (now &amp;&amp; cnt &gt; k) &#123; if (now &lt; l) add(1, 1, n, now, l-1, now); merge(e[now].x, e[now].y); now--; &#125; if (cnt &lt;= k) f[l] = now + 1; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; solve(rs(u), mid+1, r); solve(ls(u), l, mid); &#125; while (top &gt; last) eko(sta[top].x, sta[top].y, sta[top].add), top--;&#125;int main()&#123; read(n, m, k, Type); for (int i = 1; i &lt;= m; i++) &#123; int u, v; read(u, v); e[i] = &#123;u, v&#125;; &#125; now = m; init(); solve(1, 1, m); read(q); unsigned int lastans = 0; while (q--) &#123; int l, r; read(l, r); if (Type) &#123; l = ((unsigned int)l + lastans) % m + 1; r = ((unsigned int)r + lastans) % m + 1; if (l &gt; r) swap(l ,r); &#125; lastans &lt;&lt;= 1; if (f[r] &gt;= l) lastans++; puts(f[r] &gt;= l ? &quot;Yes&quot; : &quot;No&quot;); &#125; return 0;&#125; 10.6 T1 æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªåºåˆ—æ˜¯å•å³°çš„ï¼Œå½“ä¸”ä»…å½“å®ƒæ»¡è¶³ä»¥ä¸‹ä¸€ä¸ªæ¡ä»¶ï¼š å­˜åœ¨ä¸€ä¸ªä¸‹æ ‡ k(1â‰¤kâ‰¤n)k(1\\le k\\le n)k(1â‰¤kâ‰¤n) æ»¡è¶³ a1&lt;a2&lt;a3&lt;â‹¯&lt;ak&gt;ak+1&gt;â‹¯&gt;ana_1 &lt; a_2 &lt; a_3 &lt; \\dots &lt; a_k &gt; a_{k+1} &gt; \\dots &gt; a_na1â€‹&lt;a2â€‹&lt;a3â€‹&lt;â‹¯&lt;akâ€‹&gt;ak+1â€‹&gt;â‹¯&gt;anâ€‹ å­˜åœ¨ä¸€ä¸ªä¸‹æ ‡ k(1â‰¤kâ‰¤n)k(1\\le k\\le n)k(1â‰¤kâ‰¤n) æ»¡è¶³ a1&gt;a2&gt;a3&gt;â‹¯&gt;ak&lt;ak+1&lt;â‹¯&lt;ana_1 &gt; a_2 &gt; a_3 &gt; \\dots &gt; a_k &lt; a_{k+1} &lt; \\dots &lt; a_na1â€‹&gt;a2â€‹&gt;a3â€‹&gt;â‹¯&gt;akâ€‹&lt;ak+1â€‹&lt;â‹¯&lt;anâ€‹ ä¸€ä¸ªéå•å³°åºåˆ—å¯ä»¥è¿›è¡Œè‹¥å¹²æ¬¡Swapæ“ä½œä½¿å¾—åºåˆ—å˜æˆå•å³°çš„ã€‚å°Cæ¯æ¬¡ä¼šåœ¨åºåˆ—çš„æœ«å°¾æ·»åŠ ä¸€ä¸ªæ–°çš„å…ƒç´  xxx ï¼Œå°Cæƒ³çŸ¥é“æ¯æ¬¡æ·»åŠ æ–°çš„å…ƒç´ åï¼Œåºåˆ—æœ€å°‘è¿›è¡Œå‡ æ¬¡Swapæ“ä½œå¯ä»¥å˜æˆå•å³°çš„ è€ƒè™‘åˆ°å•å³°çš„å®šä¹‰ï¼Œæˆ‘ä»¬ä¿è¯æ¯æ¬¡æ·»åŠ çš„å…ƒç´ åœ¨ä¹‹å‰æ²¡æœ‰å‡ºç°è¿‡ å¯¹äºæ¯ä¸€ä¸ªæ–°æ’è¿›æ¥çš„æ•°ï¼Œå¯ä»¥æ’åˆ°å‰é¢ï¼Œä¹Ÿå¯ä»¥æ’åˆ°åé¢ å®ƒçš„è´¡çŒ®æ˜¯ä¸­é—´æ˜¯æ²¡æ”¾çš„æ•°ä¸­ ä¸‹æ ‡æ¯”å®ƒå¤§çš„ æ¯” ä¸‹æ ‡æ¯”å®ƒå°çš„ æ›´å¤šå°±æ”¾å‰é¢ï¼Œå¦åˆ™æ”¾åé¢ è€ƒè™‘é€†åºå¯¹ï¼ŒäºŒåˆ†å³å¯ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define ll long long#define MAXN 300005using namespace std;int n;namespace doubleForkIndexTree&#123; #define lowbit(i) (i &amp; -i) int t[MAXN]; void add(int pos, int val) &#123; while (pos &lt;= n) &#123; t[pos] += val; pos += lowbit(pos); &#125; &#125; int query(int pos, int res = 0) &#123; while (pos) &#123; res += t[pos]; pos -= lowbit(pos); &#125; return res; &#125;&#125;using namespace doubleForkIndexTree;int a[MAXN], h[MAXN];vector &lt;int&gt; q[MAXN];int iOrderPair[MAXN];ll ans[MAXN];void solve()&#123; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= n; i++) q[i].clear(); for (int i = 1; i &lt;= n; i++) &#123; h[a[i]] = i; iOrderPair[i] = query(a[i]); add(a[i], 1); &#125; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= n; i++) &#123; int l = h[i], r = n, mid; while (l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if (query(mid) &gt;= 2 * iOrderPair[h[i]]) r = mid; else l = mid + 1; &#125; q[l].push_back(i); add(h[i], 1); &#125; memset(t, 0, sizeof(t)); ll v = 0; for (int i = 1; i &lt;= n; i++) &#123; v += query(n) - query(a[i]); for (int j : q[i]) add(j, -1); add(a[i], 1); ans[i] = min(ans[i], v); &#125;&#125;int main()&#123; read(n); memset(ans, 0x3f, sizeof(ans)); for (int i = 1; i &lt;= n; i++) read(a[i]), h[i] = a[i]; sort(h+1, h+1+n); for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(h+1, h+1+n, a[i]) - h; solve(); for (int i = 1; i &lt;= n; i++) a[i] = n - a[i] + 1; solve(); for (int i = 1; i &lt;= n; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;&#125; T2 å° Q è¦è¿›è¡Œ nnn ç»„ä½“èƒ½è®­ç»ƒã€‚éœ€è¦ mmm ç§é…é‡åœ†ç›˜ã€‚åœ¨ç¬¬ iii ç»„è®­ç»ƒä¸­ï¼Œéœ€è¦ wi,jw_{i,j}wi,jâ€‹ ä¸ªé…é‡ä¸º jjj çš„åœ†ç›˜ã€‚å° Q çš„è®­ç»ƒå™¨æ¢°æ˜¯ä¸€ä¸ªç±»ä¼¼æ ˆçš„ç»“æ„ï¼Œæ¯æ¬¡åªèƒ½å–å‡ºæœ€ä¸Šæ–¹çš„åœ†ç›˜æˆ–æŠŠä¸€ä¸ªåœ†ç›˜æ”¾åœ¨æœ€ä¸Šæ–¹ï¼Œæ¯æ¬¡æ“ä½œéƒ½è¦æ¶ˆè€—ä¸€ç‚¹ä½“åŠ›ã€‚æ·¸å¸®åŠ©å° Q å®‰æ’æ”¾åœ“ç›¤çš„é †åºï¼Œä½¿å¾—æ¶ˆè€—çš„é«”åŠ›æœ€å°‘ ä¸å¤„ç†å‡ºæ¯æ¬¡æœ€å¤šå¯ä»¥ä¿ç•™çš„åœ†ç›˜ï¼Œä¹Ÿå°±æ˜¯ min(wiâˆ’1,j,wi,j)min(w_{i-1, j}, w_{i,j})min(wiâˆ’1,jâ€‹,wi,jâ€‹) ï¼Œç„¶ååŒºé—´Dp Code 123456789101112131415memset(f, 0x3f, sizeof(f));for (int i = 1; i &lt;= n;i++)&#123; for (int j = 1; j &lt;= m; j++) read(w[i][j]), g[j] = w[i][j]; for (int j = i; j &gt;= 1; j--) for (int k = 1; k &lt;= m; k++) &#123; g[k] = min(g[k], w[j][k]); cost[j][i] += g[k] * 2; &#125; f[i][i] = cost[i][i];&#125;for (int len = 2; len &lt;= n; len++) for (int l = 1; l &lt;= n - len + 1; l++)&#123; int r = l + len - 1; for (int k = l; k &lt; r; k++) f[l][r] = min(f[l][r], f[l][k] + f[k+1][r] - cost[l][r]);&#125; T3 æœ‰ nnn ä¸ªå°æœ‹å‹ï¼Œç¬¬ iii ä¸ªå°æœ‹å‹ç«™åœ¨ xi,yix_i, y_ixiâ€‹,yiâ€‹ ï¼Œå° Q åœ¨åœ°ä¸Šæ”¾ç½®äº† nnn ä¸ªæ™®é€š ğŸ¬ ï¼Œå° Q æ¯æ¬¡å›é€‰æ‹©ä¸€ä¸ªå°æœ‹å‹ï¼Œå°æœ‹å‹å›æ¯æ¬¡é€‰æ‹©è·ç¦»ä»–æœ€è¿‘çš„ç³–æœæ‹¿ä¸‹ï¼Œä½†æ˜¯å° Q è¿˜ä¸å°å¿ƒæŠŠå®ƒå–œæ¬¢çš„è‰¾å°”ç™»æ³•ç¯æ‰åˆ°åœ°ä¸Šäº†ï¼Œè¯·é—®æ˜¯å¦å­˜åœ¨ä½¿å”¤å°æœ‹å‹çš„é¡ºåºï¼Œä½¿å¾—æœ€åé€‰å‰©ä¸‹çš„æ˜¯è‰¾å°”ç™»æ³•ç¯ è€ƒè™‘ä¸€ä¸ªè´ªå¿ƒï¼Œå¤„ç†å‡ºæ¯ä¸ªå°å­©ä¸æ‹¿æ³•ç¯çš„æƒ…å†µä¸‹å¯ä»¥æ‹¿åˆ°çš„ç³–æœï¼Œè¿˜æœ‰å¯¹åº”ç³–æœå¯ä»¥è¢«æ‹¿çš„å°å­©ã€‚ æ¯æ¬¡é€‰æ‹©å¯ä»¥æ‹¿ç³–æœçš„æœ€å°‘çš„å°å­©å»æ‹¿å¯ä»¥è¢«æœ€å°‘çš„å°å­©æ‹¿çš„ç³–æœã€‚è¿™ä¸ªè´ªå¿ƒæ˜¯å¯¹çš„ é€‰æ‹©å¯ä»¥é€‰ç‚¹æœ€å°‘çš„å°å­©å¯ä»¥é¿å…åœ¨è¿™ä¸ªå°å­©èº«ä¸Šå‡ºé”…ï¼Œç„¶åé€‰æ‹©å°å­©æœ€å°‘çš„ç³–æœå¯ä»¥ç»™åˆ«çš„å°å­©æ“ä½œç©ºé—´ ç„¶åå°±æ˜¯å¯è¡Œæ€§ï¼Œé¢˜ç›®é‡Œçš„è¦æ±‚å°±æ˜¯è®©å°å­©æ‹¿ç¦»ä»–æœ€è¿‘çš„ç³–æœï¼Œæ ¹æœ¬æ²¡æœ‰é€‰ç³–æœçš„æƒåˆ©ï¼Œé‚£æˆ‘ä»¬ä¸ºä»€ä¹ˆå¯ä»¥é€‰æ‹©å‘¢ï¼Ÿ ç»è¿‡æ‰‹ç©ä¸€ä¸‹ï¼Œå¯ä»¥å‘ç°å¯ä»¥æ„é€ æ–¹æ¡ˆä½¿å¾—æƒ³æ³•æˆç«‹ã€‚ åæ­£è€ƒåœºä¸Šåˆä¸ä¼šè®©è¯æ˜è´ªå¿ƒï¼Œæƒ³åˆ°å°±å†²å°±å®Œäº† Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define MAXN 1005#define ll long longusing namespace std;int n;struct node &#123; ll x, y; &#125;;node a[MAXN], b[MAXN], c;vector &lt;int&gt; kid[MAXN];vector &lt;int&gt; bel[MAXN];int vis[MAXN];ll dis(node a, node b)&#123; return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);&#125;int main()&#123; read(n); for (int i = 1; i &lt;= n; i++) read(a[i].x, a[i].y); read(c.x, c.y); for (int i = 1; i &lt;= n; i++) read(b[i].x, b[i].y); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; if (dis(a[i], c) &gt;= dis(a[i], b[j])) &#123; kid[i].push_back(j); bel[j].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; int who = 0, which = 0; for (int j = 1; j &lt;= n; j++) &#123; if (!vis[j] &amp;&amp; (!who || kid[j].size() &lt; kid[who].size())) who = j; &#125; for (int j : kid[who]) &#123; if (!which || bel[j].size() &lt; bel[which].size()) which = j; &#125; if (!kid[who].size()) &#123; printf(&quot;IMPOSSIBLE&quot;); return 0; &#125; vis[who] = 1; for (int j : kid[who]) bel[j].erase(lower_bound(bel[j].begin(), bel[j].end(), who)); for (int j : bel[which]) kid[j].erase(lower_bound(kid[j].begin(), kid[j].end(), which)); &#125; printf(&quot;POSSIBLE&quot;); return 0;&#125; 10.7 T1 ç»™å®šä¸€ä¸ªåºåˆ— a1,a2,â€¦,an{a_1, a_2, \\dots, a_n}a1â€‹,a2â€‹,â€¦,anâ€‹ å’Œä¸€ä¸ªæ•´æ•° sss ï¼Œæ±‚æœ‰å¤šå°‘æ­£æ•´æ•°åºåˆ— {k1,k2,â‹¯ ,kn}\\{k_{1}, k_{2}, \\cdots, k_{n}\\}{k1â€‹,k2â€‹,â‹¯,knâ€‹} ï¼Œæ»¡è¶³ âˆ‘i=1naikiâ‰¤s\\sum_{i=1}^{n} a_{i}^{k_{i}} \\leq sâˆ‘i=1nâ€‹aikiâ€‹â€‹â‰¤s ï¼Œå…¶ä¸­ nâ‰¤8n \\le 8nâ‰¤8 ã€‚ nâ‰¤8n \\le 8nâ‰¤8 è€¶ï¼ éš¾å¾—è€ƒè¯•æ•´ç­¾åˆ°é¢˜ï¼Œç›´æ¥ä¸Šçˆ†æœå“‡ï¼Œä½†æ˜¯å°±ç®—æ˜¯ç­¾åˆ°é¢˜ç›´æ¥æœä¹Ÿä¼šå¯„çš„è¾£ï¼Œ æŠ˜åŠæœå°±è¡Œäº† Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define ll long long#define the_great_will 10#define Marika 10000005using namespace std;int great_will, ye_dead;ll Dung_eater, deathbed[the_great_will], ye_live, Tarnished_elden_lord;ll elden_ring[Marika]; int Tarnished;ll elden_lord[Marika]; int demigods;void dfs(int black_knives, int bless, ll goldmask)&#123; if (goldmask &gt; Dung_eater) return; if (black_knives &gt; bless) &#123; if (bless == ye_dead) elden_ring[++Tarnished] = goldmask; else elden_lord[++demigods ] = goldmask; return; &#125; ll lands_between = deathbed[black_knives]; for (int grace = 1; grace; grace++) &#123; if (lands_between + goldmask &gt; Dung_eater) break; if (lands_between + ye_live - deathbed[black_knives] &gt; Dung_eater) break; dfs(black_knives + 1, bless, goldmask + lands_between); lands_between *= deathbed[black_knives]; &#125;&#125;int main()&#123; read(great_will, Dung_eater); ye_dead = (great_will &gt;&gt; 1); for (int grace = 1; grace &lt;= great_will; grace++) read(deathbed[grace]), ye_live += deathbed[grace]; dfs(1, ye_dead, 0); dfs(ye_dead+1, great_will, 0); sort(elden_ring+1, elden_ring+1+Tarnished); sort(elden_lord+1, elden_lord+1+demigods ); for (ll grace = 1; grace &lt;= Tarnished; grace++) &#123; ll j = upper_bound(elden_lord+1, elden_lord+1+demigods , Dung_eater - elden_ring[grace]) - elden_lord - 1; Tarnished_elden_lord += j; &#125; printf(&quot;%lld&quot;, Tarnished_elden_lord); return 0;&#125; T2 æ¢…ç³å¨œæƒ³ç§æ ‘ï¼Œä½†æ˜¯æœ¨å¤´æ²¡è„‘å­ï¼Œå†³å®šè®©ç¬¬ iii ä¸ªç‚¹çš„çˆ¶äº²åœ¨ [1,iâˆ’1][1, i-1][1,iâˆ’1] ä¹‹é—´éšæœºã€‚ä½†æ˜¯æœ¨å¤´åˆè§‰å¾—å¤ªçŸ®äº†ï¼Œå°±å†³å®šç»™æ¯ä¸ªç‚¹åŠ ä¸¤ä¸ªæƒå€¼ ai,bia_i, b_iaiâ€‹,biâ€‹ , è¡¨ç¤ºç¬¬ jjj ä¸ªç‚¹ä½œä¸ºç¬¬ iii ä¸ªç‚¹çš„çˆ¶äº²çš„æ¦‚ç‡æ˜¯ aja1+a2+â‹¯+aiâˆ’1\\frac{a_{j}}{a_{1}+a_{2}+\\cdots+a_{i-1}}a1â€‹+a2â€‹+â‹¯+aiâˆ’1â€‹ajâ€‹â€‹ , ä¸”è¾¹ (j,i)(j, i)(j,i) çš„é•¿åº¦ä¸º bi+bjb_i + b_jbiâ€‹+bjâ€‹ ã€‚ è¦æ±‚è´¼æ‹‰å¤šçš„ç‡ƒæ–™æ¢…ç³å¨œå°å§å¾ˆå¥½å¥‡è¿™é¢—æ ‘çš„ç»“æ„ï¼Œæ¯æ¬¡è¯¢é—® u,vu, vu,v çš„æœŸæœ›è·ç¦» æ ¹æ®æœŸæœ›çš„çº¿æ€§ï¼Œç­”æ¡ˆæ˜¯ E(dep(u))+E(dep(v))âˆ’2Ã—E(dep(lca(u,v)))E(dep(u))+E(dep(v))-2 \\times E(dep(lca(u, v)))E(dep(u))+E(dep(v))âˆ’2Ã—E(dep(lca(u,v))) E(dep(u))E(dep(u))E(dep(u)) æšä¸¾çˆ¶äº²æ¥æ±‚ âˆ‘i=1uâˆ’1ai(E(dep(i))+bi+bu)âˆ‘i=1uâˆ’1ai\\frac{\\sum_{i=1}^{u-1} a_{i}\\left(E(dep(i))+b_{i}+b_{u}\\right)}{\\sum_{i=1}^{u-1} a_{i}} âˆ‘i=1uâˆ’1â€‹aiâ€‹âˆ‘i=1uâˆ’1â€‹aiâ€‹(E(dep(i))+biâ€‹+buâ€‹)â€‹ è¿˜æœ‰å°±æ˜¯ u,vu, vu,v çš„ lcalcalca åˆ°åˆ°æ ¹çš„æœŸæœ›è·ç¦» E(lca(u,v))=aufu+âˆ‘i=1uâˆ’1E(lca(i,u))âˆ‘i=1uaiE(lca(u, v))=\\frac{a_{u} f_{u}+\\sum_{i=1}^{u-1} E(lca(i, u))}{\\sum_{i=1}^{u} a_{i}} E(lca(u,v))=âˆ‘i=1uâ€‹aiâ€‹auâ€‹fuâ€‹+âˆ‘i=1uâˆ’1â€‹E(lca(i,u))â€‹ 10.8 T1 ç»™ä¸¤ä¸ªåºåˆ— aaa, bbbï¼Œâ»“åº¦åˆ†åˆ«ä¸º nnn, mmmï¼Œæ±‚ç›¸é‚»å…ƒç´ å±äºç»™å®šç‚¹å¯¹çš„ a,ba,ba,b å…¬å…±â¼¦åºåˆ—ä¸ªæ•° å…ˆç¦»æ•£åŒ–ã€‚ ç„¶åDPã€‚ f(i)f(i)f(i) è¡¨ç¤º å‰ jjj ä¸ªèƒ½é…æˆå‡ å¯¹ï¼Œæ–°æ‰¾åˆ°ä¸€å¯¹ï¼Œå°±åŠ ä¸Šä»¥å‰æ‰¾åˆ°çš„ï¼Œæ‰€ä»¥å‰ç¼€å’Œä¼˜åŒ–å°±å®Œäº†å¥¥ Code 123456789for (int i = 1;i&lt;=n;i++)&#123; int s = 1; for (int j=1;j&lt;=m;j++)&#123; int t=f[j]; if (a[i]==b[j]) add(f[j],s),add(ans,s); if (mp[b[j]][a[i]]) add(s,t); &#125;&#125; T2 nnn ä¸ªç‚¹ï¼Œåˆå§‹æ—¶æ²¡æœ‰è¾¹é¡¹é“¾ï¼Œé“¾æ¥ç¬¬ iii å’Œç¬¬ jjj ä¸ªç‚¹çš„ä»£ä»·æ˜¯ di,jd_{i,j}di,jâ€‹ æ¯ä¸ªç»“ç‚¹ä¸Šä½ç€ä¸€ä¸ªé­”æ³•å±…æ°‘ï¼Œè‹¥ä¸¤ä¸ªèŠ‚ç‚¹é—´æœ‰è¾¹ç›´æ¥ç›¸è¿ï¼Œåˆ™ä»–ä»¬æˆä¸ºé‚»å±…ã€‚å±…æ°‘ä¸€å…±æœ‰ä¸‰ç§ç±»å‹ï¼š æ‘æ°‘ï¼šä»–ä»¬åªèƒ½æ‹œè®¿è‡ªå·±çš„é‚»å±…ï¼› å·«å¸ˆï¼šä»–ä»¬å¯ä»¥æ‹œè®¿è‡ªå·±çš„é‚»å±…ä»¥åŠé‚»å±…çš„é‚»å±…ï¼› å¤§é­”æ³•å¸ˆï¼šå¯ä»¥æ‹œè®¿æ‰€æœ‰ä¸è‡ªå·±è¿é€šçš„äººã€‚ æ¯ç§ç±»å‹çš„å±…æ°‘è¦ä¹ˆä¸å‡ºç°ï¼Œè¦ä¹ˆè‡³å°‘å‡ºç°ä¸¤ä¸ªã€‚æ¯ä¸ªå±…æ°‘éƒ½å¸Œæœ›å¯ä»¥æ‹œè®¿å…¶ä»–æ‰€æœ‰çš„å±…æ°‘ã€‚æ±‚åœ¨é“è·¯æ•°ç›®æœ€å°‘çš„å‰æä¸‹çš„æœ€å°ä»£ä»·ã€‚ è¿›è¡Œä¸€ä¸ªæƒ…å†µçš„åˆ†ä¸è´ªå¿ƒ å¦‚æœæœ‰æ‘æ°‘çš„è¯ï¼Œç›´æ¥æŠŠæ¯ä¸€ä¸ªæ‘æ°‘éƒ½å’Œå…¶ä»–äººè¿ä¸Šè¾¹å°±è¡Œè¾£ã€‚è¿™æ ·å·«å¸ˆä¸‰ï¼šç‹‚çŒå’Œå¤§é­”æ³•å¸ˆä¹Ÿæ»¡è¶³äº†ã€‚ å¦‚æœåªæœ‰å¤§é­”æ³•å¸ˆçš„è¯ï¼Œç›´æ¥æœ€å°ç”Ÿæˆæ ‘å°±è¡Œäº†ã€‚ å¯¹äºå‰©ä¸‹çš„æƒ…å†µä¸»è¦æ˜¯è¿™æ ·çš„ï¼Œå¯ä»¥ä»¥ä¸€ä¸ªç‚¹ä¸ºæ ¹å‘å…¶ä½™çš„ç‚¹å…¨è¿ä¸Šè¾¹ï¼Œæ‰€ä»¥æœ€å°‘çš„è¾¹æ•°æ˜¯ nâˆ’1n-1nâˆ’1ã€‚ å·«å¸ˆä¹‹é—´å¿…é¡»è¦è¿è¾¹æˆ–è€…è¿å‘åŒä¸€ä¸ªäººï¼Œé‚£ä¹ˆä¹Ÿå°±æ˜¯è¯´å¯ä»¥æšä¸¾ä¸Šé¢è¯´çš„ nnn ã€‚ è¿˜æœ‰å°±æ˜¯åªæœ‰ä¸¤ä¸ªå·«å¸ˆçš„æƒ…å†µï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä»–ä»¬ä¹‹é—´è¿è¾¹ï¼Œç„¶åå‰©ä¸‹çš„ç‚¹å“ªä¸ªä»£ä»·å°‘è¿é‚£ä¸ªã€‚ç‰¹åˆ¤å– minminmin å³å¯ T3 ç»™å®šä¸¤ä¸ªåºåˆ—ï¼Œå®‰æ’é¡ºåºï¼Œä½¿å¾—å¯¹åº”ä½ç½®å¼‚æˆ–å‡ºæ¥çš„æ–°åºåˆ—å­—å…¸åºæœ€å°‘ å»ºä¸¤é¢— Trie æ ‘è´ªå¿ƒï¼ŒçœŸæ˜¯æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œæ€ä¹ˆè€ƒè¯•å°±æ²¡æƒ³å‡ºæ¥å‘¢éº»éº»åœ° Code 12345678910void query(int u, int v, int d, int now)&#123; a.siz[u]--; b.siz[v]--; if (cnt &gt;= n) return; if (d &lt; 0) &#123; ans[++cnt] = now; return; &#125; while (a.siz[lsa(u)] &amp;&amp; b.siz[lsb(v)]) query(lsa(u), lsb(v), d-1, now); while (a.siz[rsa(u)] &amp;&amp; b.siz[rsb(v)]) query(rsa(u), rsb(v), d-1, now); while (a.siz[lsa(u)] &amp;&amp; b.siz[rsb(v)]) query(lsa(u), rsb(v), d-1, now + (1 &lt;&lt; d)); while (a.siz[rsa(u)] &amp;&amp; b.siz[lsb(v)]) query(rsa(u), lsb(v), d-1, now + (1 &lt;&lt; d));&#125; 10.10 T1 æœ‰nåº§å±±ï¼ŒmåªçŒ«å’Œpä¸ªå·¥ä½œäººå‘˜ã€‚å±±ä»å·¦å¾€å³ç¼–å·ä¸º 1âˆ¼n1 \\sim n1âˆ¼nï¼Œå±± iii å’Œ iâˆ’1i-1iâˆ’1 ä¹‹é—´çš„è·ç¦»æ˜¯ ddd ç±³ã€‚æœ‰ä¸€å¤©ï¼ŒçŒ«éƒ½åˆ°å±±ä¸Šå»ç©äº†âˆ¶ç¬¬ iii åªçŒ«ä¼šåˆ°å±± hih_ihiâ€‹ å»ï¼Œå¹¶ä¸€ç›´ç©åˆ°æ—¶é—´ tttï¼Œä¹‹åå°±åœ¨é‚£åº§å±±ç­‰å¾…å·¥ä½œäººå‘˜æ¥æ¥å®ƒã€‚æ¯ä¸ªå·¥ä½œäººå‘˜çš„çº¿è·¯éƒ½æ˜¯ä»1èµ°åˆ°nï¼Œå¹¶å¸¦èµ°æ²¿é€”ä»»æ„åªåœ¨ç­‰å¾…çš„çŒ«ã€‚å·¥ä½œäººå‘˜é€Ÿåº¦ä¸ºæ¯å•ä½æ—¶é—´1ç±³ï¼Œä¸èƒ½åœ¨å±±ä¸Šåœç•™ã€‚å®‰æ’æ¯ä¸ªå·¥ä½œäººå‘˜å‡ºå‘çš„æ—¶é—´ï¼Œä½¿æ‰€æœ‰çŒ«çš„ç­‰å¾…æ—¶é—´æ€»å’Œæœ€å° æ–œç‡ä¼˜åŒ–DP é¦–å…ˆå¯ä»¥å‘ç°çš„æ˜¯æ¯ä¸ªäººä¸€å®šæ˜¯é€‰æ‹©æ°å¥½å¯ä»¥æ¥åˆ°ä¸€åªçŒ«çš„æ—¶å€™å‡ºå‘ timitim_itimiâ€‹ è¡¨ç¤ºæƒ³è¦æ°å¥½æ¥åˆ°ç¬¬ iii åªçŒ«è¦ä»ä»€ä¹ˆæ—¶åˆ»å‡ºå‘ã€‚å…ˆå¯¹ timitim_itimiâ€‹ æ’ä¸ªåºï¼Œé‚£ä¹ˆåœ¨ iii å‰é¢çš„éƒ½èƒ½è¢« iii æ¥åˆ° é‚£ä¹ˆ fi,jf_{i, j}fi,jâ€‹ è¡¨ç¤ºç¬¬ iii ä¸ªäººé€‰ç¬¬ jjj åªçŒ«çš„æœ€å°èŠ±è´¹ã€‚ è½¬ç§»çš„è¯ï¼Œæ¯”å¦‚è¯´ç¬¬ iâˆ’1i-1iâˆ’1 ä¸ªäººé€‰æ‹©äº†ç¬¬ kkk åªçŒ«ï¼Œç¬¬ iii ä¸ªäººé€‰æ‹©äº†ç¬¬ jjj åªçŒ«ï¼Œé‚£ä¹ˆè¿™ä¸ªäººå¯ä»¥æŠŠ [k+1,j][k+1, j][k+1,j] çš„çŒ«å…¨æ‹¿ä¸‹ï¼Œè¿™äº›çŒ«ä¸€å…±ç­‰å¾… âˆ‘i=k+1jtjâˆ’ti\\sum\\limits_{i = k+1}^{j} t_j - t_ii=k+1âˆ‘jâ€‹tjâ€‹âˆ’tiâ€‹ çš„æ—¶é—´ï¼Œè®°å½• sss ä¸º ttt çš„å‰ç¼€å’Œï¼Œè½¬ç§»å°±æ˜¯ fi,j=fiâˆ’1,k+âˆ‘p=k+1j(tjâˆ’tp)f_{i,j} = f_{i-1, k} + \\sum\\limits_{p = k+1}^j (t_j - t_p) fi,jâ€‹=fiâˆ’1,kâ€‹+p=k+1âˆ‘jâ€‹(tjâ€‹âˆ’tpâ€‹) ç¨å¾®å˜ä¸€å˜ \\begin{align} f_{i,j} &amp;= f_{i-1, k} + \\sum\\limits_{p = k+1}^j (t_j - t_p) \\\\ &amp;= f_{i-1, k} + (j-k) \\times t_j - s_j + s_k \\\\ &amp;= f_{i-1, k} + jt_j - kt_j - s_j + s_k \\\\ \\end{align} å‘ç°å¯¹äº kkk æ˜¯ä¸€ä¸ªä¸€æ¬¡å‡½æ•°ï¼Œæ–œç‡ä¼˜åŒ– T2 ç»™å®šä¸€ä¸ªé•¿ä¸º nnn çš„åºåˆ— aaa ï¼Œå¯¹ kâˆˆ[1,n]k \\in [1, n]kâˆˆ[1,n] æ±‚ âˆ‘i=1kâˆ‘j=1kaimodaj\\sum\\limits_{i = 1}^{k} \\sum\\limits_{j = 1}^{k} a_imod a_j i=1âˆ‘kâ€‹j=1âˆ‘kâ€‹aiâ€‹modajâ€‹ æ¯æ¬¡ kkk åŠ ä¸€ä¼šå‘å¤–æ‰©å±•ä¸€è¡Œå’Œä¸€åˆ—ï¼Œä¹Ÿå°±æ˜¯ âˆ‘i=1kak%aj+aj%ak\\sum\\limits_{i = 1}^{k} a_k \\% a_j + a_j \\% a_ki=1âˆ‘kâ€‹akâ€‹%ajâ€‹+ajâ€‹%akâ€‹ è€ƒè™‘ä¼˜åŒ–ï¼Œå¯¹äº aj%aka_j \\% a_kajâ€‹%akâ€‹ æˆ‘ä»¬æŠŠ æ¨¡è¿ç®—å˜ä¸ºé™¤ï¼Œåˆ†å—ï¼Œæšä¸¾ aka_kakâ€‹ çš„å€æ•° å¯¹äº ak%aja_k \\% a_jakâ€‹%ajâ€‹ æˆ‘ä»¬åœ¨æ¯ä¸ª aja_jajâ€‹ çš„ä½ç½®ä¸ŠåŠ ä¸Š aja_jajâ€‹ , ç„¶åæŸ¥è¯¢ aka_kakâ€‹ ä½ç½®ä¸Šçš„å‰ç¼€å’Œå°±è¡Œè¾£ ç»´æŠ¤ä¸¤ä¸ªæ ‘çŠ¶æ•°ç»„ Code 1234567891011121314151617for (int k = 1; k &lt;= n; k++)&#123; ll bs = a[k], t = 0; sum += bs; t1.add(bs, 1); ll tmp = 0; for (ll i = 0; i &lt;= mx; i += bs, t++) &#123; tmp += t1.query(i, i + bs - 1) * t; t2.add(i, a[k]); &#125; ans += k * bs - t2.query(1, a[k]); tmp = sum - bs * tmp; ans += tmp; printf(&quot;%lld &quot;, ans);&#125; 10.11 å¯„ 10.12 T1 æœ‰ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„ç¯ï¼Œsis_isiâ€‹ è¡¨ç¤º iii ä½ç½®ä¸Šçš„é¢œè‰²ã€‚æ¯æ¬¡ä»ä¸Šé¢å‰ªå»ä¸€æ®µé•¿åº¦ä¸º kkk çš„è¿ç»­æ®µã€‚å†æŠŠå‰©ä½™éƒ¨åˆ†é¦–å°¾ç›¸æ¥ï¼Œè¯¢é—®æ¯æ¬¡æ“ä½œåçš„èŠ±ç¯æ˜¯ä¸æ˜¯ç¾ä¸½çš„ ç¾ä¸½æŒ‡çš„æ˜¯ç¯ä¸Šä»»æ„ä¸¤ä¸ªç›¸é‚»ä½ç½®çš„é¢œè‰²ä¸åŒ ä»ä¿ç•™çš„éƒ¨åˆ†ä¸‹æ‰‹ï¼Œå¯¹äºä¸€ä¸ªç¡®å®šçš„å·¦ç«¯ç‚¹ l, å®ƒèƒ½ä¿ç•™åˆ°çš„å³ç«¯ç‚¹ r æ˜¯å•è°ƒä¸å¢çš„ï¼Œæˆ‘ä»¬å›ºå®šä¸€ä¸ªé•¿åº¦ä¸º kkk çš„åŒºé—´ï¼Œå¦‚æœåŒºé—´æœ‰ä¸¤ä¸ªç›¸é‚»ç›¸åŒçš„ï¼Œé‚£ä¹ˆè¿™ä¸ªåŒºé—´å°±ä¸èƒ½å…­ï¼Œè¿˜æœ‰å°±æ˜¯åŒºé—´çš„åšå³ç«¯ç‚¹ä¸èƒ½ç›¸åŒ T2 ç»™ä¸€ä¸ªç«èµ›å›¾ï¼Œä»¤ dist(u,v)dist(u,v)dist(u,v) è¡¨ç¤ºæœ€çŸ­è·¯ï¼Œæ±‚ minâ¡1â‰¤uâ‰¤nmaxâ¡1â‰¤vâ‰¤ndist(u,v)\\min\\limits_{1\\le u \\le n} \\max\\limits_{1 \\le v \\le n} dist(u, v)1â‰¤uâ‰¤nminâ€‹1â‰¤vâ‰¤nmaxâ€‹dist(u,v) æ‰‹ç©ä¸€ä¸‹å‘ç°ï¼Œç­”æ¡ˆåªæœ‰ 0,1,20, 1, 20,1,2 ä¸‰ç§å¯èƒ½ å¦‚æœåªæœ‰ä¸€ä¸ªç‚¹ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º 000 å¦‚æœå­˜åœ¨ä¸€ä¸ªç‚¹å’Œå…¶ä»–è¾¹éƒ½æœ‰è¿è¾¹ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º 111 å¦åˆ™ä¸º 222 T3 æœ€å¤§æƒå®Œç¾åŒ¹é…ï¼Œè½¬åŒ–ä¸ºè´¹ç”¨æµï¼Œç‚¹ä¹‹é—´è¿æµé‡ä¸º 111 ,è´¹ç”¨ä¸º $$ ç»™å®šä¸€ä¸ªæ•°åˆ— A1â€¦nA_{1 \\dots n}A1â€¦nâ€‹ , 10.14 15 T1 ç»™å®šä¸€ä¸ªæ•°åˆ— A1â€¦nA_{1 \\dots n}A1â€¦nâ€‹ , å¯¹äº 1â€¦n1 \\dots n1â€¦n çš„æ¯ä¸€ä¸ª kkk ï¼Œè¦æŠŠå®ƒåˆ†æˆ kkk çš„éç©ºçš„è¿ç»­æ®µï¼Œå¯¹æ¯æ®µåˆ†åˆ«æ±‚å’Œï¼Œå¾—åˆ° kkk ä¸ªæ•°ï¼Œæœ€å¤§åŒ–ä»–ä»¬çš„æœ€å¤§å…¬çº¦æ•° è®°å‰ç¼€å’Œä¸º sumsumsum é‚£ä¹ˆä¹Ÿå°±æ˜¯æŠŠå’Œåˆ†ä¸º kkk ä¸ªéƒ¨åˆ†ï¼Œç„¶åæ‰¾åˆ°ä¸€ä¸ª ddd æ»¡è¶³ dâˆ£sumd \\mid sumdâˆ£sum å¹¶ä¸” dâˆ£sumkd \\mid sumkdâˆ£sumk æšä¸¾çº¦æ•°å³å¯ T2 ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„éè´Ÿæ•´æ•°åºåˆ— a1,â‹¯ ,ana_1,\\cdots,a_na1â€‹,â‹¯,anâ€‹ ã€‚ç»Ÿè®¡äºŒå…ƒç»„ (i,j)(i,j)(i,j) çš„æ•°é‡ï¼Œæ»¡è¶³ $1\\leq i\\leq j\\leq n $ ä¸” aiâŠ•ai+1âŠ•â‹¯âŠ•ajâ‰¤maxâ¡{ai,ai+1â‹¯ ,aj}a_i\\oplus a_{i+1}\\oplus \\cdots\\oplus a_j\\leq \\max\\{a_i,a_{i+1}\\cdots,a_j\\}aiâ€‹âŠ•ai+1â€‹âŠ•â‹¯âŠ•ajâ€‹â‰¤max{aiâ€‹,ai+1â€‹â‹¯,ajâ€‹} ã€‚ å†·é—¨æ•°æ®ç»“æ„ï¼Œç”¨ç¬›å¡å°”æ ‘ç»´æŠ¤æœ€å¤§å€¼ï¼Œç°åœ¨éœ€è¦ n2n^2n2 æšä¸¾æœ€å¤§å€¼å’ŒåŒºé—´ç„¶åå¯æŒä¹…åŒ– 01Trieï¼Œè€ƒè™‘å¦‚ä½•ä¼˜åŒ– æˆ‘ä»¬æšä¸¾æœ€å¤§å€¼æ˜¯ä¸€å®šçš„ï¼Œé‚£ä¹ˆåŒºé—´å·¦å³ç«¯ç‚¹çš„ç»´æŠ¤å¯ä»¥ç±»ä¼¼äºå¯å‘å¼åˆå¹¶ï¼Œæ”¹ä¸º 01Trie åˆå¹¶å³å¯ T3 ç»™å®šä¸€ä¸ª kkk æ±‚ [L,R][L, R][L,R] å†…æ»¡è¶³ä¸‹åˆ—æ¡ä»¶çš„å€¼çš„å’Œ âˆ€iâˆˆ[2,min(xâˆ’1,k)],iâˆ¤x \\forall i \\in [2, min(x-1, k)], i \\nmid x âˆ€iâˆˆ[2,min(xâˆ’1,k)],iâˆ¤x ä¸€çœ¼ç­›ï¼Œæˆ‘ä»¬å…ˆç¡®å®šæ‰€æœ‰å¯èƒ½æˆä¸º xxx çš„çº¦æ•°çš„æ•°ã€‚æ— éæ˜¯æ¯” kkk å°çš„è´¨æ•°ã€‚ ç„¶åå†ç”¨è¿™äº›è´¨æ•°ç­›å°±å®Œäº† T4 æ‚¨åœ¨æ‰“éŸ³æ¸¸ï¼Œç»™å®šä¸€ä¸ªé•¿ä¸º nnn çš„åºåˆ— ppp ï¼Œè¡¨ç¤ºç¬¬ iii ä¸ªæ‹å­æ‚¨ pperfectpperfectpperfect çš„æ¦‚ç‡ï¼Œæ‚¨çš„å¾—åˆ†ç”±åŸºç¡€åˆ†å’Œè¿å‡»åˆ†æ„æˆã€‚æ‚¨å·²ç»å‡ºç¥å…¥åŒ–ï¼Œå¦‚æœæ²¡æœ‰ perfectperfectperfect ï¼Œå°±åªä¼š missmissmiss SiS_iSiâ€‹ è¡¨ç¤ºç¬¬ iii ä¸ªéŸ³ç¬¦æ˜¯å¦ perfectperfectperfect åŸºç¡€åˆ† =AÃ—âˆ‘iâˆ’1nSi= A \\times \\sum_{i-1}^{n} S_i=AÃ—âˆ‘iâˆ’1nâ€‹Siâ€‹ è¿å‡»åˆ†éœ€è¦ä¸€ä¸ªè®¡ç®—çš„å‡½æ•° fff f(i)={Sii=1f(iâˆ’1)+1iâ‰ 1âˆ§Si=1f(iâˆ’1)Ã—t otherwise f(i)=\\left\\{\\begin{array}{lr} S_{i} &amp; i=1 \\\\ f(i-1)+1 &amp; i \\neq 1 \\wedge S_{i}=1 \\\\ f(i-1) \\times t &amp; \\text { otherwise } \\end{array}\\right. f(i)=â©âªâ¨âªâ§â€‹Siâ€‹f(iâˆ’1)+1f(iâˆ’1)Ã—tâ€‹i=1iî€ =1âˆ§Siâ€‹=1 otherwise â€‹ è¿å‡»åˆ† =BÃ—(âˆ‘iâˆ’1nSi)= B \\times \\left(\\sum_{i-1}^{n} S_i\\right)=BÃ—(âˆ‘iâˆ’1nâ€‹Siâ€‹) å› ä¸ºæ‚¨ä¸€è¾¹ç¡è§‰ä¸€è¾¹æ‰“ï¼Œä¼šæœ‰ä¸€äº›çªå‘äº‹ä»¶å¯¼è‡´æŸä¸ªä½ç½®çš„ ppp æ”¹å˜ã€‚æ¯æ¬¡è¯¢é—® [l,r][l, r][l,r] çš„æœŸæœ›å¾—åˆ† æ¨æ¨å°æŸ¿å­ï¼Œç»´æŠ¤ fff å’Œæ€»å¾—åˆ† sumsumsum ï¼Œæ¨å¼å­å‘ç°å¯ä»¥çŸ©é˜µä¼˜åŒ–ï¼Œè½¬ç§»çŸ©é˜µ f,sumf, sumf,sum å’Œå¸¸æ•° ç„¶åå°±æ˜¯çº¿æ®µæ ‘ç»´æŠ¤çŸ©é˜µï¼Œå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´ä¹˜ å…¶å®ä¹Ÿå¯ä»¥ç›´æ¥ kx+bkx + bkx+b ç»´æŠ¤æ€»å¾—åˆ†ã€‚çŸ©é˜µçš„åšæ³•æ›´å¥½ç†è§£ 10.16 T1 ä¸€ä¸ª nnn ä¸ªç‚¹çš„æ£®æ—ï¼Œæ¯ä¸ªç‚¹è¢«æ¶‚æˆé»‘è‰²æˆ–ç™½è‰²ï¼Œéœ€è¦åˆ å»ä¸€äº›è¾¹ä½¿å¾—æ‰€æœ‰é»‘ç‚¹çš„åº¦æ•°ä¸ºå¥‡æ•°ï¼Œæ‰€æœ‰ç™½ç‚¹çš„åº¦æ•°ä¸ºå¶æ•°ã€‚æ±‚ä¿ç•™çš„è¾¹å­—å…¸åºæœ€å°çš„æ–¹æ¡ˆã€‚ æœ€èƒ½æƒ³åˆ°çš„æ–¹æ¡ˆå°±æ˜¯ç›´æ¥æŠŠä¸¤ä¸ªé»‘ç‚¹è¿èµ·æ¥ï¼Œå®é™…ä¸Šç›´æ¥æŠŠä¸¤ä¸ªé»‘ç‚¹ä¹‹é—´çš„è·¯å¾„è¿èµ·æ¥ç¡®å®æ˜¯å¯¹çš„ã€‚ é™¤äº†åœ¨ç«¯ç‚¹ä¸Šçš„ä¸¤ä¸ªé»‘ç‚¹ï¼Œè·¯å¾„ä¸Šçš„å…¶ä»–ç‚¹éƒ½æ˜¯ä¸€æ¡è¾¹è¿›ï¼Œä¸€æ¡è¾¹å‡ºï¼Œåº¦æ•°ä¸ä¼šæ”¹å˜ï¼Œæ‰€ä»¥ä¹Ÿå°±æ˜¯è¯´æ¯æ¬¡æ‰¾ä¸¤ä¸ªé»‘ç‚¹ï¼Œæ‰“é€šä¹‹é—´çš„è·¯å¾„å°±è¡Œäº†ï¼Œé»‘ç‚¹ä¸ªæ•°ä¸æ˜¯å¶æ•°å°±æ— è§£ çº¿æ®µæ ‘ç»´æŠ¤è¾¹åŒºé—´å–åè¡¨ç¤ºä¿ç•™ä¸ä¿ç•™å°±å®Œäº†å¥¥ T2 ä¸€å¼ å›¾ï¼Œæ¯ä¸ªç‚¹æœ‰ç‚¹æƒï¼Œå° kkk å’Œè¾¹ä¹‹é—´æœ‰é¢œè‰²ï¼Œä¸èƒ½é€šè¿‡å’Œè‡ªå·±ä¸€æ ·é¢œè‰²çš„è¾¹ï¼Œä½†æ˜¯å° kkk å¯ä»¥ä¸­é€”åœ¨ä»»æ„ä¸€ä¸ªç‚¹æ”¹å˜é¢œè‰²ï¼Œæ¯æ¬¡è¯¢é—®ä»ç»™å®šçš„ç‚¹å‡ºå‘ï¼Œæœ€å¤šçš„ç‚¹æƒå’Œã€‚ ç–¯ç‹‚ bfsbfsbfs å»å¤„ç†å‡ºæ¯ä¸ªé¢œè‰²çš„è¿é€šå—å’Œç›¸äº¤éƒ¨åˆ†çš„è¿é€šå—. 10.17 T1 å¼€å§‹æœ‰ nnn ä¸ªç‰©å“æ’æˆä¸€è¡Œï¼Œæ¯ä¸ªç‰©å“æœ‰ä¸€ä¸ªä»£ä»·å’Œä¸€ä¸ªä»·å€¼ ã€‚ä½ å¯ä»¥é€‰æ‹©ä¸¤ä¸ªç›¸é‚»çš„ä»£ä»·ä¹‹å’Œä¸è¶…è¿‡ kkk çš„ç‰©å“ï¼Œå°†å®ƒä»¬ä»åºåˆ—ä¸­åˆ å»ï¼Œå¹¶è·å¾—ä¸¤ä¸ªç‰©å“ä»·å€¼ä¹‹å’Œçš„æ”¶ç›Šã€‚æ±‚æœ€å¤§æ”¶ç›Š åŒºé—´ DP ï¼Œ fl,rf_{l,r}fl,râ€‹ è¡¨ç¤º l,rl, rl,r ä¸ªç‰©å“çš„è´¡çŒ® 123456789for (int len = 2; len &lt;= n; len++)for (int l = 1, r = l + len - 1; r &lt;= n; l++, r++)&#123; for (int _k = l+1; _k &lt; r; _k++) f[l][r] = max(f[l][r], f[l][_k] + f[_k+1][r]); if (f[l+1][r-1] == sum[r-1] - sum[l] &amp;&amp; a[l] + a[r] &lt;= k) // å¯ä»¥åˆå¹¶ f[l][r] = max(f[l][r], f[l+1][r-1] + b[l] + b[r]);&#125; T2 ä¸€å¼  nnn ä¸ªç‚¹çš„å›¾ï¼Œæ¯æ¡è¾¹æœ‰è¾¹æƒ d,(dâ‰¤9)d , (d \\le 9)d,(dâ‰¤9) ï¼Œ æ¯é€šè¿‡ä¸€æ¡è¾¹åä¸‹ä¸€æ¡è¾¹çš„èŠ±è´¹éƒ½ä¼šä¹˜ 101010 ã€‚æ±‚ä» 111 åˆ° nnn çš„æœ€çŸ­è·¯ã€‚ å› ä¸ºè¾¹æƒå°äº 999 æ‰€ä»¥å°‘èµ°ä¸€æ¡è¾¹è‚¯å®šæ›´ä¼˜ï¼Œæ‰€ä»¥è¦å°½é‡èµ°å°‘çš„è¾¹ã€‚ bfsbfsbfs é¢„å¤„ç†å‡ºåªç»è¿‡ 000 è¾¹å¯ä»¥åˆ°è¾¾ nnn çš„ç‚¹ï¼Œ ç„¶åæ¯ä¸€æ¡è¾¹çš„è¾¹æƒåœ¨ç­”æ¡ˆä¸­éƒ½è´¡çŒ®ä¸€ä½æ•°ï¼Œç„¶å bfsbfsbfs åˆ†å±‚ï¼Œæœ€å bfsbfsbfs æ‰¾è·¯å¾„ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define INF 0x3f3f3f3fusing namespace std;int n, m, k;int cnte = 1, head[MAXN];struct edge&#123; int st, to, nxt, dis;&#125;e[MAXN &lt;&lt; 2];void adde(int u, int v, int w)&#123; e[++cnte].st = u; e[cnte].to = v; e[cnte].nxt = head[u]; e[cnte].dis = w; head[u] = cnte;&#125;int cnt0[MAXN], dep[MAXN];queue &lt;int&gt; q; void bfs()&#123; memset(cnt0, -1, sizeof(cnt0)); q.push(n-1); cnt0[n-1] = 0; while (q.size()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (e[i].dis == 0 &amp;&amp; cnt0[v] == -1) &#123; cnt0[v] = cnt0[u] + 1; q.push(v); &#125; &#125; &#125;&#125;void bfs1()&#123; memset(dep, 0x3f, sizeof(dep)); q.push(0); dep[0] = 0; while (q.size()) &#123; int u = q.front(); q.pop(); if (cnt0[u] != -1) continue; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (dep[v] == 0x3f3f3f3f) &#123; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; &#125;&#125;int minc[MAXN]; bool vis[MAXN];int pre[MAXN], st[MAXN];void work()&#123; memset(minc, 0x3f, sizeof(minc)); int dop = INF; vector &lt;int&gt; vq; for (int i = 1; i &lt;= n; i++) if (cnt0[i] != -1) &#123; if (dep[i] &lt; dop) &#123; dop = dep[i]; vq.clear(); &#125; if (dep[i] == dop) &#123; vq.push_back(i); st[i] = i; &#125; &#125; for(;dop!=0;dop--) &#123; vector &lt;int&gt; tmp; sort(vq.begin(), vq.end(), [&amp;](int x, int y) &#123; return cnt0[st[x]] &lt; cnt0[st[y]]; &#125;); while (vq.size()) &#123; int u = vq.front(); vq.pop_back(); if (vis[u]) continue; vis[u] = 1; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (dep[v] &gt;= dop) continue; if (e[i].dis &lt; minc[dop-1]) &#123; tmp.clear(); minc[dop-1] = e[i].dis; &#125; if (e[i].dis == minc[dop-1]) &#123; tmp.push_back(v); pre[v] = u; st[v] = st[u]; &#125; &#125; &#125; vq = tmp; &#125;&#125;void pr1nt(int x)&#123; if (cnt0[x] != -1) return; pr1nt(pre[x]); print(minc[dep[x]]);&#125;int main()&#123; #ifdef ONLINE_JUDGE freopen(&quot;great.in&quot;, &quot;r&quot;, stdin); freopen(&quot;great.out&quot;, &quot;w&quot;, stdout); #endif read(n, m); for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; read(u, v, w); adde(u, v, w); adde(v, u, w); &#125; bfs(); bfs1(); work(); if (cnt0[0] == -1) pr1nt(0), putchar(&#x27;\\n&#x27;); else puts(&quot;0&quot;); print(dep[st[0]] + cnt0[st[0]] + 1); return 0;&#125; T3 ä¸€æ£µ nnn ä¸ªç‚¹çš„æ ‘ï¼Œæ¯æ¡è¾¹éƒ½æœ‰ä¸€ä¸ªè¾¹æƒï¼Œæ¯æ¬¡å¯ä»¥é€‰æ‹©ä¸¤ä¸ªç‚¹ u,vu, vu,v è®©ä»–ä»¬ä¹‹é—´çš„è·¯å¾„éƒ½å¼‚æˆ–ä¸€ä¸ªæ•° xxxã€‚è¯¢é—®æœ€å°‘å‡ æ¬¡æ“ä½œå¯ä»¥ä½¿æ‰€æœ‰è¾¹è¾¹æƒä¸º 0 å®šä¹‰ä¸€ä¸ªç‚¹çš„æƒå€¼ä¸ºå®ƒçš„æ‰€æœ‰å‡ºè¾¹å¼‚æˆ–èµ·æ¥ã€‚é‚£ä¹ˆå¦‚æœæˆ‘ä»¬å¯¹ u,vu, vu,v è¿›è¡Œæ“ä½œï¼Œæƒå€¼ä¼šæ”¹å˜çš„åªæœ‰ u,vu, vu,v ã€‚ å› ä¸ºå…¶ä»–ç‚¹ä¸€ä¸ªè¿›ä¸€ä¸ªå‡ºï¼Œå¼‚æˆ–äº†ç™½å¼‚æˆ–ã€‚ æ˜¾ç„¶æ‰€æœ‰è¾¹æƒä¸º 000 ã€‚å½“ä¸”ä»…å½“æ‰€æœ‰ç‚¹æƒå€¼ä¸º 000 äºæ˜¯é—®é¢˜è½¬åŒ–ä¸ºäº†æŠŠè¿™äº›ç‚¹åˆ†ä¸ºå‡ ç»„ï¼Œåˆ†åˆ«æ“ä½œã€‚é¦–å…ˆä¸¤ä¸ªæƒå€¼ä¸€æ ·çš„ç‚¹å¯ä»¥å¼‚æˆ–ä¸Šè¿™ä¸ªæƒå€¼ï¼Œå…¶ä»–çš„çŠ¶å‹æšä¸¾å­é›†å³å¯ã€‚ 10.18 T1 æœ‰ nnn å †çŸ³å­ï¼Œç¬¬ iii å †æœ‰ xix_ixiâ€‹ ä¸ªï¼Œæ¯æ¬¡å¯ä»¥å–ä»ä¸€å †ä¸­ aâˆ¼ba \\sim baâˆ¼b ä¸ªã€‚è¯¢é—®å…ˆæ‰‹å¿…èƒœè¿˜æ˜¯å¿…è´¥ã€‚ ç»å…¸å¥—è·¯æ‰“ SG è¡¨æ‰¾è§„å¾‹ã€‚ å‘ç° SG å€¼æ˜¯æœ‰è§„å¾‹çš„ï¼Œå¤§æ¦‚æ˜¯ 1,0,2,3 æ„æˆçš„å¾ªç¯æ®µï¼Œæ¯æ®µé•¿ä¸º aaa ï¼Œæ¯æ®µä¸€èµ·çœ‹å¾ªç¯èŠ‚ä¸º a+b T2ARC104F ç»™ä¸€ä¸ªé•¿åº¦ä¸º NNN çš„æ•°åˆ— H1..NH_{1..N}H1..Nâ€‹ ï¼Œç¬¬ iii é¡¹åœ¨ [1,Hi][1,H_i][1,Hiâ€‹] ä¸­é€‰ä¸€ä¸ªæ•°ï¼Œå¾—åˆ°æ•°åˆ— X1..NX_{1..N}X1..Nâ€‹ ã€‚å†æ„é€ ä¸€ä¸ªæ•°åˆ— P1..NP_{1..N}P1..Nâ€‹ ï¼ŒPi=maxâ¡j(j&lt;i,Xj&gt;Xi)P_i=\\max j(j&lt;i, X_j &gt; X_i)Piâ€‹=maxj(j&lt;i,Xjâ€‹&gt;Xiâ€‹) ï¼Œè‹¥ä¸å­˜åœ¨è¿™æ ·çš„ jjj ï¼Œ Pi=âˆ’1P_i=-1Piâ€‹=âˆ’1 ã€‚æ±‚èƒ½å¤Ÿæ—©å‡ºå¤šå°‘ç§ PPP æˆ‘çœŸæœäº†ã€‚ è½¬åŒ–ä¸€ä¸‹ï¼Œiii å‘ pip_ipiâ€‹ è¿è¾¹ï¼Œå‘ç°æ˜¯ä¸€æ£µæ ‘ã€‹ã€‹ã€‚ ç„¶åå°±å¼€å§‹åŒºé—´ DP fl,r,vf_{l, r, v}fl,r,vâ€‹ è¡¨ç¤º lll åˆ° rrr ï¼Œxxx çš„æœ€å°å€¼çš„æœ€å¤§å€¼ä¸º vvv çš„æ£®æ—æ•°é‡ gl,r,vg_{l, r, v}gl,r,vâ€‹ è¡¨ç¤º lll åˆ° rrr ï¼Œxxx çš„æœ€å¤§å€¼ä¸º vvv çš„æ£®æ—æ•°é‡ è½¬ç§»çš„è¯ gL,R,V=fL+1,R,Vâˆ’1(HLâ‰¥V)fL,R,V=gL,R,V+âˆ‘K=LRâˆ’1âˆ‘W=1VfL,K,WÃ—gK+1,R,V+âˆ‘K=LRâˆ’1[HK+1â‰¥V]âˆ‘W=1Vâˆ’1FL,K,VÃ—gK+1,R,Wg_{L, R, V}=f_{L+1, R, V-1}\\left(H_{L} \\geq V\\right) \\\\ f_{L, R, V}=g_{L, R, V}+\\sum_{K=L}^{R-1} \\sum_{W=1}^{V} f_{L, K, W} \\times g_{K+1, R, V}+\\sum_{K=L}^{R-1}\\left[H_{K+1} \\geq V\\right] \\sum_{W=1}^{V-1} F_{L, K, V} \\times g_{K+1, R, W} gL,R,Vâ€‹=fL+1,R,Vâˆ’1â€‹(HLâ€‹â‰¥V)fL,R,Vâ€‹=gL,R,Vâ€‹+K=Lâˆ‘Râˆ’1â€‹W=1âˆ‘Vâ€‹fL,K,Wâ€‹Ã—gK+1,R,Vâ€‹+K=Lâˆ‘Râˆ’1â€‹[HK+1â€‹â‰¥V]W=1âˆ‘Vâˆ’1â€‹FL,K,Vâ€‹Ã—gK+1,R,Wâ€‹ ggg çš„è½¬ç§»çš„æ„æ€æ˜¯ï¼šå› ä¸º Hl&gt;vH_{l} &gt; vHlâ€‹&gt;v , lll è¿™ä¸ªä½ç½®çš„æ ‘å¯ä»¥å½“ä½œ [l+1,r][l+1, r][l+1,r] çš„æ ¹æŠŠä»–ä»¬éƒ½è¿èµ·æ¥ fff çš„è½¬ç§»çš„æ„æ€æ˜¯ï¼šé¦–å…ˆæ˜¯æ ‘çš„æ•°é‡ï¼Œç„¶åæšä¸¾å¯èƒ½æˆä¸ºæ ¹çš„æ ‘ï¼ŒæŠŠä»–å’Œå’Œä»–å·®ä¸å¤šçš„è¿èµ·æ¥ï¼Œç„¶åæšä¸¾å¯èƒ½æˆä¸ºè·Ÿä½†æ²¡æœ‰çš„æ ‘ï¼Œå’Œå…¶ä»–æ ‘æ„æˆæ£®æ— T3CF1140F å®šä¹‰ä¸€ä¸ªç‚¹é›†åˆ S={(xi,yi)}(1â‰¤iâ‰¤n)S=\\{(x_i,y_i)\\}(1\\leq i\\leq n)S={(xiâ€‹,yiâ€‹)}(1â‰¤iâ‰¤n) çš„æ‹“å±•æ“ä½œä¸ºå°†ç¬¦åˆä»¥ä¸‹æ¡ä»¶çš„ (x0,y0)(x_0,y_0)(x0â€‹,y0â€‹) åŠ å…¥ SSSï¼š å­˜åœ¨ a,ba,ba,bï¼Œä½¿å¾— (a,b),(a,y0),(x0,b)âˆˆS(a,b),(a,y_0),(x_0,b)\\in S(a,b),(a,y0â€‹),(x0â€‹,b)âˆˆSã€‚ ä¸æ–­æ‰§è¡Œä»¥ä¸Šæ“ä½œç›´åˆ°ä¸èƒ½æ“ä½œï¼Œæ­¤æ—¶å¾—åˆ°çš„é›†åˆå³ä¸ºæ‹“å±•é›†åˆã€‚ç°åœ¨ç»™å®š qqq ä¸ªæ“ä½œï¼Œæ¯æ¬¡åŠ å…¥æˆ–åˆ é™¤ä¸€ä¸ªç‚¹ï¼Œé‡å¤ç‚¹å³ä¸ºåˆ é™¤ï¼Œä½ éœ€è¦è¾“å‡ºæ¯ä¸ªæ“ä½œä¹‹åçš„æ‹“å±•é›†åˆå¤§å°ï¼ˆ çœ‹æ‰©å±•çš„è¿™ä¸ªè¿‡ç¨‹ï¼Œå…¶å®å°±æ˜¯äºŒåˆ†å›¾ï¼Œå·¦è¾¹å·¦éƒ¨ç‚¹ï¼Œå³è¾¹å³éƒ¨ç‚¹ï¼Œå¹¶æŸ¥é›†ç»´æŠ¤ siz ä¹˜èµ·æ¥å°±æ˜¯ç­”æ¡ˆã€‚ æ—¶é—´è½´ç”¨çº¿æ®µæ ‘åˆ†æ²»ç»´æŠ¤ Code s1z è¡¨ç¤ºå·¦éƒ¨ç‚¹å¤§å°, s2z è¡¨ç¤ºå³éƒ¨ç‚¹å¤§å°ï¼Œ res è¡¨ç¤ºç­”æ¡ˆ123456789101112void merge(int x, int y)&#123; int fx = find(x), fy = find(y); if (fx == fy) return; if (rk[fx] &gt; rk[fy]) swap(fx, fy); sta[++top] = &#123;fx, fy, s1z[fy], s2z[fy], rk[fy], res&#125;; fa[fx] = fy; rk[fy] += rk[fy] == rk[fx]; res -= 1LL * s1z[fx] * s2z[fx] + 1LL * s1z[fy] * s2z[fy]; s1z[fy] += s1z[fx]; s2z[fy] += s2z[fx]; res += 1LL * s1z[fy] * s2z[fy];&#125; 10.19 T1CF1163F ä¸€ä¸ªæ— å‘å›¾ï¼Œæ¯æ¬¡æŠŠä¿®æ”¹ä¸€æ¡è¾¹çš„è¾¹æƒï¼Œè¯¢é—® 111 åˆ° nnn çš„æœ€çŸ­è·¯é•¿åº¦ã€‚è¯¢é—®é—´ç›¸äº’ç‹¬ç«‹ åˆ†ç±»è®¨è®º ä»¤ dis1idis1_idis1iâ€‹ è¡¨ç¤º 111 å‡ºå‘åˆ° iii çš„æœ€çŸ­è·¯ï¼Œ dis2idis2_idis2iâ€‹ è¡¨ç¤º nnn å‡ºå‘åˆ° iii çš„æœ€çŸ­è·¯ ï¼Œä¿®æ”¹çš„è¾¹çš„ç«¯ç‚¹ä¸º uuu å’Œ vvv , ä¿®æ”¹çš„è¾¹åŸæ¥çš„æƒå€¼æ˜¯ xxx ï¼Œç°åœ¨çš„æƒå€¼æ˜¯ yyy ï¼ŒåŸæ¥æœ€çŸ­è·¯ä¸º distdistdist å¦‚æœä¿®æ”¹çš„è¾¹ä¸åœ¨åŸæ¥çš„æœ€çŸ­è·¯ä¸Šï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º min(dist,dis1u+yâˆ’x+dis2v,dis2u+yâˆ’x+dis1v)min(dist, dis1_u + y - x + dis2_v, dis2_u + y - x + dis1_v)min(dist,dis1uâ€‹+yâˆ’x+dis2vâ€‹,dis2uâ€‹+yâˆ’x+dis1vâ€‹) ã€‚ å¯ä»¥ O(1)O(1)O(1) å¦‚æœä¿®æ”¹çš„è¾¹åœ¨åŸæ¥çš„æœ€çŸ­è·¯ä¸Šï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º min(distâˆ’y+x,ä¸ç»è¿‡ u, v çš„æœ€çŸ­è·¯)min(dist - y + x, \\text{ä¸ç»è¿‡ u, v çš„æœ€çŸ­è·¯})min(distâˆ’y+x,ä¸ç»è¿‡ u, v çš„æœ€çŸ­è·¯) é‚£ä¹ˆä¸å¥½ç»´æŠ¤çš„å°±æ˜¯ä¸ç»è¿‡ u,vu, vu,v çš„æœ€çŸ­è·¯ã€‚æšä¸¾ä¸åœ¨ u,vu, vu,v çš„è¾¹æƒï¼Œçº¿æ®µæ ‘ç»´æŠ¤ï¼ŒåŒºé—´ä¿®æ”¹ T2CF1630B ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„æ•°ç»„ aaaã€‚ä½ éœ€è¦ç¡®å®šä¸€ä¸ªèŒƒå›´ [x,y][x,y][x,y]ï¼Œå¹¶å°† aaa æ•°ç»„åˆ†æˆ kkk æ®µï¼Œä½¿å¾—å¯¹äºæ¯ä¸€æ®µï¼Œåœ¨èŒƒå›´ [x,y][x,y][x,y] ä»¥å†…çš„å…ƒç´ ä¸ªæ•°å¤§äºåœ¨èŒƒå›´ [x,y][x,y][x,y] ä»¥å¤–çš„å…ƒç´ ä¸ªæ•°ã€‚è¯·æ±‚å‡ºä»»æ„ä¸€ç»„ä½¿å¾— yâˆ’xy-xyâˆ’x æœ€å°çš„ x,yx,yx,y å’Œåˆ’åˆ†çš„æ–¹æ¡ˆã€‚ ç­”æ¡ˆåŒºé—´æ˜¾ç„¶æ˜¯è¶Šå¤§è¶Šè¡Œï¼ŒåŒæŒ‡é’ˆæšä¸¾å€¼åŸŸï¼Œå¯¹äºæ¯ä¸ª rrr ï¼Œæ±‚å‡ºæœ€å°çš„åˆæ³•çš„ lll ï¼Œè´ªå¿ƒæ„é€ æ–¹æ¡ˆå³å¯ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344void ma1n()&#123; read(n, k); res = 561651561; cnt0 = 0; cnt1 = n; for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); cnt[a[i]]++; &#125; int l = 1; for (int r = 1; r &lt;= n; r++) &#123; cnt0 += cnt[r]; cnt1 -= cnt[r]; if (cnt0 - cnt1 &lt; k) continue; while (l &lt;= r &amp;&amp; cnt0 - cnt1 &gt;= k) &#123; int tmp = r - l + 1; if (tmp &lt; res) &#123; res = tmp; resl = l; resr = r; &#125; else if (tmp == res &amp;&amp; l &lt; resl) &#123; resl = l, resr = r; &#125; cnt0 -= cnt[l]; cnt1 += cnt[l++]; &#125; &#125; cout &lt;&lt; resl &lt;&lt; &#x27; &#x27; &lt;&lt; resr &lt;&lt; &#x27;\\n&#x27;; cnt0 = 0; cnt1 = 0; int last = 1, tot = 0; for (int i = 1; i &lt;= n; i++) &#123; cnt[a[i]]--; if (a[i] &gt;= resl &amp;&amp; a[i] &lt;= resr) cnt0++; else cnt1++; if (cnt0 - cnt1 == 1 &amp;&amp; tot &lt; k - 1) &#123; cout &lt;&lt; last &lt;&lt; &#x27; &#x27; &lt;&lt; i &lt;&lt; &#x27;\\n&#x27;; last = i + 1; tot++; cnt1 = cnt0 = 0; &#125; &#125; cout &lt;&lt; last &lt;&lt; &#x27; &#x27; &lt;&lt; n &lt;&lt; &#x27;\\n&#x27;;&#125; T3HNOI2011 æœ‰ nnn ä¸ªéŸ³é˜¶ï¼Œéœ€è¦ç”¨è¿™äº›éŸ³é˜¶ç»„æˆ mmm ä¸ªäº’ä¸ç›¸åŒçš„ç‰‡æ®µï¼Œè¦æ±‚åœ¨æ‰€æœ‰è¿™äº›ç‰‡æ®µä¸­æ¯ä¸ªéŸ³é˜¶çš„å‡ºç°æ¬¡æ•°äº’ä¸ç›¸åŒï¼Œè¯¢é—®æœ‰å¤šå°‘æ–¹æ¡ˆï¼Œç‰‡æ®µä¹‹é—´çš„é¡ºåºæ— å…³ç­”æ¡ˆã€‚ è½¬åŒ–ä¸€ä¸‹é—®é¢˜ï¼Œå°±æ˜¯é€‰å‡º mmm ä¸ªä¸ç›¸åŒçš„ 1,â€¦,n{1, \\dots, n}1,â€¦,n çš„å­é›†ï¼Œç„¶åæœ‰ä¸€äº›é™åˆ¶ã€‚ç‰‡æ®µä¹‹é—´çš„é¡ºåºæ— å…³ç´§è¦ï¼Œå¯ä»¥æœ€åé™¤ä»¥ m!m!m! ç„¶åå¯¹äºå‡ºç°æ¬¡æ•°æ˜¯å¶æ•°çš„é—®é¢˜ï¼Œç¬¬ nâˆ’1n-1nâˆ’1 ä¸ªç‰‡æ®µç¡®å®šäº†ï¼Œç¬¬ nnn ä¸ªç‰‡æ®µä¹Ÿå°±ç¡®å®šäº†","categories":[],"tags":[{"name":"æ€»ç»“","slug":"æ€»ç»“","permalink":"https://ve1bae.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://ve1bae.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"è´ªå¿ƒ","slug":"è´ªå¿ƒ","permalink":"https://ve1bae.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"æ•°å­¦æ‚é¡¹","slug":"æ•°å­¦æ‚é¡¹","date":"2022-09-27T08:08:23.000Z","updated":"2022-11-08T10:40:08.032Z","comments":true,"path":"2022/09/27/æ•°å­¦æ‚é¡¹/","link":"","permalink":"https://ve1bae.github.io/2022/09/27/%E6%95%B0%E5%AD%A6%E6%9D%82%E9%A1%B9/","excerpt":"æ•´ç†ä¸€äº›å°çŸ¥è¯†ç‚¹","text":"æ•´ç†ä¸€äº›å°çŸ¥è¯†ç‚¹ æ•°è®ºå°å‡½æ•° ç§¯æ€§å‡½æ•° Ï†\\varphiÏ† Î¼\\muÎ¼ Ïƒk(n)=âˆ‘dâˆ£ndk\\sigma_k(n) = \\sum\\limits_{d \\mid n} d^kÏƒkâ€‹(n)=dâˆ£nâˆ‘â€‹dk ddd å› æ•°ä¸ªæ•°å‡½æ•° Ïƒ0\\sigma_0Ïƒ0â€‹ Îµ(n)=[n=1]\\varepsilon(n) = [n = 1]Îµ(n)=[n=1] å•ä½å‡½æ•° å®Œå…¨ç§¯æ€§ I(n)=1I(n) = 1I(n)=1 å®Œå…¨ç§¯æ€§ id(n)=nid(n) = nid(n)=n å®Œå…¨ç§¯æ€§ æ€§è´¨ Ï†\\varphiÏ† n=p1Î±1â‹¯psÎ±sn=p_1^{\\alpha_1} \\cdots p_s^{\\alpha_s}n=p1Î±1â€‹â€‹â‹¯psÎ±sâ€‹â€‹ å¯¹ nnn å”¯ä¸€åˆ†è§£ Ï†(n)=nâˆi=1s(1âˆ’1pi)n=âˆ‘dâˆ£nÏ†(d)\\varphi(n) = n \\prod\\limits_{i=1}^s (1 - \\frac{1}{p_i}) \\\\ n = \\sum\\limits_{d \\mid n} \\varphi(d) Ï†(n)=ni=1âˆsâ€‹(1âˆ’piâ€‹1â€‹)n=dâˆ£nâˆ‘â€‹Ï†(d) Î¼\\muÎ¼ Î¼\\muÎ¼ ä¸ Ï†\\varphiÏ† Ï†=nâˆ‘dâˆ£nÎ¼(d)d\\varphi = n\\sum\\limits_{d \\mid n} \\frac {\\mu(d)}{d} Ï†=ndâˆ£nâˆ‘â€‹dÎ¼(d)â€‹ Î¼\\muÎ¼ ä¸ ddd çš„ d(ij)=âˆ‘xâˆ£iâˆ‘yâˆ£j[gcdâ¡(x,y)=1]d(i j)=\\sum_{x \\mid i} \\sum_{y \\mid j}[\\operatorname{gcd}(x, y)=1] d(ij)=xâˆ£iâˆ‘â€‹yâˆ£jâˆ‘â€‹[gcd(x,y)=1] å·ç§¯ Ï†âˆ—1=Id\\varphi*1 = IdÏ†âˆ—1=Id Î¼âˆ—1=Îµ\\mu * 1 = \\varepsilonÎ¼âˆ—1=Îµ Ïƒk=Idkâˆ—1\\sigma_k=Id_k*1Ïƒkâ€‹=Idkâ€‹âˆ—1 å¸¸è§åæ¼” è«æ¯”ä¹Œæ–¯åæ¼” \\begin{align} &amp;\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} [gcd(i,j) == 1] \\nonumber \\\\ =&amp;\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} \\sum\\limits_{d \\mid gcd(i,j)} \\mu(d)\\nonumber \\\\ =&amp;\\sum\\limits_{d=1}^n \\mu(d) \\sum\\limits_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum\\limits_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor} 1 \\nonumber \\\\ =&amp;\\sum\\limits_{d=1}^n \\mu(d) \\left\\lfloor \\frac{n}{d} \\right\\rfloor \\left\\lfloor \\frac{m}{d} \\right\\rfloor \\nonumber \\end{align} æ¬§æ‹‰åæ¼” \\begin{align} &amp;\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{n} gcd(i,j)\\nonumber \\\\ =&amp;\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{n} \\sum\\limits_{d \\mid gcd(i,j)} \\varphi(d)\\nonumber \\\\ =&amp;\\sum\\limits_{d=1}^n \\varphi(d) \\sum\\limits_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum\\limits_{j=1}^{\\lfloor \\frac{n}{d} \\rfloor} 1 \\nonumber \\\\ =&amp;\\sum\\limits_{d=1}^n \\varphi(d) \\left\\lfloor \\frac{n}{d} \\right\\rfloor ^2 \\nonumber \\end{align} ç‹„åˆ©å…‹é›·å‰ç¼€å’Œ f(i)=âˆ‘dâˆ£ig(i)f(i) = \\sum\\limits_{d\\mid i} g(i) f(i)=dâˆ£iâˆ‘â€‹g(i) ç±»ä¼¼ ç™Œæ°ç­› å¯ä»¥åœ¨ O(nlogâ¡logâ¡n)O(n\\log\\log n)O(nloglogn) å†…è§£å†³è¿™æ ·çš„é—®é¢˜ å…ˆç­›ä¸ªç´ æ•° ç„¶åç”¨ g(i)g(i)g(i) æ›´æ–° f(i)f(i)f(i) code 12345for(int i = 1; i &lt;= cnt; i++)&#123; for(int j = 1; j * prime[i] &lt;= n; j++) g[p[i] * j] += g[j]; &#125; ç±»ä¼¼çš„ è¿˜æœ‰åç¼€å’Œ f(i)=âˆ‘iâˆ£dg(i)f(i) = \\sum\\limits_{i\\mid d} g(i) f(i)=iâˆ£dâˆ‘â€‹g(i) å€’åºæšä¸¾ 12345for(int i = 1; i &lt;= cnt; i++)&#123; for(int j = n/prime[i]; j; j--) g[p[i] * j] += g[j]; &#125; å·®ä¸å¤šçš„ å¯ä»¥ç”¨ f(i)f(i)f(i) æ±‚ g(i)g(i)g(i) ä¸¤çº§åè½¬ 12345for(int i = cnt; i; i--)&#123; for(int j = n/prime[i]; j; j--) f[j * prime[i]] -= f[j];&#125; ç­›å­ æ¬§æ‹‰ç­› çº¿æ€§ O(n)O(n)O(n) ç­›è´¨æ•° Code ç­› mumumu å’Œ varphivarphivarphi çš„ç‰ˆæœ¬12345678910111213141516171819void get_prime()&#123; isp[1] = mu[1] = phi[1] = 1; for (int i = 2; i &lt;= maxn; i++) &#123; if (!isp[i]) &#123; prime[++cnt] = i; mu[i] = -1; phi[i] = i - 1; &#125; for(int j = 1;j &lt;= cnt &amp;&amp; i*prime[j] &lt;= MAXN-5; j++) &#123; isp[i * prime[j]] = 1; if(i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; mu[i * prime[j]] = -mu[i]; &#125; &#125;&#125; æœæ•™ç­› å¯ä»¥åœ¨è¾ƒæ‹‰çš„äºšçº¿æ€§å¤æ‚åº¦å†…æ±‚å‡ºç§¯æ€§å‡½æ•°å‰ç¼€å’Œ ç°åœ¨æˆ‘ä»¬è¦æ±‚ fff çš„å‰ç¼€å’Œ S(n)S(n)S(n)ï¼Œæˆ‘ä»¬å…ˆæ„é€ å¦ä¸€ä¸ªç•¸æ€§å‡½æ•° gggï¼Œä»ä»–ä¿©çš„å·ç§¯çš„å‰ç¼€å’Œå…¥æ‰‹ã€‚ \\begin{align} \\sum\\limits_{i = 1}^n f*g &amp;= \\sum\\limits_{i = 1}^n \\sum\\limits_{d \\mid i} f(d) * g (\\frac id) \\nonumber\\\\ &amp;= \\sum\\limits_{d = 1}^n g(d) \\cdot \\sum\\limits_{i = 1}^{\\frac nd} f(i) \\nonumber\\\\ &amp;= \\sum\\limits_{d = 1}^n g(d) \\cdot S(\\frac nd) \\nonumber \\end{align} å¯¹å·ç§¯æ•´å‰ç¼€å’Œï¼Œç„¶åæˆ‘ä»¬æŠŠ g(1)g(1)g(1) æå‡ºæ¥ \\begin{align} g(1)S(n) &amp;+ \\sum\\limits_{d = 2}^n g(d)S(\\frac nd) =\\sum\\limits_i^n f*g \\nonumber\\\\ S(n) &amp;=\\frac{\\sum\\limits_i^n f*g - \\sum\\limits_{d = 2}^n g(d)S(\\frac nd)}{g(1)} \\nonumber \\end{align} æˆ‘ä»¬æŠŠå®ƒæ•´æˆäº†é€’å½’å½¢å¼ï¼Œåé¢å¯ä»¥ç”¨æ•°è®ºåˆ†å—ï¼Œåªè¦èƒ½æ‰¾åˆ°åˆé€‚çš„ ggg èƒ½å¿«é€Ÿæ±‚å‡º fâˆ—gf*gfâˆ—g å°±è¡Œè¾£ å°æ•°æ®æ¬§æ‹‰ç­›ï¼Œè®°å¿†åŒ–ä¸€ä¸‹ Code ç­› mumumu å’Œ varphivarphivarphi çš„ç‰ˆæœ¬123456789101112131415161718192021222324252627ll Sum_mu(ll n)&#123; if (n &lt;= maxn) return mu[n]; if (S_mu.count(n)) return S_mu[n]; ll l = 2, r, res = 1; while(l &lt;= n) &#123; r = n / (n / l); res -= 1LL*(r - l + 1) * Sum_mu(n/l); l = r + 1; &#125; return S_mu[n] = res;&#125;ll Sum_phi(ll n)&#123; if (n &lt;= maxn) return phi[n]; if (S_phi.count(n)) return S_phi[n]; ll l = 2, r, res = n * (n+1) /2; while (l &lt;= n) &#123; r = n / (n / l); res -= 1LL*(r - l + 1) * Sum_phi(n/l); l = r + 1; &#125; return S_phi[n] = res;&#125; CRT æ±‚è§£åŒä½™æ–¹ç¨‹ç»„ï¼Œé€‚ç”¨äºæ¨¡æ•°ä¸¤ä¸¤äº’è´¨çš„æƒ…å†µ {xâ‰¡a1 (mod p1)xâ‰¡a2 (mod p2)â‹®xâ‰¡an (mod pn)\\left\\{\\begin{matrix} x \\equiv a_1 \\; (mod \\ p_1)\\\\ x \\equiv a_2 \\; (mod \\ p_2)\\\\ \\vdots \\\\ x \\equiv a_n \\; (mod \\ p_n)\\\\ \\end{matrix}\\right. â©âªâªâªâªâ¨âªâªâªâªâ§â€‹xâ‰¡a1â€‹(mod p1â€‹)xâ‰¡a2â€‹(mod p2â€‹)â‹®xâ‰¡anâ€‹(mod pnâ€‹)â€‹ ExCRT","categories":[],"tags":[{"name":"æ•°å­¦ï¼Œæ•°è®º","slug":"æ•°å­¦ï¼Œæ•°è®º","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"}]},{"title":"emoji","slug":"emoji","date":"2022-09-21T13:53:27.000Z","updated":"2022-11-08T10:40:17.179Z","comments":true,"path":"2022/09/21/emoji/","link":"","permalink":"https://ve1bae.github.io/2022/09/21/emoji/","excerpt":"markdown emoji ğŸ˜ƒ å»ºè®®ç¼©æ”¾ 90%","text":"markdown emoji ğŸ˜ƒ å»ºè®®ç¼©æ”¾ 90% ç»å…¸é»„è„¸Human and humanities ç»å…¸é»„è„¸ ğŸ˜ƒ :) :smiley: ğŸ˜„ :smile: ğŸ˜š :kissing_closed_eyes: ğŸ˜ :heart_eyes: â˜ºï¸ :relaxed: ğŸ˜ :smirk: ğŸ˜˜ :kissing_heart: ğŸ˜Š :blush: ğŸ˜† :laughing: ğŸ˜³ :flushed: ğŸ˜ :stuck_out_tongue_closed_eyes: ğŸ˜† :satisfied: ğŸ˜¬ :grimacing: ğŸ˜‰ :wink: ğŸ˜œ :stuck_out_tongue_winking_eye: ğŸ˜Œ :relieved: ğŸ˜€ :grinning: ğŸ˜— :kissing: ğŸ˜™ :kissing_smiling_eyes: ğŸ˜¦ :frowning: ğŸ˜´ :sleeping: ğŸ˜Ÿ :worried: ğŸ˜› :stuck_out_tongue: ğŸ˜§ :anguished: ğŸ˜® :open_mouth: ğŸ˜ :grin: ğŸ˜‘ :expressionless: ğŸ˜¯ :hushed: ğŸ˜• :confused: ğŸ˜· :mask: ğŸ˜… :sweat_smile: ğŸ˜“ :sweat: ğŸ˜” :pensive: ğŸ˜© :weary: ğŸ˜¥ :disappointed_relieved: ğŸ˜‡ :innocent: ğŸ˜– :confounded: ğŸ˜‚ :joy: ğŸ˜ :disappointed: ğŸ˜£ :persevere: ğŸ˜¨ :fearful: ğŸ˜­ :sob: ğŸ˜« :tired_face: ğŸ˜² :astonished: ğŸ˜± :scream: ğŸ˜¢ :cry: ğŸ˜ :neutral_face: ğŸ˜µ :dizzy_face: ğŸ˜¤ :triumph: ğŸ˜ª :sleepy: ğŸ˜ :sunglasses: ğŸ˜’ :unamused: ğŸ˜¡ :rage: ğŸ‘¿ :imp: ğŸ˜ˆ :smiling_imp: ğŸ˜¶ :no_mouth: ğŸ˜  :angry: ğŸ˜‹ :yum: ğŸ¤’ :face_with_thermometer: ğŸ‘½ :alien: ğŸ˜° :cold_sweat: ğŸ¤• :face_with_head_bandage: Human ğŸ‘ :+1: ğŸ‘ :open_hands: ğŸ‘« :couple: ğŸ‘ :-1: ğŸ‘‡ :point_down: ğŸ’‘:couple_with_heart: ğŸ¤˜ :metal: â˜ï¸ :point_up: ğŸ–ï¸ :raised_hand_with_fingers_splayed: âœŒï¸ :v: ğŸ‘† :point_up_2: ğŸ‘©â€â¤ï¸â€ğŸ‘¨:couple_with_heart_woman_man: ğŸ–• :fu: ğŸ‘ˆ :point_left: ğŸ‘©â€â¤ï¸â€ğŸ‘©:couple_with_heart_woman_woman: âœŠ :fist: ğŸ‘‰ :point_right: ğŸ‘¨â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨:couplekiss_man_man: ğŸ‘Š :punch: ğŸ‘¼ :angel: ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨ :couplekiss_man_woman: âœ‹ :hand: ğŸ‘¨ :man: ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘© :couplekiss_man_woman: ğŸ‘‹ :wave: ğŸ‘¦ :boy: ğŸ‘¬ :two_men_holding_hands: ğŸ‘:clap: ğŸ‘­ :two_men_holding_hands: ğŸ™ :pray: ğŸ‘² :man_with_gua_pi_mao: ğŸ’ª :muscle: ğŸ’ :information_desk_person: ğŸ‘‚ :ear: ğŸ‘°â€â™€ï¸ :bride_with_veil: ğŸ‘ï¸ :eye: ğŸ™‹ :raising_hand: ğŸ‘€ :eyes: ğŸ‘· :construction_worker: ğŸ‘ƒ :nose: ğŸ‘³â€â™‚ï¸ :man_with_turban: ğŸ‘… :tongue: ğŸ‘„ :lips: ğŸ’‹ :kiss:","categories":[],"tags":[]},{"title":"Kruskalé‡æ„æ ‘","slug":"kruskalé‡æ„æ ‘","date":"2022-09-04T02:11:19.000Z","updated":"2022-11-08T10:40:31.949Z","comments":true,"path":"2022/09/04/kruskalé‡æ„æ ‘/","link":"","permalink":"https://ve1bae.github.io/2022/09/04/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/","excerpt":"æŒºæ²¡ç”¨çš„ğŸ˜°ï¼ŒæŒºæœ‰ç”¨çš„ğŸ˜ï¼ŒæŒºæ²¡ç”¨çš„ğŸ˜°ï¼ŒæŒºæœ‰ç”¨çš„ ğŸ˜ï¼ŒæŒºæ²¡ç”¨çš„ ğŸ˜°ï¼ŒæŒºæœ‰ğŸ˜­ğŸ˜­","text":"æŒºæ²¡ç”¨çš„ğŸ˜°ï¼ŒæŒºæœ‰ç”¨çš„ğŸ˜ï¼ŒæŒºæ²¡ç”¨çš„ğŸ˜°ï¼ŒæŒºæœ‰ç”¨çš„ ğŸ˜ï¼ŒæŒºæ²¡ç”¨çš„ ğŸ˜°ï¼ŒæŒºæœ‰ğŸ˜­ğŸ˜­ æ¦‚è¿° å›é¡¾æœ€å°ç”Ÿæˆæ ‘çš„ Kruskal ç®—æ³• æŠŠæ¯æ¡è¾¹æŒ‰è¾¹æƒæ’åºï¼Œç”¨å¹¶æŸ¥é›†ç»´æŠ¤è¿é€šæ€§ï¼Œç„¶åæŠŠè¾¹åŠ å…¥ç”Ÿæˆæ ‘ä¸­ï¼Œç›´åˆ°çˆğŸ˜­ä¹ n-1 æ¡è¾¹ æˆ‘ä»¬æ¯åŠ å…¥ä¸€æ¡è¾¹æ—¶ï¼Œå®é™…ä¸Šæ˜¯åˆå¹¶äº†ä¸¤ä¸ªå¹¶æŸ¥é›†ï¼Œæ¯æ¬¡åˆå¹¶æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹çš„ç‚¹æƒè®¾ä¸ºè¿™æ¡è¾¹çš„è¾¹æƒï¼Œå·¦å³å„¿å­è®¾ä¸ºä¸¤ä¸ªå¹¶æŸ¥é›†çš„ç¥–å®—ï¼Œæœ€åå¾—åˆ°äº†ä¸€ä¸ªæ°æœ‰ n ä¸ª å¶èŠ‚ç‚¹çš„äºŒå‰æ ‘ï¼Œå°±æ˜¯ kruskal é‡æ„æ ‘ è¿™å¼ å›¾çš„ Kruskalé‡æ„æ ‘é•¿è¿™æ · æ€§è´¨ kruskal é‡æ„æ ‘æœ‰ä¸€äº›å¾ˆæ–¹ä¾¿çš„æ€§è´¨ å¦‚æœæ˜¯æœ€å°ç”Ÿæˆæ ‘ï¼Œé‚£ä¹ˆé‡æ„æ ‘ä¸Šä¸¤ä¸ªèŠ‚ç‚¹çš„ LCA çš„ç‚¹æƒå°±æ˜¯åŸå›¾ä¸Šä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æ‰€æœ‰ç®€å•è·¯å¾„æœ€å¤§è¾¹æƒçš„æœ€å°å€¼ å¦‚æœæ˜¯æœ€å¤§ç”Ÿæˆæ ‘ï¼Œé‚£ä¹ˆé‡æ„æ ‘ä¸Šä¸¤ä¸ªèŠ‚ç‚¹çš„ LCA çš„ç‚¹æƒå°±æ˜¯åŸå›¾ä¸Šä¸¤ä¸ªèŠ‚ä¹‹é—´ç‚¹æ‰€æœ‰ç®€å•è·¯å¾„æœ€å°è¾¹æƒçš„æœ€å¤§å€¼ ä¾‹é¢˜ NOIPæé«˜2013 ç«è½¦è¿è¾“ ä¸€å¼ æ— å‘å›¾ nnn ä¸ªç‚¹ï¼Œ mmm æ¡è¾¹ï¼Œæ¯æ¡è¾¹éƒ½æœ‰ä¸€ä¸ªæœ€å¤§è½½é‡ï¼Œæ¯æ¬¡è¯¢é—®ä»ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘åˆ°è¾¾å¦ä¸€ä¸ªèŠ‚ç‚¹èƒ½æœ€å¤§æ‰¿å—çš„é‡é‡ çº¯çº¯æ»´æ¿å­ï¼Œå¯¹åŸå›¾å»ºæœ€å¤§ç”Ÿæˆæ ‘æ—¶å»ºé‡æ„æ ‘ï¼Œæ¯æ¬¡è¯¢é—®è¾“å‡º LCA å³å¯ Code LCA æˆ‘ç”¨çš„æ ‘å‰–ï¼Œéšä¾¿ç”¨ï¼Œéƒ½å¯ä»¥ç”¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;#include &lt;stdint.h&gt;#define MAXN 10005#define MAXM 50005#define ll long longusing namespace std;int n, m;struct edge&#123; int st, to, w;&#125;e[MAXM];bool cmp(edge a, edge b)&#123; return a.w &gt; b.w; &#125;int fa[MAXN &lt;&lt; 1];int find(int x)&#123; if(x == fa[x]) return x; else return fa[x] = find(fa[x]);&#125;vector &lt;int&gt; g[MAXN &lt;&lt; 1];int faz[MAXN &lt;&lt; 1];int dis[MAXN &lt;&lt; 1], vis[MAXN &lt;&lt; 1];int siz[MAXN &lt;&lt; 1], son[MAXN &lt;&lt; 1];int dep[MAXN &lt;&lt; 1], top[MAXN &lt;&lt; 1];void dfs1(int u, int dad)&#123; vis[u] = 1; siz[u] = 1; faz[u] = dad; dep[u] = dep[dad] + 1; for(int v : g[u]) &#123; if(v == dad) continue; dfs1(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if(son[u]) dfs2(son[u], tup); for(int v : g[u]) &#123; if(v == son[u] || v == faz[u]) continue; dfs2(v, v); &#125;&#125;int LCA(int u, int v)&#123; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) u = faz[top[u]]; else v = faz[top[v]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int cnt = n; for(int i = 1; i &lt;= n; i++) fa[i] = i; for(int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); e[i] = edge&#123;u, v, w&#125;; &#125; sort(e+1, e+1+m, cmp); for(int i = 1; i &lt;= m; i++) &#123; int fx = find(e[i].st), fy = find(e[i].to); if(fx == fy) continue; fa[fx] = fa[fy] = ++cnt; fa[cnt] = cnt; dis[cnt] = e[i].w; g[cnt].push_back(fx); g[cnt].push_back(fy); g[fx].push_back(cnt); g[fy].push_back(cnt); &#125; for(int i = 1; i &lt;= cnt; i++) &#123; if(!vis[i]) &#123; int u = find(i); dfs1(u, 0); dfs2(u, u); &#125; &#125; int q; scanf(&quot;%d&quot;, &amp;q); for(int i = 1; i &lt;= q; i++) &#123; int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); int fu = find(u), fv = find(v); if(fu != fv) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, dis[LCA(u, v)]); &#125; return 0;&#125; SCOI2013 æ‘©æ‰˜è½¦äº¤æ˜“ ä¸€å¼ æ— å‘å›¾ nnn ä¸ªåŸå¸‚ï¼Œmmm æ¡é“è·¯ï¼Œ ç°åœ¨ä½ æœ‰ä¸€äº›é»„é‡‘å’Œ nnn ä¸ªè®¢å• ï¼Œè¦ä¾æ¬¡å‰å¾€è¿™ nnn ä¸ªåŸå¸‚è¿›è¡Œ ä¹°å…¥/å–å‡º é»„é‡‘çš„äº¤æ˜“ï¼Œä½†æ˜¯æ¯æ¡é“è·¯å¯¹æºå¸¦çš„é»„é‡‘æ•°é‡æœ‰ä¸€å®šé™åˆ¶ï¼Œä¹Ÿå­˜åœ¨ä¸€äº›åŸå¸‚èƒ½å¤Ÿäº’ç›¸æŠµè¾¾è€Œä¸”æ²¡æœ‰é™åˆ¶ï¼Œè¯¢é—®æ¯ä¸ªå–å‡ºäº¤æ˜“æœ€å¤§çš„äº¤æ˜“é¢åº¦ è¿˜æ˜¯ç»å…¸ ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æ‰€æœ‰ç®€å•è·¯å¾„æœ€å°è¾¹æƒçš„æœ€å¤§å€¼ å¤„ç†åˆ°è¾¾è®¢å•æ‰€åœ¨åŸå¸‚æœ€å¤šä¿ç•™çš„é»„é‡‘ï¼Œå¯¹äºé‚£äº›ç‰¹æ®Šçš„èŠ‚ç‚¹ï¼Œæ–°å»ºä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼ŒæŠŠè¿™äº›èŠ‚ç‚¹å’Œè™šæ‹ŸèŠ‚ç‚¹éƒ½è¿ä¸€æ¡é™åˆ¶ç‰¹åˆ«å¤§çš„ä¾¿å°±è¡Œè¾£ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#define MAXN 500005#define MAXM 2000005#define ll long long#define cjb 1919810114514843using namespace std;int n, m, q, cnt;int a[MAXN];ll b[MAXN];struct edge&#123; int st, to; ll w;&#125;e[MAXM];bool cmp(edge a, edge b)&#123; return a.w &gt; b.w;&#125;int fa[MAXM];int find(int x)&#123; if(x == fa[x]) return x; return fa[x] = find(fa[x]);&#125;ll dis[MAXM];vector &lt;int&gt; g[MAXM];void klskr()&#123; sort(e + 1, e + 1 + m, cmp); for(int i = 1; i &lt;= m; i++) &#123; int u = e[i].st, v = e[i].to; int fu = find(u), fv = find(v); if(fu == fv) continue; cnt++; fa[cnt] = fa[fv] = fa[fu] = cnt; dis[cnt] = e[i].w; g[cnt].push_back(fv); g[cnt].push_back(fu); g[fv].push_back(cnt); g[fu].push_back(cnt); &#125; return;&#125;//æ ‘å‰–LCAint siz[MAXM], dep[MAXM], faz[MAXM];int top[MAXM], son[MAXM]; void dfs1(int u, int dad)&#123; siz[u] = 1; faz[u] = dad; dep[u] = dep[dad] + 1; for(int v : g[u]) &#123; if(v == dad) continue; dfs1(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if(son[u]) dfs2(son[u], tup); for(int v : g[u]) &#123; if(v == son[u] || v == faz[u]) continue; dfs2(v, v); &#125;&#125;int LCA(int u, int v)&#123; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) u = faz[top[u]]; else v = faz[top[v]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); cnt = n; for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); fa[i] = i; &#125; for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;b[i]); for(int i = 1; i &lt;= m; i++) &#123; int u, v; ll w; scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w); e[i] = edge&#123;u, v, w&#125;; &#125; //è™šæ‹ŸèŠ‚ç‚¹å¤„ç†ç‰¹æ®Šç‚¹ for(int i = 1; i &lt;= q; i++) &#123; int u; scanf(&quot;%d&quot;, &amp;u); e[++m] = edge&#123;u, n+1, cjb&#125;; &#125; ++cnt; klskr(); dfs1(cnt, 0); dfs2(cnt, cnt); ll now = b[a[1]]; //å½“å‰èº«ä¸Šæºå¸¦çš„é»„é‡‘ if(now &lt; 0) &#123; now = 0; printf(&quot;0\\n&quot;); &#125; for(int i = 2; i &lt;= n; i++) &#123; int u = a[i-1], v = a[i]; ll res = dis[LCA(u, v)]; if(b[v] &gt; 0)//ä¹°å…¥äº¤æ˜“ç›´æ¥å…¨æ‹¿ä¸‹ä¹°ï¼Œå¦‚æœåæ¥å‘ç°ä¹°å¤šäº†å°± æ™ºæ…§æ ¸å¿ƒ å‡è£…æ²¡ä¹° &#123; now = min(now, res) + b[v]; &#125; else &#123; res = min(now, res); ll fk = min(res, abs(b[v])); printf(&quot;%lld\\n&quot;, fk); now = res - min(res, abs(b[v])); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"https://ve1bae.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"9æœˆæ¯æ—¥æ€»ç»“","slug":"9æœˆæ¯æ—¥æ€»ç»“","date":"2022-08-31T00:04:27.000Z","updated":"2022-11-14T14:23:23.176Z","comments":true,"path":"2022/08/31/9æœˆæ¯æ—¥æ€»ç»“/","link":"","permalink":"https://ve1bae.github.io/2022/08/31/9%E6%9C%88%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/","excerpt":"æ—¥ã€…ç§ãŸã¡ãŒéã”ã—ã¦ã„ã‚‹æ—¥å¸¸ã¯ã€å®Ÿã¯ã€å¥‡è·¡ã®é€£ç¶šãªã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚ æˆ‘ä»¬æ‰€ç»å†çš„æ¯ä¸ªå¹³å‡¡çš„æ—¥å¸¸ï¼Œä¹Ÿè®¸å°±æ˜¯è¿ç»­å‘ç”Ÿçš„å¥‡è¿¹ã€‚ â€”â€”ã€Šæ—¥å¸¸ã€‹","text":"æ—¥ã€…ç§ãŸã¡ãŒéã”ã—ã¦ã„ã‚‹æ—¥å¸¸ã¯ã€å®Ÿã¯ã€å¥‡è·¡ã®é€£ç¶šãªã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚ æˆ‘ä»¬æ‰€ç»å†çš„æ¯ä¸ªå¹³å‡¡çš„æ—¥å¸¸ï¼Œä¹Ÿè®¸å°±æ˜¯è¿ç»­å‘ç”Ÿçš„å¥‡è¿¹ã€‚ â€”â€”ã€Šæ—¥å¸¸ã€‹ 8.31 T1 ç°æœ‰ nnn ä¸ªçº¢ç å­å’Œ An+BAn+BAn+B ä¸ªè“ç å­ï¼Œä»å·¦å¾€å³æ”¾ç å­ï¼Œä¿è¯ä»»ä½•æ—¶å€™å‡å¦‚æœ‰ xxx ä¸ªçº¢ç å­ï¼Œè“ç å­æ•°é‡ä¸è¶…è¿‡ Ax+BAx+BAx+B ä¸ªï¼Œé—®æœ‰å¤šå°‘ç§æ‘†æ”¾æ–¹æ³•èƒ½æ‘†å®Œæ‰€æœ‰çš„ç å­ ç»„åˆæ•°å­¦ï¼Œéš¾ç‚¹ä¸»è¦åœ¨äºä¸€ä¸ªé—®é¢˜çš„è½¬æ¢ï¼ŒæŠŠ ğŸ”´ çœ‹æˆæ¨ªåæ ‡ï¼ŒæŠŠ ğŸ”µ çœ‹æˆçºµåæ ‡ï¼Œé‚£ä¹ˆå°±æ˜¯ä» (0,0)(0,0)(0,0) èµ°åˆ° (n,An+B)(n, An+B)(n,An+B) ä¸”ä¸è¶Šè¿‡ y=Ax+By = Ax+By=Ax+B çš„æ–¹æ¡ˆæ•° ä»¤ m=An+Bm = An+Bm=An+B ï¼Œæ€»æ–¹æ¡ˆæ•° Cn+mnC_{n+m}^nCn+mnâ€‹ æšä¸¾èƒ½å¤Ÿå‘ç”Ÿè¶Šç•Œçš„æ¯ä¸ªä½ç½® å³ (p,Ap+B)(p, Ap+B)(p,Ap+B) èµ°åˆ° (p,Ap+B+1)(p, Ap+B+1)(p,Ap+B+1) Cmâˆ’Apâˆ’Bâˆ’1+nâˆ’pnâˆ’p=AÃ—Cmâˆ’Apâˆ’Bâˆ’1+nâˆ’pnâˆ’pâˆ’1C_{m - Ap -B - 1 + n - p}^{n - p} = A \\times C_{m - Ap - B - 1 + n - p}^{n - p - 1} Cmâˆ’Apâˆ’Bâˆ’1+nâˆ’pnâˆ’pâ€‹=AÃ—Cmâˆ’Apâˆ’Bâˆ’1+nâˆ’pnâˆ’pâˆ’1â€‹ ä¸­é—´æ¨å¯¼è¿‡ç¨‹å°±æ˜¯æŠŠç»„åˆæ•°æ‹†å¼€ï¼Œæä¸€ä¸ª mâˆ’Apâˆ’Bnâˆ’p\\frac{m-Ap-B}{n-p}nâˆ’pmâˆ’Apâˆ’Bâ€‹ å‡ºæ¥ é‚£ä¹ˆæœ€ç»ˆç­”æ¡ˆ Cn+mnâˆ’AÃ—Cn+mnâˆ’1C_{n+m}^{n} - A \\times C_{n+m}^{n-1}Cn+mnâ€‹âˆ’AÃ—Cn+mnâˆ’1â€‹ T2 æ¨¡æ‹Ÿï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œå¯ä»¥ç”¨mapå®ç°ï¼Œè´ªå¿ƒæ‰¾æœ€é•¿çš„å…³é”®å­—è¿˜æœ‰æ³¨æ„å…³é”®å­—çš„å¤„ç†é¡ºåºå°±è¡Œ T3 gcdå·ç§¯ 9.1 ç»™å®šä¸€äº›ç‚¹ï¼Œä»ä¸­é€‰å–è‹¥å¹²ä¸ªç‚¹ï¼Œä½¿è¿™äº›ç‚¹çš„å‡¸åŒ…ä¸Šçš„ç‚¹çš„ä¸ªæ•°å°½é‡å¤š T1 è™½ç„¶å‡¸åŒ…ï¼Œä½†æ˜¯DP é¢„å¤„ç†å‡ºæ¯ä¸ªå¯èƒ½æˆä¸ºå‡¸åŒ…ä¸Šçš„è¾¹ï¼Œæšä¸¾ç«¯ç‚¹ç”¨ atan2 ç®—ä¸€ä¸ªæè§’æ’åºå°±è¡Œï¼Œç„¶å f[i][j]f[i][j]f[i][j] è¡¨ç¤ºæœ€åä¸€ä¸ªç‚¹ä¸º jjj ä¸Šä¸€ä¸ªç‚¹ä¸º iii çš„ç‚¹æ•°æœ€å¤§å€¼ï¼Œå¼€ä¸€ä¸ªè¾…åŠ©æ•°ç»„ mxmxmx è®°å½•èµ°åˆ°æ¯ä¸ªç‚¹çš„ç‚¹æ•°çš„æœ€å¤§å€¼ï¼Œè®© f[i][j]f[i][j]f[i][j] ä» mx[i]mx[i]mx[i] è½¬ç§»ï¼Œå†è½¬ç§»åˆ° mx[j]mx[j]mx[j] å°±è¡Œè¾£ 123456789101112131415161718for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++) if(j != i) v[++cnt] = vec&#123;i, j, atan2(a[i].y - a[j].y, a[i].x - a[j].x)&#125;; &#125;sort(v + 1, v + 1 + cnt, cmp);for(int i = 1; i &lt;= n; i++)&#123; memset(mx, 0x8f, sizeof(mx)); mx[i] = 0; for(int j = 1; j &lt;= cnt; j++) &#123; int a = v[j].st, b = v[j].to; dp[a][b] = mx[a] + 1; mx[b] = max(mx[b], dp[a][b]); &#125; ans = max(ans, mx[i]);&#125; T2 æœ‰ä¸¤ä¸ªå›½å®¶ A å›½å’Œ B å›½ã€‚B å›½å¯¹ A å›½å‘èµ·äº†ä¾µç•¥ã€‚A å›½æœ‰ nnn ä¸ªåŸå¸‚ï¼Œé“è·¯ç½‘ç»œæ„æˆä¸€æ£µæ ‘ï¼Œé“è·¯å¯ä»¥åŒå‘é€šè¡Œã€‚é€šè¿‡ iii æ¡é“è·¯éœ€è¦ lil_iliâ€‹ ä¸ªå•ä½æ—¶é—´ã€‚ä¸å¦¨æŠŠ A å›½çš„åŸå¸‚ç¼–å·ä¸º 1âˆ¼n1 âˆ¼ n1âˆ¼nï¼Œå¹¶æŠŠ A å›½çš„é¦–éƒ½ç¼–å·ä¸º 111 å·ã€‚æˆ‘ä»¬å®šä¹‰ â€œè¾¹ç•ŒåŸå¸‚â€ ä¸ºï¼Œä»¥é¦–éƒ½ä¸ºæ ¹æ—¶ï¼Œä¸ºå¶å­èŠ‚ç‚¹çš„åŸå¸‚ã€‚B å›½ç›´æ¥å é¢†äº† A å›½çš„æ‰€æœ‰è¾¹ç•ŒåŸå¸‚ã€‚æˆ‘ä»¬è®°è¿™ä¸ªæ—¶åˆ»ä¸ºæ—¶åˆ» 000ã€‚æ¯ä¸ªè¢«å é¢†çš„åŸå¸‚æ¯ä¸ªå•ä½æ—¶é—´å¯ä»¥è®­ç»ƒå‡ºä¸€ä¸ªå£«å…µã€‚æ‰€æœ‰å£«å…µåªä¼šæœç€é¦–éƒ½çš„æ–¹å‘ç§»åŠ¨ã€‚åœ¨æ¯ä¸ªéè¾¹ç•ŒåŸå¸‚ iii ä¸­æœ‰ did_idiâ€‹ ä¸ªå«å…µã€‚å½“ B å›½çš„ä¸€åå£«å…µè¿›å…¥ä¸€ä¸ªåŸå¸‚æ—¶ï¼Œå«å…µæ•°é‡å°±ä¼šä¸”ä»…ä¼šå‡å°‘ 1 ã€‚è€Œå½“ä¸€ä¸ªåŸå¸‚ä¸­æ²¡æœ‰å«å…µäº†ä¹‹åï¼Œè¿™ä¸ªåŸå¸‚å°±è¢« B å›½å é¢†äº†ã€‚å£«å…µåˆ°è¾¾é¦–éƒ½å¹¶è™äº†ä¸€åé¦–éƒ½çš„å«å…µå°±æ¶ˆå¤±äº†ã€‚è¯·è®¡ç®—å‡º A å›½å…¨éƒ¨åŸå¸‚éƒ½è¢«å é¢†çš„æ—¶åˆ» å¯¹äºä¸€ä¸ªèŠ‚ç‚¹ uuu ï¼Œdisudis_udisuâ€‹ è¡¨ç¤ºå…¶é“æ ¹èŠ‚ç‚¹çš„è·ç¦»ï¼Œtut_utuâ€‹ è¡¨ç¤ºå®ƒçš„ ddd å˜æˆ 000 çš„æ—¶é—´ å®ƒåœ¨æ—¶åˆ» TTT çš„ ddd çš„å‡å°‘æ•°é‡æ˜¯ âˆ‘vâˆˆsubtree(u)maxTâˆ’tuâˆ’disv+disu,0 \\sum\\limits_{v \\in subtree(u)} max{T- t_u - dis_v + dis_u, 0} vâˆˆsubtree(u)âˆ‘â€‹maxTâˆ’tuâ€‹âˆ’disvâ€‹+disuâ€‹,0 çº¿æ®µæ ‘ç»´æŠ¤ tvâˆ’disyt_v - dis_ytvâ€‹âˆ’disyâ€‹ å‘ä¸Šåˆå¹¶å³å¯ 9.2 T1 æ¨¡æ‹Ÿï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œå”¯ä¸€æ³¨æ„ç‚¹å°±æ˜¯å¤„ç†è¾“å…¥å’Œå‚æ•°æ˜¯å¦é”™è¯¯ï¼Œå»ºè®® getline() ç›´æ¥è¯»å…¥ä¸€æ•´è¡Œï¼Œç„¶åå¤„ç†å‚æ•°ï¼Œä¸ç¬¦åˆèŒƒå›´ç›´æ¥ ERROR ï¼Œè¿˜æœ‰å°±æ˜¯åœ°å›¾ä¸‹æ ‡ä» 0 å¼€å§‹ï¼ŒèŠ±äº†åŠå¤©ææ‡‚æ ·ä¾‹ ğŸ˜… T2 è™å“¥ è¦å» ppp ä¸ªèœåº—ä¹°èœï¼ŒåŒæ—¶åœ°å›¾ä¸Šè¿˜æœ‰ä¸€äº›éšœç¢ï¼Œæœ€å°åŒ–è·¯ç¨‹çš„å‰æä¸‹ï¼Œåˆ€å“¥å¸Œæœ›èƒ½è¿ˆæ›´å®å¤§çš„æ­¥å­ï¼Œiii è§„æ¨¡çš„æ­¥ä¼ä¼šå æ® (2i+1)Ã—(2i+1)(2i+1) \\times (2i+1)(2i+1)Ã—(2i+1) ä¸ªæ ¼å­ é¦–å…ˆåœ¨æ¯ä¸ªä½ç½®çš„sizå¯ä»¥é¢„å¤„ç†å‡ºæ¥ï¼Œç„¶åå¯ä»¥å¯¹äºæ¯ä¸€ä¸ªğŸŒ¿ğŸªè·‘dijæ¥å¤„ç†è·¯ç¨‹å’Œè·¯å¾„siz åˆæ³¨æ„åˆ°èœå¸‚åœºçš„æ•°é‡å¾ˆå°‘ï¼Œå¯ä»¥çŠ¶å‹è¡¨ç¤ºæ¯ä¸€ä¸ªè¶…å¸‚å»æ²¡å»è¿‡ï¼Œå°DPå³å¯ 123456789101112131415161718192021222324252627282930313233void dij(int x, int y)&#123; priority_queue&lt;qnode&gt; q; memset(f[i][j][n][m], 0x3f, sizeof(f[i][j][n][m])); f[i][j][n][m][x][y] = node&#123;0, 0&#125;; q.emplace(qnode&#123;0, 0, x, y&#125;); while (q.size()) &#123; int dis = q.top().dis; int val = q.top().val; int x = q.top().x; int y = q.top().y; q.pop(); if(f[i][j][n][m][x][y].dis != dis || f[i][j][n][m][x][y].val != val) continue; for(int i = 0; i &lt; 4; i++) &#123; int qx = x + dx[i], qy = y + dy[i]; if(qx &lt; 1 || qx &gt; n || qy &lt; 1 || qy &gt; m || a[qx][qy]) continue; if(f[i][j][n][m][qx][qy].dis &gt; dis + 1 || (f[i][j][n][m][qx][qy].dis == dis + 1 &amp;&amp; f[i][j][n][m][qx][qy].val &lt; val + b[qx][qy])) &#123; f[i][j][n][m][qx][qy].dis = dis + 1; f[i][j][n][m][qx][qy].val = val + b[qx][qy]; q.emplace(qnode&#123;f[i][j][n][m][qx][qy].dis, f[i][j][n][m][qx][qy].val, qx, qy&#125;); &#125; &#125; &#125;&#125;for(i = 1; i &lt; 1 &lt;&lt; p; i++)for(j = 0; j &lt; p; j++) if((i &gt;&gt; j) &amp; 1) //iå¾—å»è¿‡for(k = 0; k &lt; p; k++) if(((i &gt;&gt; k) &amp; 1) &amp;&amp; k != j)//kå¾—å»è¿‡f[i][j] = min(f[i][j], f[i ^ (1 &lt;&lt; j)][k] + dis[k][j]); 9.3 æœ‰ nnn ä¸ªæ•°ï¼Œå¯ä»¥é€‰æ‹©æœ‰ kkk ä¸ªæ•°çš„ç»„åˆï¼Œå®ƒçš„è´¡çŒ®æ˜¯ç»„åˆä¸­æœ€å¤§çš„æ•°ï¼Œæ±‚æ‰€æœ‰ç»„åˆè´¡çŒ®ä¹‹å’Œ T1 è€ƒè™‘æ¯ä¸ªæ•°äº§ç”Ÿçš„è´¡çŒ®ï¼Œé‚£ä¹ˆå°±è¦æ±‚é€‰äº† kkk ä¸ªæ•°ï¼Œè€Œä¸”å½“å‰æ•°ä¸ºæœ€å¤§å€¼ï¼Œé‚£ä¹ˆå½“å‰æ•°ä¸€å®šè¦é€‰ï¼Œä¹‹åå†ä»å°äºç­‰ äºå½“å‰æ•°çš„æ•°ä¸­é€‰å‰©ä¸‹çš„ kâˆ’1k-1kâˆ’1 ä¸ªæ–¹æ¡ˆæ•° ansi=Ccnt[ai]kâˆ’1Ã—aians_i = C_{cnt[a_i]}^{k-1} \\times a_i ansiâ€‹=Ccnt[aiâ€‹]kâˆ’1â€‹Ã—aiâ€‹ ä½†æ˜¯æœ‰æ•°å€¼ç›¸åŒçš„æ•°æ—¶ä¼šç®—é‡æˆ–è€…å°‘ç®—ï¼Œæœ‰ä¸€ç§å·§å¦™çš„æ–¹æ³•å°±æ˜¯ç›´æ¥æ’åºï¼Œçœ‹ä»£ç ä½“ä¼š 123sort(a + 1, a + 1 + n);for (int i = 1; i &lt;= n; i++)ans = ans + C(i-1, k-1) * a[i]; T2 å°Q åœ¨ç‹¬æœ¨æ¡¥ä¸Šå½·å¾¨äº†ã€‚ä»–çŸ¥é“ï¼Œä»–åªå‰©ä¸‹äº† NNN ç§’çš„æ—¶é—´ï¼Œæ¯ä¸€ç§’çš„æ—¶é—´é‡Œï¼Œä»–ä¼šå‘å·¦æˆ–å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚NNN ç§’ä¹‹åï¼Œå°Q æ°å¥½åˆ°è¾¾å‡ºå‘å¤„ï¼Œä¸”ä»–æ¯ä¸¤æ¬¡ç»è¿‡æ­¤ä½ç½®çš„æ—¶é—´é—´éš”ä¸ä¼šè¶…è¿‡ MMM ç§’ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œè¿™ N ç§’çš„æ—¶&gt; é—´é‡Œï¼Œå°Q çš„è·¯çº¿æ€»å…±ä¼šæœ‰å¤šå°‘ç§å¯èƒ½çš„å½¢å¼ è€ƒè¯•æ—¶è¿é¢˜éƒ½æ²¡çœ‹æ‡‚ ğŸ˜­ æˆ‘ä»¬æŠŠç¬¬ä¸€æ¬¡åˆ°è¾¾æŸä¸ªåœ°ç‚¹çœ‹ä½œå·¦æ‹¬å·ï¼Œå›åˆ°è¿™ä¸ªåœ°ç‚¹çœ‹ä½œå³æ‹¬å·ï¼Œé‚£ä¹ˆåˆæ³•çš„ç§»åŠ¨å½¢æˆçš„æ‹¬å·åºåˆ—é•¿åº¦ â©½m\\leqslant mâ©½mï¼Œè€Œä¸”æ˜¯å¶æ•° äºæ˜¯æˆ‘ä»¬å¯ä»¥æŠŠé•¿åº¦ä¸º 2,4,â€¦m2, 4, \\dots m2,4,â€¦m å’Œæ‹¬å·åºåˆ—æœ‰å¤šå°‘ç§é¢„å¤„ç†å‡ºæ¥ æšä¸¾æ‹¬å·é•¿åº¦ f[i]=f[iâˆ’len]+a[len]f[i] = f[i-len] + a[len]f[i]=f[iâˆ’len]+a[len] å‘ç°æ˜¯ä¸€ä¸ªé€’æ¨è€Œä¸”çš„è¿‡ç¨‹ mmm ä¸å¤§ï¼Œäºæ˜¯è€ƒè™‘çŸ©é˜µåŠ é€Ÿ T3 åˆå§‹ä¸€ä¸ªæ•° BBBï¼Œåœ¨ nnn ç§’å†…æ¯ä¸€ç§’éƒ½ä¼šå¢åŠ  AAA æ±‚å„ä¸ªæ—¶åˆ»æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤º 111 çš„ä¸ªæ•°å’Œ ä¸éš¾å‘ç°ç´¯åŠ  AAA çš„è´¡çŒ®æ˜¯æœ‰å¾ªç¯èŠ‚çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ B+iAB + iAB+iA å’Œ B+2kaB + 2^kaB+2ka çš„ ç¬¬ kkk ä½æ˜¯ç›¸åŒæ»´ã€‚ æ‰€ä»¥å¯ä»¥è®¡ç®—å‡ºå‰ xxx é¡¹çš„äºŒçš„æ•´æ•°æ¬¡å¹‚ä½ä¸Šä¸€å…±æœ‰å‡ ä¸ª 111 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#define ll long longusing namespace std;ll A, B, N, ans;ll calc(ll x, ll bit) //å‰xé¡¹çš„ç¬¬bitä½ä¸Šæœ‰å‡ ä¸ª1&#123; ll ans = 0, f[i][j][n][m] = 0; for(ll i = 1; i &lt;= x; i++) &#123; ll to = B + A*i; //bit æ˜¯ä¸€ä¸ª2çš„æ•´æ¬¡å¹‚,(bit &gt;&gt; 1) çš„å½¢å¼æ˜¯100...000 ä¸ä¹‹æ¯”è¾ƒå°±èƒ½ç¡®å®šå½“å‰æœ€é«˜ä½æ˜¯1è¿˜æ˜¯0 if(to % bit &lt; (bit &gt;&gt; 1)) //å½“å‰æ˜¯ 0,åªèƒ½ä»ä¸Šä¸€ä½è¿›ä½ &#123; i = min(x, i + ((bit &gt;&gt; 1)-1 - to%bit)/A); &#125; else //å½“å‰ä½æ˜¯ 1,å¯ä»¥ä»å½“å‰ä½è¿›ä½ &#123; f[i][j][n][m] = min(x, i + (bit-1 - to%bit)/A); ans += f[i][j][n][m] - i + 1; i = f[i][j][n][m]; &#125; &#125; return ans;&#125;int main()&#123; int t; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;A, &amp;B, &amp;N); ll to = B + A*N; ans = 0; for(ll i = 2; i &lt; (to &lt;&lt; 1); i &lt;&lt;= 1) &#123; if(N / i) ans += 1LL*(N / i) * calc(i ,i); ans += calc(N % i, i); &#125; printf(&quot;%lld\\n&quot;, ans); &#125; return 0;&#125; 9.5 T1 AT4168 ç»™å®šä¸€ä¸ªé•¿ä¸º 2n2^n2n çš„åºåˆ— AAA ï¼Œç¼–å· 0â€¦2nâˆ’10 \\dots 2^n-10â€¦2nâˆ’1 ï¼Œå¯¹äºæ¯ä¸€ä¸ª k(0â‰¤kâ‰¤2n)k (0 \\leq k \\leq 2^n)k(0â‰¤kâ‰¤2n) ï¼Œæ±‚ max(Ai+Aj)(i or jâ©½k)max(A_i + A_j) (i \\; or \\; j \\leqslant k)max(Aiâ€‹+Ajâ€‹)(iorjâ©½k) è‚¯å®šæ˜¯åœ¨æ»¡è¶³æ¡ä»¶çš„æ•°é‡Œé€‰ä¸¤ä¸ªæœ€å¤§çš„ï¼Œé‚£ä¹ˆç»´æŠ¤ä¸€ä¸ªé›†åˆä¸­çš„æœ€å¤§å€¼å’Œæ¬¡å¤§å€¼ï¼Œæš´åŠ›æšä¸¾é›†åˆä¸­çš„æ•°è‚¯å®šä¸è¡Œï¼Œè€ƒè™‘å¦‚ä½•å¿«é€Ÿçš„æ±‚å‡ºç¬¦åˆæ¡ä»¶çš„æ•°çš„é›†åˆã€‚å¯¹äºä¸€ä¸ªæ•° kkk ï¼Œå®ƒçš„æ¯ä¸€ä¸ª lowbitlowbitlowbit å’Œ å®ƒå‡å»å®ƒçš„è¿™ä¸ª lowbitlowbitlowbit æˆ–èµ·æ¥ä¸€å®šå°äºç­‰äºå®ƒæ‰€ä»¥æšä¸¾ lowbitlowbitlowbit ç„¶åå†ä¸æ–­æ›´æ–°æœ€å¤§å€¼ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 300005using namespace std;int n, N;struct node &#123; int id, mx, cmx; &#125; a[MAXN];int ans [MAXN];node Max (node a, node b)&#123; node c; if (a.mx &gt; b.mx) &#123; c.mx = a.mx; c.id = a.id; c.cmx = max(a.cmx, b.mx); &#125; else if(b.mx &gt; a.mx) &#123; c.mx = b.mx; c.id = b.id; c.cmx = max(a.mx, b.cmx); &#125; else &#123; c.mx = a.mx; c.id = a.id; if (a.id == b.id) c.cmx = max(a.cmx, b.cmx); else c.cmx = b.mx; &#125; return c; &#125;#define lowbit(i) (i &amp; -i)int main()&#123; scanf(&quot;%d&quot;, &amp;n); N = 1 &lt;&lt; n; for (int i = 0; i &lt; N; i++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); a[i] = node &#123; i, x &#125;; &#125; for (int k = 1; k &lt; N; k++) &#123; int now = k; while(now) &#123; int i = lowbit(now); a[k] = Max(a[k], a[k - i]); now -= i; &#125; &#125; for (int i = 1; i &lt; N; i++) &#123; ans[i] = max(ans[i-1], a[i].mx + a[i].cmx); printf(&quot;%d\\n&quot;, ans[i]); &#125; return 0;&#125; T2 ç»™å®šä¸€ä¸ªæ•´æ•°æ•°åˆ— aaaï¼Œå®šä¹‰ f(a)=max1â©½iâ©½jâ©½n(ajâˆ’ai)f(a)=max_{1 \\leqslant i \\leqslant j \\leqslant n}(a_jâˆ’a_i)f(a)=max1â©½iâ©½jâ©½nâ€‹(ajâ€‹âˆ’aiâ€‹)ï¼Œä¿è¯ f(a)&gt;0f(a)&gt;0f(a)&gt;0ï¼Œä½ éœ€è¦æ±‚å‡ºè‡³å°‘éœ€è¦ä¿®æ”¹ aaa çš„å¤šå°‘ä¸ªä½ç½®æ‰èƒ½ä½¿ f(a)f(a)f(a) å˜å° é¦–å…ˆæŒ‰ç…§æœ€å°å€¼åˆ†æˆè‹¥å¹²æ®µï¼Œæ˜¾ç„¶æ¯æ®µä¹‹é—´äº’ä¸å½±å“ã€‚å¯¹äºæ¯ä¸€æ®µï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘æœ€å¤§å€¼å’Œæœ€å°å€¼ä¹‹å·®ã€‚å¦‚æœä¸¤ä¸ªæå€¼ä¹‹å·®ç­‰äº f(a)f(a)f(a)ï¼Œé‚£ä¹ˆå¿…é¡»ä»ä¸­é—´é€‰å®šä¸€ä¸ªä½ç½® iii ï¼Œå°† iii ä¹‹å‰çš„æœ€å°å€¼å’Œä¹‹åçš„æœ€å¤§å€¼åˆ å» Code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 1000005#define cjb 1145141919using namespace std;int n;int a[MAXN];int mx, mi, ans;int main()&#123; scanf(&quot;%d&quot;, &amp;n); mi = cjb; mx = -cjb; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); mx = max(mx, a[i] - mi); mi = min(mi, a[i]); &#125; int i, j, cnt = 0, len = 0; for (i = 1; i &lt;= n; i = j) &#123; len = cnt = 0; for (j = i; j &lt;= n &amp;&amp; a[i] &lt;= a[j]; j++) &#123; if (a[j] == a[i]) cnt++; else if (a[j] - a[i] == mx) &#123; cnt--; len = min(len, cnt); ans++; &#125; &#125; ans += len; &#125; printf(&quot;%d&quot;, ans); return 0;&#125; 9.6 T1 æœ‰ nnn ä¸ªæ•°ã€‚ä½ éœ€è¦æ‰¾å‡ºå®ƒä»¬çš„ä¸€ä¸ªæ’åˆ—ï¼Œæ»¡è¶³ mmm ä¸ªæ¡ä»¶ï¼Œæ¯ä¸ªæ¡ä»¶å½¢å¦‚ xax_axaâ€‹ â€‹å¿…é¡»åœ¨ xbx_bxbâ€‹ ä¹‹å‰â€‹ï¼Œæ±‚æ»¡è¶³æ¡ä»¶çš„æœ€å¤§å­æ®µå’Œ æœ€å°å‰²ã€‚ å¯¹æ¯ä¸€ä¸ªæ•°æ‹†ç‚¹ å¦‚æœ aia_iaiâ€‹ ä¸ºæ­£æ•°ï¼Œé‚£ä¹ˆ è¶…ğŸ”æºç‚¹è¿å‘å…¥ç‚¹ï¼Œå‡ºç‚¹è¿å‘è¶…ğŸ”æ±‡ç‚¹ æµé‡ä¸º aia_iaiâ€‹ çš„è¾¹ï¼Œ å¦‚æœè¿™æ¡è¾¹è¢«å‰²äº†ï¼Œè¯´æ˜è¿™ä¸ªæ•°è¢«æ”¾åˆ°äº†é€‰ä¸­çš„å­åºåˆ—çš„å‰è¾¹æˆ–åè¾¹ å¦‚æœ aia_iaiâ€‹ ä¸ºè´Ÿæ•°ï¼Œé‚£ä¹ˆåœ¨å…¥ç‚¹å’Œå‡ºç‚¹é—´è¿ä¸€æ¡æµé‡ä¸º âˆ£aiâˆ£\\left\\vert a_i \\right\\vertâˆ£aiâ€‹âˆ£ çš„è¾¹ï¼Œå¦‚æœè¿™æ¡è¾¹è¢«å‰²äº†ï¼Œè¯´æ˜è¿™ä¸ªæ•°è¢«åŠ åˆ°äº†å­åºåˆ—é‡Œ å¯¹äºæ¯ä¸ªé™åˆ¶ï¼Œå°±åˆ†åˆ«æŠŠä¸¤ä¸ªç‚¹çš„å…¥ç‚¹å’Œå‡ºç‚¹è¿èµ·æ¥ï¼Œæµé‡è¶…ğŸ”å¤§ï¼Œè¿™æ ·é™åˆ¶ä¸€å®šæ»¡è¶³ï¼Œå› ä¸ºä¸ä¼šè¢«å‰² ç­”æ¡ˆå°±æ˜¯ æ­£æ•°å’Œ-æœ€å°å‰² T2 CF1616H ç»™å®šä¸€ä¸ªæ•°åˆ—ï¼Œå’Œä¸€ä¸ªæ•° xxx ï¼Œæ±‚æœ‰å¤šå°‘ä¸ªæ•°åˆ—çš„å­é›†ï¼Œæ»¡è¶³é›†åˆä¸­çš„æ•°ä¸¤ä¸¤å¼‚æˆ–éƒ½ä¸å¤§äº xxx çœ‹åˆ°å¼‚æˆ–ï¼Œè€ƒè™‘å»º01Trieï¼Œå…ˆæŠŠé›†åˆä¸­çš„æ•°æ’å…¥Trieä¸­ï¼Œå› ä¸ºç»Ÿè®¡ä¸ªæ•°ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹è¢«å‡ ä¸ªé›†åˆä¸­çš„æ•°ç”¨åˆ° ç„¶åè€ƒè™‘å¦‚ä½•æ»¡è¶³é™åˆ¶ï¼Œç»å…¸ä»é«˜ä½å‘åœ°ä½å¼€å§‹æ’ï¼Œç„¶åä»é«˜ä½å‘ç¬¬ä½éå†ï¼Œåˆ†æƒ…å†µè®¨è®º å¦‚æœå½“å‰éå†çš„ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯åŒä¸€ä¸ªèŠ‚ç‚¹ï¼š å¦‚æœ xxx åœ¨è¿™ä¸€ä½ä¸Šæ˜¯ 111 ï¼Œé‚£ä¹ˆåŒæ—¶é€’å½’å·¦å­æ ‘å’Œå³å­æ ‘ å¦‚æœ xxx åœ¨è¿™ä¸€ä½ä¸Šæ˜¯ 000 ï¼Œé‚£ä¹ˆåˆ†åˆ«é€’å½’å·¦å­æ ‘å’Œå³å­æ ‘ å¦‚æœå½“å‰éå†çš„ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯ä¸åŒèŠ‚ç‚¹ï¼š å¦‚æœ xxx åœ¨è¿™ä¸€ä½ä¸Šæ˜¯ 111 ï¼Œé‚£ä¹ˆé€’å½’ä¸¤ä¸ªèŠ‚ç‚¹çš„ä¸åŒå­æ ‘ï¼Œä¸¤ç§æƒ…å†µçš„ç­”æ¡ˆä¹˜èµ·æ¥ å¦‚æœ xxx åœ¨è¿™ä¸€ä½ä¸Šæ˜¯ 000 ï¼Œé‚£ä¹ˆé€’å½’ç›¸åŒå­æ ‘ï¼Œå†ç»Ÿè®¡ä¸€ä¸‹å•ç‹¬åœ¨ä¸€æ£µå­æ ‘é‡Œçš„ç­”æ¡ˆè¿”å› è¿˜æœ‰å°±æ˜¯æ³¨æ„ä¸€äº›å°ç»†èŠ‚ï¼Œæ¯”å¦‚ç©ºé›†é‡å¤è®¡ç®—å‡ä¸€çš„é—®é¢˜ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#define mbit 30#define MAXN 150005#define mod 998244353#define ll long longusing namespace std;int n, m;ll pow2[MAXN];namespace Trie&#123; int tot = 1; int siz[MAXN * mbit]; int ch[MAXN * mbit][2]; #define ls(i) (ch[i][0]) #define rs(i) (ch[i][1]) void insert(int x) &#123; int u = 1; siz[u]++; for (int i = mbit; i &gt;= 0; i--) &#123; int bit = (x &gt;&gt; i) &amp; 1; if(!ch[u][bit]) ch[u][bit] = ++tot; u = ch[u][bit]; siz[u]++; &#125; &#125;&#125;using namespace Trie;ll dfs(int u1, int u2, int d)&#123; int bit = (m &gt;&gt; d) &amp; 1; if(!u1 || !u2) return pow2[siz[u1 + u2]]; if(u1 == u2) &#123; if (d &lt; 0) return pow2[siz[u1]]; if (bit) return dfs(ls(u1), rs(u1), d-1) %mod; else return (dfs(ls(u1), ls(u1), d-1) + dfs(rs(u1), rs(u1), d-1) -1 + mod)%mod; &#125; else &#123; if (d &lt; 0) return pow2[siz[u1] + siz[u2]]; if (bit) return (dfs(ls(u1), rs(u2), d-1) * dfs(rs(u1), ls(u2) , d-1)) %mod; else &#123; ll ans = (dfs(ls(u1), ls(u2), d-1) + dfs(rs(u1), rs(u2), d-1) -1 + mod)%mod; ans = (ans + (pow2[siz[ls(u1)]]-1 +mod) * (pow2[siz[rs(u1)]] - 1 + mod)%mod)%mod; ans = (ans + (pow2[siz[ls(u2)]]-1 +mod) * (pow2[siz[rs(u2)]] - 1 + mod)%mod)%mod; return ans; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); pow2[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); insert(x); pow2[i] = pow2[i-1] * 2LL %mod; &#125; printf(&quot;%lld&quot;, (dfs(1, 1, mbit)-1 +mod) %mod); return 0;&#125; 9.7 T1 ğŸ¯å“¥ä»ä¸œç™¾æ¥åˆ°å¹¿å·ï¼Œè¦çœ‹å¹¿å·å¡”ï¼Œåˆ€å“¥é€‰æ‹©åèˆ¹å»ï¼Œå¯æƒœå µèˆ¹äº†ï¼Œè€Œä¸”ğŸ”ªå“¥æ°å¥½åœ¨ç¦»å¡”æœ€è¿œçš„èˆ¹ä¸Šï¼Œæ¯è‰˜èˆ¹çš„èˆ¹å¤´è·ç¦»å¡”çš„è·ç¦»ä¸º xix_ixiâ€‹ï¼Œèˆ¹é•¿ä¸º lil_iliâ€‹ ï¼Œé€Ÿåº¦ä¸º viv_iviâ€‹ ï¼Œè®¡ç®—ğŸ¯å“¥æ¥å¹¿å·å¡”éœ€è¦å¤šé•¿æ—¶é—´ ä¸€è‰˜èˆ¹çš„èƒ½å¤Ÿèˆ¹å¤´èƒ½å¤Ÿç¢°åˆ°å¹¿å·å¡”ï¼Œé‚£ä¹ˆå®ƒå‰é¢çš„èˆ¹çš„èˆ¹å°¾å·²ç»ç»è¿‡äº†å¡”ï¼Œæ‰€ä»¥æ¯è‰˜èˆ¹ä¸€å…±è¦èµ°çš„è·¯ç¨‹å®é™…ä¸Šæ˜¯å®ƒçš„èˆ¹å¤´åˆ°å¡”çš„è·ç¦»åŠ ä¸Šå®ƒå‰é¢æ‰€æœ‰èˆ¹çš„èˆ¹é•¿ï¼ˆé™¤äº†ğŸ¯æ‰€åœ¨çš„ç¬¬ä¸€è‰˜èˆ¹ï¼‰ï¼Œåé¢çš„èˆ¹ä¼šæŒ¡åˆ°å‰é¢çš„èˆ¹ï¼Œæ‰€ä»¥å–max 1234for (int i = 2; i &lt;= n; i++)sum[i] = sum[i-1] + a[i];for (int i = 1; i &lt;= n; i++)ans = max(ans, (x[i] + sum[i])/v[i]); T2 ä¸€å¼ æ— å‘å›¾ nnn ä¸ªç‚¹ï¼Œ mmm æ¡è¾¹ï¼Œè¯¢é—®èƒ½ä¸èƒ½æŠŠæ¯æ¡è·¯éƒ½èµ°ä¸€éä¸”åªèµ°ä¸€è¾¹ï¼Œå¦‚æœå®åœ¨ä¸èƒ½çš„è¯ä½¿ç”¨ä¼ é€ï¼Œå¯ä»¥ä¼ é€åˆ°ä»»æ„åŸå¸‚ï¼Œè¯¢é—®æœ€å°‘ä¼ é€å‡ æ¬¡ï¼Œè¾“å‡ºè·¯å¾„ ä¸€çœ¼é¢˜ç›®åº”è¯¥æ˜¯æ¬§æ‹‰è·¯å¾„ï¼Œå…ˆå¯¹æ¯ä¸ªè¿é€šå—å¤„ç†å‡ºåº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹ï¼Œä½¿ç”¨ä¼ é€æŠŠä»–ä»¬ä¸¤ä¸¤è¿è¾¹ï¼Œåœ¨é€‰å‡ºæ¯ä¸ªè¿é€šå—çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼ŒæŠŠè¿é€šå—ä¹‹é—´è¿è¾¹ã€‚æœ€ådfsè¾“å‡ºè·¯å¾„ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990void bfs(int st)&#123; queue &lt;int&gt; q; vector &lt;int&gt; p; q.push(st); vis[st] = 1; while(q.size()) &#123; int u = q.front(); q.pop(); if(d[u] &amp; 1) p.push_back(u); for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (!vis[v]) &#123; vis[v] = 1; q.push(v); &#125; &#125; &#125; for (int i = 2; i &lt; p.size(); i += 2) //å¥‡åº¦æ•°ç‚¹ä¸¤ä¸¤è¿è¾¹å°±èƒ½ç›¸äº’æŠµè¾¾ &#123; adde(p[i], p[i+1]); adde(p[i+1], p[i]); tot++; &#125; //è¿é€šå—å†…èµ·ç‚¹ç»ˆç‚¹ if(p.size()) s = p[0], t = p[1]; //æ²¡æœ‰å¥‡åº¦æ•°ç‚¹è¯´æ˜è¿™ä¸ªè¿é€šå—æ˜¯æ¬§æ‹‰å›è·¯ï¼Œä»»é€‰ä¸€ä¸ªç‚¹å°±è¡Œ else s = t = st;&#125;void print()&#123; printf(&quot;%d &quot;, sta.size()); while(sta.size()) &#123; printf(&quot;%d &quot;, sta.top()); sta.pop(); &#125; ENDL;&#125;void dfs(int u)&#123; for (int i = head[u]; i; i = e[i].nxt) if (!vis[i]) &#123; vis[i] = vis[i ^ 1] = 1; head[u] = i; int v = e[i].to; dfs(v); if(i/2 &gt; m) print(); //é¢˜ç›®è¦æ±‚ï¼Œä½¿ç”¨ä¼ é€æ¢ä¸ªè¡Œ else sta.push(i &amp; 1 ? -i/2 : i/2);//é¢˜ç›®è¦æ±‚ï¼Œæ­£ç€èµ°æ­£ï¼Œåç€èµ°è´Ÿ &#125;&#125;void solve()&#123; for (int i = 1; i &lt;= n; i++) if(head[i]) &#123; if(!vis[i]) &#123; tot++; bfs(i); if(alls) &#123; adde(alls, s); adde(s, alls); allt = t; &#125; else alls = s, allt = t;//å¤„ç†æ•´å¼ å›¾çš„èµ·ç‚¹ç»ˆç‚¹ &#125; &#125; printf(&quot;%d\\n&quot;, tot-1); memset(vis, 0, sizeof(vis)); dfs(alls); print();&#125;int main()&#123; freopen(&quot;travelling.in&quot;, &quot;r&quot;, stdin); freopen(&quot;travelling.out&quot;, &quot;w&quot;, stdout); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; clannad(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); adde(x, y); adde(y, x); d[x]++; d[y]++; &#125; solve(); &#125;&#125; T3 8Ã—88 \\times 88Ã—8 ç½‘æ ¼å›¾ï¼Œä¸Šé¢æœ‰ä¸€äº›ç‚¹éœ€è¦å»ºç«‹åŸºç«™ï¼Œæ¯å»ºå¥½ä¸€ä¸ªåŸºç«™éœ€è¦å’Œå·²ç»å»ºå¥½çš„åŸºç«™è°ƒè¯•ä¸€æ¬¡ï¼Œè‹¥ä¸¤ä¸ªåŸºç«™çš„åæ ‡åˆ†åˆ«ä¸º (x1,y1)(x1,y1)(x1,y1) å’Œ (x2,y2)(x2,y2)(x2,y2) è°ƒè¯•çš„æ—¶é—´æ˜¯ max(âˆ£x1âˆ’x2âˆ£,âˆ£y1âˆ’y2âˆ£)max(\\left\\vert x_1 - x_2 \\right\\vert,\\left\\vert y_1 - y_2 \\right\\vert)max(âˆ£x1â€‹âˆ’x2â€‹âˆ£,âˆ£y1â€‹âˆ’y2â€‹âˆ£)ï¼Œå»ºç«‹è¿™ä¸ªåŸºç«™æ€»çš„è°ƒè¯•æ—¶é—´æ˜¯å’Œè¿™äº›åŸºç«™è°ƒè¯•æ—¶é—´çš„æœ€å¤§å€¼ï¼Œç¡®å®šä¸€ä¸ªé¡ºåºï¼Œä½¿å¾—æ€»å…±çš„è°ƒè¯•æ—¶é—´æœ€å° å¦‚æœæ˜¯ä¸€ä¸ªåºåˆ—ï¼Œé‚£ä¹ˆå…ˆä¸­é—´åä¸¤è¾¹ï¼Œçš„è°ƒè¯•æ—¶é—´æ˜¯æœ€å°çš„ã€‚ç½‘æ ¼å›¾ä¹Ÿæ˜¯è¿™æ ·ï¼Œå…ˆä¸­é—´ï¼Œåå››å‘¨ã€‚ä»¥è¿™ä¸ªä¸ºåŸºç¡€è¿›è¡ŒDP 123456789101112131415161718192021222324//è®¡ç®—åŒºåŸŸå†…è´¡çŒ®int ask(int i, int j, int n, int m, int s1, int t1, int s2, int t2)&#123; int tmp = 0; for(int p = s1; p &lt;= s2; p++) for(int q = t1; q &lt;= t2; q++) &#123; if(id[p][q] == 1) tmp += max( max(Abs((p-i)), Abs((p-n))), max(Abs((q-j)), Abs((q-m)))); &#125; return tmp;&#125;int dp(int i, int j, int n, int m)&#123; if(i &gt; n || j &gt; m) return 0; if(f[i][j][n][m] &gt; -1) return f[i][j][n][m]; //è®°å¿†åŒ– //å››ä¸ªæ–¹å‘ï¼Œæ‰©å±•ä¸€è¡Œ/åˆ— f[i][j][n][m] = min(f[i][j][n][m], ask(i, j, n, m, i, j, i, m) + dp(i+1, j, n, m)); f[i][j][n][m] = min(f[i][j][n][m], ask(i, j, n, m, i, j, n, j) + dp(i, j+1, n, m)); f[i][j][n][m] = min(f[i][j][n][m], ask(i, j, n, m, n, j, n, m) + dp(i, j, n-1, m)); f[i][j][n][m] = min(f[i][j][n][m], ask(i, j, n, m, i, m, n ,m) + dp(i, j, n, m-1)); return f[i][j][n][m];&#125; 9.8 T1 ARC101C ç»™å®šä¸€ä¸ªå¤§å°ä¸º nnn çš„æ ‘ï¼Œä¿è¯ nnn ä¸ºå¶æ•°ä¸”å°äº 50005000ã€‚æ‚¨éœ€è¦ç»™æ ‘ä¸Šçš„ç‚¹ä¸¤ä¸¤é…å¯¹ï¼Œå¯¹äºä¸€ç»„å¯¹å­ (u,v)(u,v)(u,v) ï¼Œåœ¨æ ‘ä¸Šå°† uâ†’vu \\to vuâ†’v çš„è·¯å¾„æŸ“è‰²ï¼Œå®šä¹‰ä¸€ä¸ªé…å¯¹æ–¹æ¡ˆåˆå½“ä¸”ä»…å½“æ‰€æœ‰è¾¹éƒ½æœ‰é¢œè‰²ï¼Œæ±‚å’Œæ³•æŸ“è‰²çš„æ–¹æ¡ˆ å…ˆé¢„å¤„ç†é™¤ iii ä¸ªç‚¹ä»»æ„é…å¯¹çš„æ–¹æ¡ˆæ•° gig_igiâ€‹ ï¼Œgi=âˆiâˆ’2k+1nig_i= \\prod\\limits_{i - 2k+1}^n igiâ€‹=iâˆ’2k+1âˆnâ€‹i for (int i = 2; i &lt;= n; i++) g[i] = g[i-2] *(i-1) %mod; f(s)f(s)f(s) è¡¨ç¤ºè¾¹é›† SSS å†…çš„æ–¹æ¡ˆæ•°ï¼Œå…¨é›†ä¸º EEE ï¼Œå®¹æ–¥ä¸€ä¸‹ ans=âˆ‘SâŠ†E(âˆ’1)âˆ£Sâˆ£f(S)ans = \\sum\\limits_{S \\subseteq E} (-1)^{\\vert S \\vert} f(S) ans=SâŠ†Eâˆ‘â€‹(âˆ’1)âˆ£Sâˆ£f(S) ç„¶åè€ƒè™‘dpï¼Œdp(i,j)dp(i,j)dp(i,j) è¡¨ç¤ºä»¥ iii ä¸ºæ ¹çš„å­æ ‘å†…ï¼Œiii æ‰€åœ¨çš„è¿é€šå—å¤§å°ä¸º jjj çš„ç­”æ¡ˆï¼Œæšä¸¾å­æ ‘ä¹˜æ³•åŸç†è½¬ç§» 12345678910111213141516171819void dfs(int u, int fa)&#123; siz[u] = 1; dp[u][1] = 1; for (int v : e[u]) &#123; if (v == fa) continue; dfs(v, u); for (int i = 1; i &lt;= siz[u] + siz[v]; i++) f[i] = 0; for (int i = 1; i &lt;= siz[u]; i++) for (int j = 1; j &lt;= siz[v]; j++) &#123; f[i] = (f[i] - dp[u][i]*dp[v][j]%mod * g[j]%mod + mod) %mod; f[i+j] = (f[i+j] + dp[u][i] * dp[v][j]%mod)%mod; &#125; siz[u] += siz[v]; for (int i = 1; i &lt;= siz[u]; i++) dp[u][i] = f[i]; &#125;&#125; T2 ARC088C ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ¯æ¬¡å¯ä»¥äº¤æ¢ä»»æ„ç›¸é‚»çš„ä¸¤ä¸ªå­—ç¬¦ï¼Œè¯¢é—®æœ€å°‘äº¤æ¢å‡ æ¬¡å¯ä»¥å˜æˆä¸€ä¸ªå›æ–‡ä¸²ï¼Œæ— è§£è¾“å‡º -1 å¦‚æœé•¿åº¦ä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆæœ‰ä¸€ä¸ªå­—ç¬¦å‡ºç°æ¬¡æ•°æ˜¯å¥‡æ•°ï¼Œå¦‚æœé•¿åº¦ä¸ºå¶æ•°ï¼Œé‚£ä¹ˆæ²¡æœ‰å­—ç¬¦å‡ºç°æ¬¡æ•°ä¸ºå¥‡æ•°ï¼Œå¦åˆ™æ— è§£ ä¾æ¬¡æ‰«æå­—ç¬¦ä¸²ï¼Œå¯»æ‰¾æœ€é åçš„ç›¸åŒå­—ç¬¦ä¸å®ƒåŒ¹é…ï¼ŒæŒ‰è¿™ä¸ªç­–ç•¥å¤„ç†å‡ºæ¯ä¸ªå­—ç¬¦åœ¨å›æ–‡ä¸²ä¸­çš„ä½ç½®ï¼Œæ±‚é€†åºå¯¹å³å¯ å¯ä»¥é¢„å¤„ç†é™¤æ¯ä¸ªå­—ç¬¦æ‰€æœ‰çš„å‡ºç°ä½ç½® 12345678910111213141516171819202122232425262728293031323334for (int i = 1; i &lt;= n; i++)&#123; q[s[i] - &#x27;a&#x27;].push_back(i); cnt[s[i]- &#x27;a&#x27;]++; &#125;for (int i = 0; i &lt; 26; i++) if(cnt[i] &amp; 1)ji++;if(n % 2 == 0)&#123; if(ji) printf(&quot;-1&quot;); return 0;&#125;else if(ji &gt; 1) printf(&quot;-1&quot;); return 0;//æˆ‘è¿™é‡Œä½¿ç”¨äº†åŒç«¯é˜Ÿåˆ—ç»´æŠ¤for (int i = 1; i &lt;= n; i++) if(!pos[i])&#123; int x = q[s[i] - &#x27;a&#x27;].front(); int y = q[s[i] - &#x27;a&#x27;].back(); if(x == y) pos[x] = (n+1)/2; else &#123; q[s[i] - &#x27;a&#x27;].pop_back(); q[s[i] - &#x27;a&#x27;].pop_front(); pos[x] = ++tot; pos[y] = n-tot+1; &#125;&#125;//æ ‘çŠ¶æ•°ç»„æ±‚é€†åºå¯¹for (int i = 1; i &lt;= n; i++)&#123; add(pos[i], 1); ans += i - query(pos[i]);&#125;printf(&quot;%lld&quot;, ans); 9.9 T1 CF1422F ç»™å®šä¸€ä¸ªåºåˆ—ï¼Œæ±‚åŒºé—´ lcmlcmlcm ã€‚nâ©½100000n \\leqslant 100000nâ©½100000 ï¼Œaiâ©½2000000a_i \\leqslant 2000000aiâ€‹â©½2000000 å…ˆè½ä¸€ä¸ªçº¿æ®µæ ‘ä¸Šå»å‘ç°ä¸å¯¹ï¼Œç„¶åè€ƒè™‘å¯¹æ¯ä¸€ä¸ªæ•°å”¯ä¸€åˆ†è§£ï¼Œå®é™…ä¸ŠæŠŠé—®é¢˜è½¬åŒ–ä¸ºäº†ç´ æ•°ä¸ªæ•°çš„æœ€å¤§å€¼é—®é¢˜ï¼Œ äººç±»æ™ºæ…§æ ¹å·åˆ†æ²» å°äºç­‰äº a\\sqrt{a}aâ€‹ çš„ è´¨æ•°åªæœ‰ 868686 ä¸ªï¼ŒSTè¡¨å¤„ç† å¤§äº a\\sqrt{a}aâ€‹ çš„é—®é¢˜è½¬åŒ–ä¸ºåŒºé—´å‡ºç°è¿‡çš„æ•°çš„ä¹˜ç§¯ï¼Œè€Œä¸”å¯ä»¥å‘ç° aaa åªå«æœ‰ä¸€ä¸ªè¿™æ ·çš„è´¨å› æ•°ï¼Œç»´æŠ¤ preipre_ipreiâ€‹ è¡¨ç¤º iii ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œç”¨ä¸€ä¸ªå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æ±‚ä¹˜ç§¯çš„ä¸»å¸­æ•°ç»´æŠ¤ T2 CF741D ä¸€ä¸ª 111 ä¸ºæ ¹èŠ‚ç‚¹çš„æ•°ï¼Œæ¯æ¡è¾¹ä¸Šæœ‰ä¸€ä¸ªå­—ç¬¦ a va~va v 22ç§ï¼Œè¯¢é—®æ‰€æœ‰å­æ ‘ä¸­æœ€é•¿çš„ç®€å•è·¯å¾„ä½¿å¾—è·¯å¾„ä¸Šçš„å­—æ¯é‡æ’åå¯ä»¥å˜æˆå›æ–‡ä¸² çœ‹åˆ°å¯¹äºå­æ ‘çš„è¯¢é—®ï¼Œè€ƒè™‘ dsu on tree ã€‚ä¸€ä¸ªå­—ç¬¦ä¸²èƒ½é‡æ’æˆå›æ–‡ä¸²ï¼Œé‚£ä¹ˆå‡ºç°å¥‡æ•°æ¬¡çš„å­—ç¬¦æœ€å¤šæœ‰ä¸€ä¸ªã€‚æ€è€ƒåªæœ‰22ä¸ªå­—ç¬¦çš„æ·±æ„ï¼Œæˆ‘ä»¬å¯ä»¥çŠ¶å‹æ¯ä¸€ç§å­—ç¬¦å‡ºç°çš„æ¬¡æ•°ä¸ºå¥‡æ•°è¿˜æ˜¯å¶æ•°ï¼Œç»†èŠ‚çœ‹ä»£ç  Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//cnt[i] è¡¨ç¤ºå­æ ‘å†…å­—ç¬¦çŠ¶æ€ä¸º i çš„æœ€å¤§æ·±åº¦void dfs(int u, int fa)&#123; siz[u] = 1; dep[u] = dep[fa] + 1; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; //é¢„å¤„ç†é™¤æ¯ä¸ªèŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„å­—ç¬¦çŠ¶æ€ num[v] = num[u] ^ (1 &lt;&lt; e[i].dis); dfs(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;int now;void add1(int u)&#123; // çœ‹çœ‹æœ‰æ²¡æœ‰å‡ºç°çŠ¶æ€å’Œå½“å‰ä¸€æ ·èŠ‚ç‚¹çš„ï¼Œå¯ä»¥åˆå¹¶æˆä¸€ä¸ªå¶å›æ–‡ä¸² ans[now] = max(ans[now], dep[u] + cnt[num[u]]); // æšä¸¾çŠ¶æ€ï¼Œåˆå¹¶å¥‡å›é—®ä¸² for (int i = 0; i &lt; 22; i++) ans[now] = max(ans[now], dep[u] + cnt[(1 &lt;&lt; i) ^ num[u]]);&#125;// ä¸èƒ½è‡ªå·±å’Œè‡ªå·±åˆå¹¶ï¼Œæ‰€ä»¥ä¸èƒ½å†™åœ¨ä¸€ä¸ªå‡½æ•°é‡Œvoid add2(int u)&#123; // ç”¨å½“å‰èŠ‚ç‚¹æ›´æ–°å½“å‰çŠ¶æ€ cnt[num[u]] = max(cnt[num[u]], dep[u]);&#125;// åŠ å­æ ‘è´¡çŒ®void adds1(int u)&#123; add1(u); for (int i = head[u]; i; i = e[i].nxt) adds1(e[i].to);&#125;void adds2(int u)&#123; add2(u); for (int i = head[u]; i; i = e[i].nxt) adds2(e[i].to);&#125;// æ·¸å­æ ‘è´¡çŒ®void clannad(int u)&#123; cnt[num[u]] = -cjb; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; clannad(v); &#125;&#125;void dsu(int u)&#123; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v != son[u]) &#123; dsu(v); clannad(v); &#125; &#125; if(son[u]) dsu(son[u]); now = u; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v != son[u]) &#123; adds1(v); adds2(v); &#125; &#125; add1(u), add2(u); // è¿™é‡Œçš„ansæ˜¯é™å®šå¿…é¡»ç»è¿‡uçš„è·¯å¾„ï¼Œç±»ä¼¼ä¸ç‚¹åˆ†æ²» ans[u] -= dep[u] * 2; //å‡lcaä¹Ÿå°±æ˜¯uçš„æ·±åº¦ // å› ä¸ºæœ‰å¿…é¡»ç»è¿‡uçš„é™åˆ¶ï¼Œæ‰€ä»¥è¦å’Œå®ƒçš„å­æ ‘å–max for (int i = head[u]; i; i = e[i].nxt) ans[u] = max(ans[u], ans[e[i].to]);&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; (1 &lt;&lt; 22); i++) cnt[i] = -cjb; for (int i = 2; i &lt;= n; i++) &#123; int x; char c; cin &gt;&gt; x &gt;&gt; c; adde(x, i, c - &#x27;a&#x27;); &#125; dfs(1, 0); dsu(1); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; max(ans[i], 0) &lt;&lt; &#x27; &#x27;; return 0;&#125; 9.11 T1 ARC117E ç»™å®š nnn å’Œ kkk ï¼Œæ±‚æœ‰å¤šå°‘é•¿åº¦ä¸º 2n2n2n çš„åˆ— A(a1,a2,a3â‹¯a2n)A(a_1,a_2,a_3 \\cdots a_{2n})A(a1â€‹,a2â€‹,a3â€‹â‹¯a2nâ€‹) æ»¡è¶³åºåˆ—ä¸­æ°å¥½åˆ†åˆ«æœ‰ nnn ä¸ª 111 å’Œ nnn ä¸ª âˆ’1-1âˆ’1 å¹¶ä¸”æœ‰ä¸”ä»…æœ‰ kkk å¯¹ (l,r)(l, r)(l,r) æ»¡è¶³ (1â©½lâ©½r)(1 \\leqslant l \\leqslant r)(1â©½lâ©½r) ä¸” (âˆ‘i=lrai)=0(\\sum\\limits_{i = l}^r a_i) = 0(i=lâˆ‘râ€‹aiâ€‹)=0 å› ä¸ºåºåˆ—ä¸­ä¹‹æœ‰ 000 å’Œ 111 ï¼Œæ‰€ä»¥åºåˆ—ä¸­çš„å‰ç¼€å’Œåº”è¯¥æ˜¯è¿™æ ·çš„ å›¾ç‰‡æ¥è‡ªå®˜æ–¹é¢˜è§£ DPï¼Œè®¾çŠ¶æ€ä¸º f[i][j][k] è¡¨ç¤ºå½“å‰æ„é€ äº†é•¿åº¦ä¸º iii çš„åºåˆ—ï¼Œæœ‰ jjj ä¸ªå’Œä¸º 000 çš„åŒºé—´ï¼Œä¸­é—´æœ‰ kkk ä¸ªæ²¡å¡«ä¸Šçš„æ•° äºæ˜¯æœ‰è½¬ç§»å¼ f[i+len][j+Clen2][xâˆ’(k+1)]+=f[i][j][k]f[i+len][j+C_{len}^2][x - (k + 1)] += f[i][j][k]f[i+len][j+Clen2â€‹][xâˆ’(k+1)]+=f[i][j][k] T2 ARC117F æœ‰ä¸€ä¸ªé•¿åº¦ä¸º 2n2n2n çš„ç¯ A(a1,a2,â‹¯a2n)A(a_1, a_2, \\cdots a_{2n})A(a1â€‹,a2â€‹,â‹¯a2nâ€‹)ï¼Œå¯¹åº”çš„æ¯ä¸ªä½ç½®ä¸Šæœ‰ä¸€ä¸ªé™åˆ¶ bib_ibiâ€‹ ï¼Œè¡¨ç¤º biâ©½âˆ‘ii+nâˆ’1aib_i \\leqslant \\sum\\limits_{i}^{i+n-1} a_ibiâ€‹â©½iâˆ‘i+nâˆ’1â€‹aiâ€‹ ï¼Œè¯·ä½ åœ¨æ»¡è¶³æ‰€æœ‰é™åˆ¶çš„æƒ…å†µä¸‹ï¼Œæ„é€ ä¸€ç§æ–¹æ¡ˆï¼Œä½¿å¾— âˆ‘ai\\sum a_iâˆ‘aiâ€‹ æœ€å° è®°å‰ç¼€å’Œ SiS_iSiâ€‹ ï¼Œå¯ä»¥å‘ç° S2nS_{2n}S2nâ€‹ å¯¹äºè¿™äº›é™åˆ¶æ˜¯æœ‰å•è°ƒæ€§çš„ å¯¹äºç¼–å·å°äº nnn çš„ä½ç½®ï¼Œå®ƒçš„é™åˆ¶è½¬åŒ–ä¸º biâ©½Si+nâˆ’1âˆ’Siâˆ’1b_i \\leqslant S_{i+n-1} - S_{i-1}biâ€‹â©½Si+nâˆ’1â€‹âˆ’Siâˆ’1â€‹ å¯¹äºç¼–å·å¤§äº nnn çš„ä½ç½®ï¼Œå®ƒçš„è¦æ±‚å¯ä»¥è½¬åŒ–ä¸º S2nâˆ’biâ©¾Siâˆ’1âˆ’Siâˆ’nS_{2n} - b_i \\geqslant S_{i-1} - S_{i-n}S2nâ€‹âˆ’biâ€‹â©¾Siâˆ’1â€‹âˆ’Siâˆ’nâ€‹ é‚£ä¹ˆå¯¹æ¯ä¸€ä¸ª aia_iaiâ€‹ éƒ½æœ‰ biâ©½Si+nâˆ’1âˆ’Siâˆ’1â©½S2nâˆ’bi+nb_i \\leqslant S_{i+n-1} - S_{i-1} \\leqslant S_{2n} - b_{i+n}biâ€‹â©½Si+nâˆ’1â€‹âˆ’Siâˆ’1â€‹â©½S2nâ€‹âˆ’bi+nâ€‹ æˆ‘ä»¬å¯ä»¥äºŒåˆ† S2nS_{2n}S2nâ€‹ T3 CF19D ç»´æŠ¤ä¸€ä¸ªäºŒç»´ç‚¹é›†ï¼Œæ”¯æŒæ·»åŠ ä¸€ä¸ªç‚¹ï¼Œåˆ é™¤ä¸€ä¸ªç‚¹ï¼ŒæŸ¥è¯¢ç‚¹ååç»§ (xâ€²&gt;x,yâ€²&gt;y)(x&#x27; &gt; x, y&#x27; &gt; y)(xâ€²&gt;x,yâ€²&gt;y) é‰´å®šä¸ºæ•°æ®ç»“æ„ï¼Œä½¿ç”¨æƒå€¼çº¿æ®µæ ‘ç»´æŠ¤ xxx å€¼ï¼Œ å¥— setsetset ç»´æŠ¤ yyy å€¼ é¦–å…ˆ xxx æ˜¯æŒºå¤§çš„ï¼Œå…ˆè¿›è¡Œä¸€ä¸ªç¦»çº¿å’Œç¦»æ•£åŒ–ï¼Œç„¶åå°±å¹²å˜›å¹²å˜›å°±è¡Œè¾£ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#define MAXN 200005#define pir pair &lt;int, int&gt;#define mkp make_pairusing namespace std;int h[MAXN], maxx;struct OPOPOP&#123; int id; int x, y;&#125;q[MAXN];multiset &lt;int&gt; s[MAXN];namespace Leitree&#123; struct tree &#123; int l, r; int max; &#125;t[MAXN &lt;&lt; 2]; #define ls(i) (i &lt;&lt; 1) #define rs(i) (i &lt;&lt; 1 | 1) void push_up(int i) &#123; t[i].max = max(t[ls(i)].max, t[rs(i)].max); &#125; void build(int i, int l, int r) &#123; t[i].l = l; t[i].r = r; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(ls(i), l, mid); build(rs(i), mid+1, r); &#125; void change(int i, int pos, int val, int op) &#123; if (t[i].l == pos &amp;&amp; t[i].r == pos) &#123; if (op == 1) &#123; s[pos].insert(val); t[i].max = max(t[i].max, val); &#125; else &#123; s[pos].erase(val); if (s[pos].empty()) t[i].max = 0; else t[i].max = *s[pos].begin(); &#125; return; &#125; int mid = (t[i].l + t[i].r) &gt;&gt; 1; if (pos &lt;= mid) change(ls(i), pos, val, op); else change(rs(i), pos, val, op); push_up(i); &#125; pir query(int i, int l, int r, int val) &#123; if (t[i].max &lt;= val) return mkp(-1, -1); if (t[i].l == t[i].r) &#123; int x = t[i].l; return mkp(h[x], *s[x].upper_bound(val)); &#125; int mid = (t[i].l + t[i].r) &gt;&gt; 1; pir ans; if (t[ls(i)].r &gt;= l) &#123; ans = query(ls(i), l, r, val); if (ans.first != -1) return ans; &#125; if (t[rs(i)].l &lt;= r) &#123; ans = query(rs(i), l, r, val); if (ans.first != -1) return ans; &#125; return mkp(-1, -1); &#125;&#125;using namespace Leitree;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; char op[10]; int x, y; scanf(&quot;%s%d%d&quot;, op+1, &amp;x, &amp;y); if (op[1] == &#x27;a&#x27;) q[i].id = 1; if (op[1] == &#x27;r&#x27;) q[i].id = 2; if (op[1] == &#x27;f&#x27;) q[i].id = 3; q[i].x = x; q[i].y = y; h[++cnt] = x; h[++cnt] = x + 1; //è¿™é‡ŒåŠ å…¥ x+1 æ˜¯å› ä¸ºæŸ¥è¯¢çš„æ—¶å€™æ˜¯æŸ¥x+1 //é˜²æ­¢ç¦»æ•£åŒ–å‡ºé”…ï¼Œxdmå¯ä»¥è¯•ä¸€è¯• &#125; sort(h + 1, h + 1 + cnt); maxx = unique(h + 1, h + 1 + cnt) - h-1; build(1, 1, maxx); for (int i = 1; i &lt;= n; i++) &#123; int x = lower_bound(h + 1, h + 1 + maxx, q[i].x) - h; if (q[i].id == 3) &#123; pir ans = query(1, x+1, maxx, q[i].y); if (ans.first != -1) printf(&quot;%d %d\\n&quot;, ans.first, ans.second); else printf(&quot;-1\\n&quot;); &#125; else change(1, x, q[i].y, q[i].id); &#125; return 0;&#125; 9.12 T3 CF1503E nÃ—mn \\times mnÃ—m çš„æ£‹ç›˜ï¼Œæ¯ä¸ªæ ¼å­å¯ä»¥æŸ“æˆé»„è‰²æˆ–è€…è“è‰²ï¼Œå®šä¹‰åˆæ ¼çš„æŸ“è‰²æ–¹æ¡ˆæ˜¯æ¯è¡Œæœ‰ä¸”åªæœ‰ä¸€æ®µè“è‰²çš„æ ¼å­ï¼Œæ¯åˆ—æœ‰ä¸”åªæœ‰ä¸€æ®µé»„è‰²çš„æ ¼å­ï¼Œæ±‚ä¸€å…±æœ‰å¤šå°‘ç§åˆæ ¼çš„æŸ“è‰²æ–¹æ¡ˆ é€šè¿‡è¿™ä¸ªå®šä¹‰æˆ‘ä»¬å‘ç°ï¼Œå·®ä¸å¤šå’Œæ ¼çš„æŸ“è‰²æ–¹æ¡ˆéƒ½æ˜¯é•¿è¿™æ ·çš„ ä¹Ÿå°±æ˜¯è¯´ï¼Œå­˜åœ¨ä¸€æ¡åˆ†ç•Œçº¿ï¼Œä½¿å¾—æ‰€æœ‰é»„è‰²çš„è¿é€šå—äº’ç›¸ä¸è¶Šè¿‡è¿™æ¡åˆ†ç•Œçº¿ ï¼Œè€Œä¸”éƒ½åˆ°è¾¾äº†åˆ†ç•Œçº¿ æ‰€ä»¥æšä¸¾åˆ†ç•Œçº¿å’Œé»„è‰²è¿é€šå—ä¸Š ğŸŒ çš„ä¸¤ä¸ªç¦»å¾—è¿‘çš„ç‚¹ï¼Œè®¡ç®—é»„è‰²è¿é€šå—å¯èƒ½çš„æ–¹æ¡ˆæ•°ï¼Œå…·ä½“è€Œè¨€å°±æ˜¯è¯´è®¡ç®—è¾¹ç•Œå››ä¸ªç‚¹åˆ°è¿™ä¸¤ä¸ªç‚¹çš„æ–¹æ¡ˆæ•° ï¼Œæ•´ç‚¹ç»„åˆæ•°ç®—è·¯å¾„ è¿˜æœ‰ä¸€ç§æƒ…å†µï¼Œæ— éæ˜¯æŠŠæ£‹ç›˜ç¿»è½¬ï¼Œ n,mn,mn,m äº¤æ¢ä¸€ä¸‹ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#define ll long long#define mod 998244353#define RTX 4080using namespace std;ll n, m, ans;ll jc[RTX], ijc[RTX];ll ksm (ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a %mod; a = a * a %mod; b &gt;&gt;= 1; &#125; return ans;&#125;void get_jc(int RTXON = 4060)&#123; jc[0] = jc[1] = 1; ijc[0] = 1; for (int i = 2; i &lt;= RTXON; i++) jc[i] = 1LL*i * jc[i-1] %mod; ijc[RTXON] = ksm(jc[RTXON], mod-2); for (int i = RTXON-1; i; i--) ijc[i] = ijc[i+1] * 1LL*(i+1) %mod;&#125;ll Ways(ll n, ll m)&#123; return jc[n + m] * ijc[n] %mod * ijc[m] %mod;&#125;int main()&#123; scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); get_jc(); for (int i = 1; i &lt;= m-1; i++) &#123; ll sum = 0; for (int j = 1; j &lt;= n-1; j++) &#123; sum = (sum + Ways(i, j-1) * Ways(i-1, n-j)%mod)%mod; ans = (ans + sum * Ways(m-i-1, j)%mod * Ways(m-i, n-j-1)%mod)%mod; &#125; &#125; swap(n, m); for (int i = 1; i &lt;= m-1; i++) &#123; ll sum = 0; for (int j = 1; j &lt;= n-1; j++) &#123; ans = (ans + sum * Ways(m-i-1, j)%mod * Ways(m-i, n-j-1)%mod)%mod; sum = (sum + Ways(i, j-1) * Ways(i-1, n-j)%mod)%mod; &#125; &#125; printf(&quot;%lld&quot;, ans*2%mod); return 0;&#125; 9.13 T1 ç»™å‡ºä¸¤é¢— nnn ç‚¹çš„æœ‰æ ¹æ ‘ï¼ŒTAT_ATAâ€‹ å’Œ TBT_BTBâ€‹ï¼Œä»–ä»¬çš„æ ¹éƒ½æ˜¯ 111 mmm æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ä¸¤ä¸ªç‚¹ uuuï¼Œ vvv ï¼Œæ±‚ä¸€ä¸ªç¼–å·æœ€å¤§çš„ç‚¹ ccc ï¼Œä½¿å¾— ccc åœ¨ TAT_ATAâ€‹ ä¸Šæ˜¯ uuu çš„ç¥–å…ˆï¼Œåœ¨ TBT_BTBâ€‹ ä¸Šæ˜¯ vvv çš„ç¥–å…ˆ å¯¹äº AAA æ ‘ä¸Šçš„æ¯ä¸€ä¸ªç‚¹å»ºç«‹ä¸»å¸­æ ‘ï¼Œç»´æŠ¤è¿™ä¸ªç‚¹åœ¨ BBB æ ‘ä¸Šçš„çš„ç¥–å…ˆä¿¡æ¯ï¼Œå…·ä½“è€Œè¨€å°±æ˜¯è¯´æ’å…¥è¿™ä¸ªç‚¹åœ¨ BBB æ ‘ä¸ŠDFSåºï¼Œç„¶åå¯¹å®ƒçš„å­æ ‘ï¼Œè¿›è¡Œæœ€å¤§å€¼è¦†ç›– Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAXN 100005using namespace std;int n, m;vector &lt;int&gt; e1[MAXN];vector &lt;int&gt; e2[MAXN];namespace Leitree&#123; int rt[MAXN &lt;&lt; 5]; int tot; struct tree &#123; int ls, rs; int max; &#125;t[MAXN &lt;&lt; 5]; #define ls(i) (t[i].ls) #define rs(i) (t[i].rs) int newnode() &#123; ++tot; return tot; &#125; void push_up(int i) &#123; t[i].max = max(t[ls(i)].max, t[rs(i)].max); &#125; void insert(int &amp;i, int last, int l, int r, int L, int R, int val) &#123; i = ++tot; t[i] = t[last]; if (l &gt;= L &amp;&amp; r &lt;= R) &#123; t[i].max = max(t[i].max, val); return; &#125; int mid = (l + r) &gt;&gt; 1; if (mid &gt;= L) insert(ls(i), ls(last), l, mid, L, R, val); if (mid &lt; R) insert(rs(i), rs(last), mid+1, r, L, R, val); &#125; int query(int i, int l, int r, int pos) &#123; if (!i) return 0; if (l == pos &amp;&amp; r == pos) return t[i].max; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) return max(t[i].max, query(ls(i), l, mid, pos)); else return max(t[i].max, query(rs(i), mid+1, r, pos)); &#125; #undef ls #undef rs&#125;using namespace Leitree;int T, siz[MAXN], dfn[MAXN], idfn[MAXN];void dfs1(int u)&#123; siz[u] = 1; dfn[u] = ++T; idfn[T] = u; for (int v : e2[u]) &#123; dfs1(v); siz[u] += siz[v]; &#125;&#125;void dfs2(int u, int dad)&#123; insert(rt[u], rt[dad], 1, n, dfn[u], dfn[u] + siz[u] - 1, u); for (int v : e1[u]) dfs2(v, u); &#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 2; i &lt;= n; i++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); e1[x].push_back(i); &#125; for (int i = 2; i &lt;= n; i++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); e2[x].push_back(i); &#125; dfs1(1); dfs2(1, 0); int last_ans = 0; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); x = (x + last_ans) %n + 1; y = (y + last_ans) %n + 1; printf(&quot;%d\\n&quot;, last_ans = query(rt[x], 1, n, dfn[y])); &#125; return 0;&#125; T2 A,B,C,DA, B, C, DA,B,C,D æ±‚æœ‰å¤šå°‘ä¸ª iii æ»¡è¶³ [A+Bi,A+Ci][A+B_i, A+C_i][A+Biâ€‹,A+Ciâ€‹] ä¸­æ²¡æœ‰ DDD çš„æ•´æ•°å€æ•° æ±‚è¿™ä¸ª âˆ‘i=1n[âŒŠA+BiDâŒ‹=âŒŠA+CiDâŒ‹]\\sum\\limits_{i = 1}^{n}\\left [ \\left \\lfloor \\frac{A + Bi}{D} \\right \\rfloor = \\left \\lfloor \\frac{A + Ci}{D} \\right \\rfloor \\right ] i=1âˆ‘nâ€‹[âŒŠDA+Biâ€‹âŒ‹=âŒŠDA+Ciâ€‹âŒ‹] æ˜¾ç„¶ï¼Œå½“ Ciâˆ’Biâ‰¥DC_i - B_i \\geq DCiâ€‹âˆ’Biâ€‹â‰¥D ï¼Œæ—¶ iii æ²¡æœ‰æ„ä¹‰ï¼Œé‚£ä¹ˆä¸Šç•Œ n=âŒŠDâˆ’2Câˆ’BâŒ‹n = \\left\\lfloor \\frac{D-2}{C-B} \\right\\rfloorn=âŒŠCâˆ’BDâˆ’2â€‹âŒ‹ ï¼Œé‚£ä¹ˆæ­¤æ—¶ä¸¤é¡¹ä¹‹å·®ä¸º 000 æˆ– 111 ï¼Œæ‰€ä»¥é—®é¢˜è½¬åŒ–ä¸º nâˆ’âˆ‘i=1n(âŒŠA+CiDâŒ‹âˆ’âŒŠA+Biâˆ’1DâŒ‹)n - \\sum\\limits_{i=1}^{n} \\left( \\left \\lfloor \\frac{A + Ci}{D} \\right\\rfloor -\\left \\lfloor \\frac{A + Bi-1}{D} \\right \\rfloor \\right) nâˆ’i=1âˆ‘nâ€‹(âŒŠDA+Ciâ€‹âŒ‹âˆ’âŒŠDA+Biâˆ’1â€‹âŒ‹) å¯ä»¥ä½¿ç”¨ç±»æ¬§å‡ é‡Œå¾·è§£å†³ 12345678910111213141516171819ll f(ll a, ll b, ll c, ll n)&#123; if (!a) return 0; if (a &gt;= c || b &gt;= c) return f(a%c, b%c, c, n) + a/c * (n+1)*n/2 + b/c * (n+1); return (a*n + b)/c*n - f(c, c-b-1, a, (a*n+b)/c-1); &#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ll A, B, C, D; scanf(&quot;%lld%lld%lld%lld&quot;, &amp;A, &amp;B, &amp;C, &amp;D); ll n = (D-2)/(C-B); ll res = (f(C, A, D, n) - f(B, A-1, D, n)); printf(&quot;%lld\\n&quot;, n - res); &#125; return 0;&#125; 9.14 T1 ç»´æŠ¤ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„æ•°åˆ— aia_iaiâ€‹ ï¼Œå…±æœ‰ mmm ä¸ªæ“ä½œï¼Œè¿™äº›æ“ä½œå…±æœ‰ä¸¤ç§ã€‚ 1 l r k å°†åŒºé—´ [l,r][l,r][l,r] å†…çš„å…ƒç´ å…¨éƒ¨ä¿®æ”¹ä¸º kkk 2 l r c æŸ¥è¯¢åŒºé—´å†…æ˜¯å¦å­˜åœ¨å‡ºç°æ¬¡æ•°å¤§äº ccc çš„æ•° ä¿è¯æ“ä½œ 222 ä¸­ï¼Œæ»¡è¶³ câ‰¥âŒŠrâˆ’l+15âŒ‹c \\geq \\lfloor \\frac{r-l+1}{5} \\rfloorcâ‰¥âŒŠ5râˆ’l+1â€‹âŒ‹ã€‚ åŒºé—´æ¨å¹³æ“ä½œï¼Œä½¿ç”¨ç‚æœµè‰æ ‘é­”æ³• Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#define otto auto#define MAXN 100005using namespace std;int a[MAXN];namespace Chtholly&#123; class node &#123; public: int l, r; mutable int val; node(int l, int r, int val) &#123; this -&gt; l = l; this -&gt; r = r; this -&gt; val = val; &#125; friend bool operator &lt; (node a, node b) &#123; return a.l &lt; b.l; &#125; int length() const &#123; return (r - l + 1); &#125; &#125;; int length; set &lt;node&gt; odt; void build(int N) &#123; length = N; int l = 1; for (int i = 2; i &lt;= N + 1; i++) if (a[i-1] != a[i]) &#123; odt.insert(node(l, i-1, a[i-1])); l = i; &#125; &#125; otto split(int pos) &#123; if (pos &gt; length) return odt.end(); otto it = --odt.upper_bound(node(pos, 0, 0)); if (it -&gt; l == pos) return it; int l = it -&gt; l; int r = it -&gt; r; int val = it -&gt; val; odt.erase(it); odt.insert(node(l, pos-1, val)); return odt.insert(node(pos, r, val)).first; &#125; void assign(int l, int r, int val) &#123; otto itr = split(r + 1), itl = split(l); odt.erase(itl, itr); odt.insert(node(l, r, val)); &#125; int cnt[MAXN]; bool query(int l, int r, int c) &#123; int flag = 0; otto itr = split(r + 1), itl = split(l); for (otto it = itl; it != itr; it++) &#123; cnt[it -&gt; val] += it -&gt; length(); if (cnt[it -&gt; val] &gt; c) flag = 1; &#125; for (otto it = itl; it != itr; it++) &#123; cnt[it -&gt; val] -= it -&gt; length(); &#125; return flag; &#125;&#125;using namespace Chtholly;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); build(n); int m; scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int op, l, r, val; scanf(&quot;%d%d%d%d&quot;, &amp;op, &amp;l, &amp;r, &amp;val); if (op == 1) assign(l, r, val); else &#123; if (query(l, r, val)) printf(&quot;laffey\\n&quot;); else printf(&quot;ayanami\\n&quot;); &#125; &#125; return 0;&#125; T2 P8456 ç»™å®šä¸€ä¸ª nnn ä¸ªç‚¹ï¼Œ mmm æ¡è¾¹çš„æ— å‘è¿é€šå›¾ã€‚æ¯æ¡è¾¹æ ‡æœ‰ D æˆ– dã€‚ å®šä¹‰æ— åºç‚¹å¯¹ (u,v)(u, v)(u,v) æ˜¯é“çš„ï¼Œå½“ä¸”ä»…å½“ uï¼Œvuï¼Œvuï¼Œv ä¹‹é—´å­˜åœ¨åŒæ—¶å‡ºç° D å’Œ d çš„ç®€å•è·¯å¾„ æ±‚ä¸€å…±æœ‰å‡ ä¸ªè¿™æ ·çš„ç‚¹å¯¹ æˆ‘ä»¬è€ƒè™‘ä»€ä¹ˆæ ·çš„ç‚¹å¯¹æ˜¯ä¸æ»¡è¶³æ¡ä»¶çš„: uuu åˆ° vvv çš„ä»»æ„è·¯å¾„åªæœ‰ D æˆ– d uuu åˆ° vvv çš„æ¯ä¸€æ¡è·¯å¾„ä¸­ä»…æœ‰ D æˆ– d å¯¹äºç¬¬ä¸€ç§æƒ…å†µï¼Œæˆ‘ä»¬é€šè¿‡åœ¨åŸå›¾ä¸­å»æ‰å«æœ‰ D æˆ– d çš„è¾¹ï¼Œå®é™…ä¸Šè½¬åŒ–ç‡ä¸€ä¸ªè”é€šæ€§é—®é¢˜ï¼Œè€ƒè™‘åœ†æ–¹æ ‘ æ£€å‡ºåœ†æ–¹æ ‘åæˆ‘ä»¬å µæ­»æ‰€æœ‰å¯¹åº”ç‚¹åŒå†…å«æœ‰ D çš„æ–¹ç‚¹ï¼Œè¿™æ ·ä»¥åèƒ½äº’ç›¸åˆ°è¾¾çš„ç‚¹åŒä¹‹é—´ç»è¿‡çš„è·¯å¾„ä¸€å®šæ˜¯åªæœ‰ä¸€ç§å­—æ¯çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å¹¶æŸ¥é›†ç»´æŠ¤è¿é€šå—ç»Ÿè®¡ siz ï¼Œå¯¹äº D å’Œ d çš„ä¸¤ç§æƒ…å†µåˆ†åˆ«ç»Ÿè®¡å°±è¡Œ å¯¹äºç¬¬äºŒç§æƒ…å†µï¼Œæˆ‘ä»¬ 9.15 T1 ç­¾åˆ°é¢˜ T2 ç»™å®šä¸€å¼ æœ‰å‘å›¾ï¼Œæ¯ä¸ªç‚¹æœ‰ç‚¹æƒã€‚è¯•æ‰¾åˆ°ä¸€æ¡è·¯å¾„ï¼Œä½¿å¾—è¯¥è·¯å¾„ä¸Šçš„ç‚¹æƒæœ€å¤§å€¼å‡å»ç‚¹æƒæœ€å°å€¼æœ€å¤§ï¼Œé—®è¿™ä¸ªå·®æœ€å¤§æ˜¯å¤šå°‘ è®°å¿†åŒ–æœç´¢ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MAXM 500005#define INF 1145141919using namespace std;int n, m;int f[MAXN];int dis[MAXN];int mi[MAXN], mx[MAXN];int cnte = 1, head[MAXN];struct edge&#123; int to, nxt;&#125;e[MAXM];void adde(int u, int v)&#123; e[++cnte].to = v; e[cnte].nxt = head[u]; head[u] = cnte;&#125;void dfs(int u, int MX, int MI, int fa)&#123; int flag = 1; MX = max(MX, dis[u]), MI = min(MI, dis[u]); if (mx[u] &lt; MX) mx[u] = MX, flag = 0; if (mi[u] &gt; MI) mi[u] = MI, flag = 0; if (f[u] &lt; MX - MI) f[u] = max(f[fa], MX - MI), flag = 0; if (flag) return; for (int i = head[u]; i; i = e[i].nxt) &#123; dfs(e[i].to, MX, MI, u); &#125;&#125;int main()&#123; freopen(&quot;b.in&quot;, &quot;r&quot;, stdin); freopen(&quot;b.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;dis[i]); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); adde(u, v); &#125; for (int i = 1; i &lt;= n; i++) &#123; mi[i] = INF; mx[i] = -INF; &#125; for (int i = 1; i &lt;= n; i++) dfs(i, dis[i], dis[i], 0); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ans = max(ans, f[i]); &#125; printf(&quot;%d&quot;, ans); return 0;&#125; T3 æœ‰ nnn ä¸ªäººï¼Œæ¯ä¸ªäººéƒ½æœ‰ä¸¤æŠŠåˆ·å­ï¼Œæ¯ä¸ªåˆ·å­éƒ½æœ‰ä¸€ä¸ªå±æ€§å€¼ã€‚å¦‚æœè¯´ä¸€ä¸ªäººæ‹¿ç€çš„ä¸¤æŠŠåˆ·å­çš„å±æ€§å€¼ä¹‹å·®çš„ç»å¯¹å€¼è¶…è¿‡äº†ğ‘ï¼Œåˆ™è¿™ä¸ªäººæ— æ³•ä½¿ç”¨ä»–çš„ä¸¤æŠŠåˆ·å­ã€‚ç°åœ¨ä½ å¯ä»¥é€‰æ‹©äº¤æ¢ä¸åŒäººçš„æŸæŠŠåˆ·å­ï¼Œä½¿å¾—æ¯ä¸ªäººéƒ½èƒ½å¤Ÿä½¿ç”¨ä»–ä»¬çš„åˆ·å­ï¼Œé—®æœ€å°æ‰€éœ€è¦çš„äº¤æ¢æ¬¡æ•° çŠ¶å‹è¡¨ç¤ºæ¯ä¸ªäººæ˜¯å¦åŒ¹é…æˆåŠŸï¼Œå…ˆæŠŠä¸åˆæ³•çš„çŠ¶æ€å‡å»ï¼ŒæŠŠäººåˆ†æˆä¸¤éƒ¨åˆ†ï¼Œå„è‡ªäº¤æ¢ï¼Œä¹Ÿå°±æ˜¯æšä¸¾å­é›† Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#define MAXN 17#define cjb 1145141919using namespace std;int n, c;int a[MAXN][2];#define ABS(i) (i &lt; 0 ? -i : i)#define Abs(i) ABS((i))int tmp[50], cnt; int f[1 &lt;&lt; MAXN];int main()&#123; // freopen(&quot;c.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;c.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%d&quot;, &amp;n, &amp;c); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;a[i][0], &amp;a[i][1]); int tot = 0; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) &#123; cnt = 0; int flag = 1; for (int j = 1; j &lt;= n; j++) if (i &amp; (1 &lt;&lt; (j - 1))) &#123; tmp[++cnt] = a[j][0]; tmp[++cnt] = a[j][1]; &#125; sort(tmp + 1, tmp + cnt + 1); for (int j = 1; j &lt;= cnt; j += 2) if (tmp[j + 1] - tmp[j] &gt; c) &#123; flag = 0; break; &#125; if (flag) &#123; f[i] = 1; &#125; else f[i] = -0x3f3f3f3f; &#125; f[0] = 0; for (int i = 1; i &lt; (1 &lt;&lt; n); i++) &#123; for (int j = i; j; j = (j-1) &amp; i) &#123; f[i] = max(f[i], f[j] + f[i^j]); &#125; &#125; if (f[(1 &lt;&lt; n)-1] &lt; 0) printf(&quot;-1&quot;); else &#123; printf(&quot;%d&quot;, n - f[(1 &lt;&lt; n) - 1]); &#125; return 0;&#125; T4 ç»´æŠ¤åºåˆ—ï¼ŒåŒºé—´åŠ æ–æ³¢é‚£å¥‘ï¼ŒåŒºé—´å’Œ è€ƒè™‘å¦‚ä½•å®ç°åŒºé—´åŠ ï¼Œå¤šæ¬¡åŠ æ–æ³¢é‚£å¥‘çš„ç»“æœï¼Œä¸€å®šæ˜¯ä¸€ä¸ªç±»æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œæœ‰ä¸¤ä¸ªé‡è¦æ€§è´¨ âˆ‘F(n)=F(n+2)âˆ’F(2)\\sum F(n) = F(n+2) - F(2)âˆ‘F(n)=F(n+2)âˆ’F(2) gn=g1(nâˆ’2)+g2(nâˆ’1)g_n = g_1(n-2) + g_2(n-1)gnâ€‹=g1â€‹(nâˆ’2)+g2â€‹(nâˆ’1) ï¼Œggg è¡¨ç¤º g1,g2g_1,g_2g1â€‹,g2â€‹ ä¸¤ä¸ªå¯¹åº”é¡¹ç›¸åŠ  æˆ‘ä»¬åªéœ€è¦ç»´æŠ¤é¦–é¡¹å’Œç¬¬äºŒé¡¹å°±å¯ä»¥æ ¹æ®è¿™ä¸¤ä¸ªå¼å­åˆå¹¶ 9.16 T1 ç»™ç”±ä¸€ä¸ªæ­£æ•´æ•° NNNï¼Œæ„é€ ä¸€ä¸ªé•¿åº¦ä¸º kkk çš„æ•°åˆ— Aï¼Œä¸ºä» N å¼€å§‹çš„è¿ç»­ kkk ä¸ªæ•°æŒ‰é¡ºåºæ‹¼æ¥ç”Ÿæˆï¼Œå³ A={N,N+1,N+2,....,N+kâˆ’1}A=\\{N,N+1,N+2,....,N+k-1\\}A={N,N+1,N+2,....,N+kâˆ’1} ï¼ŒæŠŠæ•°åˆ— AAA ä¸­çš„æ¯ä¸ªæ•°éƒ½åªä¿ç•™ä¸€ä¸ªæ•°å­—ï¼Œå¾—åˆ°æ•°åˆ— BBBã€‚ ç°åœ¨ç»™å‡º KKK å’Œæ•°åˆ— BBBï¼Œè¯·æ±‚å‡ºæœ€å°çš„åˆæ³•çš„ nnnã€‚ æšä¸¾æ¯ä¸€ä½æ•°çš„èµ·ç‚¹ï¼Œç„¶åæ¯åä½æ•°åˆå¹¶ï¼Œåœ¨æ¥ç€åä½åä½åœ°æšä¸¾ T2CF1119H ä½ çš„ç”Ÿæ—¥ç¤¼ç‰©æ˜¯nnnä¸ªæ•´æ•°ä¸‰å…ƒç»„ã€‚ç¬¬iiiä¸ªä¸‰å…ƒç»„æ˜¯{ai,bi,ci}\\{a_i,b_i,c_i\\}{aiâ€‹,biâ€‹,ciâ€‹},æ‰€æœ‰æ•°å­—jjjéƒ½æ»¡è¶³0â‰¤j&lt;2k0\\le j&lt;2^k0â‰¤j&lt;2k,kkkæ˜¯ä¸€ä¸ªå›ºå®šçš„æ•°å­—ï¼Œå°†ç”±é¢˜ç›®è¾“å…¥ã€‚ ä¸€å¤©ï¼Œä½ ç©ä¸‰å…ƒç»„ç©è…»äº†ï¼Œæ‰€ä»¥ä½ æœ‰äº†3ä¸ªæ–°çš„æ•´æ•°x,y,zx,y,zx,y,z,ç„¶åå¡«å……äº†nnnä¸ªæ•°ç»„ã€‚ç¬¬iiiä¸ªæ•°ç»„æœ‰xxxä¸ªaia_iaiâ€‹,yyyä¸ªbib_ibiâ€‹,zzzä¸ªcic_iciâ€‹.è¿™æ ·ï¼Œæ¯ä¸ªæ•°ç»„çš„å¤§å°éƒ½æ˜¯x+y+zx+y+zx+y+z. ä½ å¸Œæœ›ä»æ¯ä¸ªæ•°ç»„é‡Œé€‰æ‹©1ä¸ªæ•´æ•°ï¼Œä½¿å¾—å®ƒä»¬çš„xor(æŒ‰ä½å¼‚æˆ–)å€¼æ°å¥½ä¸ºttt. å¯¹äºåŒºé—´[0,2kâˆ’1][0,2^k-1][0,2kâˆ’1]å†…çš„æ¯ä¸ªæ•°å­—ttt,è¾“å‡ºæ»¡è¶³ä¸Šé¢çš„æ¡ä»¶çš„æ–¹æ¡ˆæ•° æ¨¡ 998244353998244353998244353 å¼‚æˆ–è€ƒè™‘ FWT ç»Ÿè®¡æ–¹æ¡ˆæƒ³åˆ°ç”Ÿæˆå‡½æ•°å·ç§¯ï¼Œæˆ‘ä»¬æŠŠè¿™äº›ä¸‰å…ƒç»„çœ‹ä½œä¸€ä¸ªå¤šé¡¹å¼ï¼Œccc è¡¨ç¤ºå¼‚æˆ–å·ç§¯çš„å˜æ¢ç³»æ•° æœ€åçš„å·ç§¯å°±æ˜¯ âˆk=1n((âˆ’1)i&amp;akx+(âˆ’1)i&amp;bky+(âˆ’1)i&amp;ckz) \\prod_{k=1}^{n}\\left((-1)^{i \\&amp; a_{k}} x+(-1)^{i \\&amp; b_{k}} y+(-1)^{i \\&amp; c_{k}} z\\right) k=1âˆnâ€‹((âˆ’1)i&amp;akâ€‹x+(âˆ’1)i&amp;bkâ€‹y+(âˆ’1)i&amp;ckâ€‹z) cntcntcnt è¡¨ç¤ºäºŒè¿›åˆ¶ä¸‹ 111 çš„ä¸ªæ•° æŒ‰ x,y,zx,y,zx,y,z çš„ç³»æ•°å››ç§æƒ…å†µè§£æ–¹ç¨‹ T3CF241B ç»™å®šnä¸ªæ•´æ•°a1,a2...ana1,a2...ana1,a2...an,æ±‚ä¸¤ä¸¤å¼‚æˆ–å€¼å‰kå¤§çš„å’Œã€‚ å…¶ä¸­n&lt;=50000,ai&lt;=109n&lt;=50000,ai&lt;=10^9n&lt;=50000,ai&lt;=109ã€‚ç­”æ¡ˆå¯¹1000000007(109+7)1000000007 (10^9+7)1000000007(109+7)å–æ¨¡ã€‚ äºŒåˆ† kkk å¤§å€¼ ï¼Œæšä¸¾æ¯ä¸ªæ•°ï¼ŒæŸ¥è¯¢ç–‘æƒ‘å’Œå¤§äº midmidmid çš„æ•°é‡ å¯¹åŸæ•°å»º 01Trieï¼Œé¢„å¤„ç†å‡ºæ ‘ä¸Šå­æ ‘ä¸Šçš„å¶å­èŠ‚ç‚¹ä¸ŠäºŒè¿›åˆ¶ä¸‹æ¯ä¸€ä½æ˜¯ 111 çš„æ•°çš„ä¸ªæ•°ã€‚ è¿™æ ·å°±å¯ä»¥æ–¹ä¾¿åœ°å¿«é€Ÿè®¡ç®—å‡ºæ•´æ£µå­æ ‘å¼‚æˆ–ä¸Šä¸€ä¸ªæ•°çš„å’Œã€‚ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;#define MXBT 30#define MAXN 50005#define ll long long#define inv2 500000004#define mod 1000000007using namespace std;int n; ll k;int a[MAXN];ll ans;namespace Trie&#123; int tot; int siz[MAXN * MXBT]; int kid[MAXN * MXBT][2]; int cnt[MAXN * MXBT][MXBT+1]; void insert(int x) &#123; int now = 0; for (int i = MXBT; i &gt;= 0; i--) &#123; int bit = (x &gt;&gt; i) &amp; 1; if (!kid[now][bit]) kid[now][bit] = ++tot; now = kid[now][bit]; siz[now]++; &#125; &#125;&#125;using namespace Trie;ll check(int x)&#123; ll sum = 0; for (int i = 1; i &lt;= n; i++) &#123; int now = 0; for (int j = MXBT; j &gt;= 0; j--) &#123; int u = (a[i] &gt;&gt; j) &amp; 1; int v = (x &gt;&gt; j) &amp; 1; if (!v) &#123; sum += siz[kid[now][u^1]]; now = kid[now][u]; &#125; else now = kid[now][u^1]; if (!now) break; &#125; sum += siz[now]; &#125; return sum/2;&#125;void init(int u, int d, int z)&#123; if (u == 0) return; if (d == 0) &#123; for (int i = 0; i &lt;= MXBT; i++) &#123; if ((z &gt;&gt; i) &amp; 1) cnt[u][i] = siz[u]; &#125; return ; &#125; init(kid[u][0], d-1, z); init(kid[u][1], d-1, z | (1 &lt;&lt; (d - 1))); for (int i = 0; i &lt;= MXBT; i++) cnt[u][i] = cnt[kid[u][0]][i] + cnt[kid[u][1]][i];&#125;void solve(int x)&#123; for (int i = 1; i &lt;= n; i++) &#123; int now = 0; for (int j = MXBT; j &gt;= 0; j--) &#123; int u = (a[i] &gt;&gt; j) &amp; 1; int v = (x &gt;&gt; j) &amp; 1; if (!v) &#123; int t = kid[now][u^1]; for (int k = 0; k &lt;= MXBT; k++) &#123; int w = (a[i] &gt;&gt; k) &amp; 1; if (w) ans = (ans + 1LL*(siz[t] - cnt[t][k]) * (1LL &lt;&lt; k)) %mod; else ans = (ans + 1LL*cnt[t][k] * (1LL &lt;&lt; k)) %mod; &#125; now = kid[now][u]; &#125; else now = kid[now][u^1]; if (!now) break; &#125; ans = (ans + 1LL * siz[now] * x)%mod; &#125;&#125;int main()&#123; scanf(&quot;%d%lld&quot;, &amp;n, &amp;k); if (!k) &#123; putchar(&#x27;0&#x27;); return 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); insert(a[i]); &#125; // cout &lt;&lt; tot &lt;&lt; &quot; I&#x27;,m tot\\n&quot;; init(kid[0][0], MXBT, 0); init(kid[0][1], MXBT, 1 &lt;&lt; MXBT); // for (int i = 1; i &lt;= tot; i++) // &#123; // for (int j = 0; j &lt;= 30; j++) // &#123; // printf(&quot;%d &quot;, cnt[i][j]); // &#125; // cout &lt;&lt; &#x27;\\n&#x27;; // &#125; int l = 0, r = 1 &lt;&lt; MXBT, kth; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; // cout &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; mid &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27;\\n&#x27;; if (check(mid) &gt;= k) &#123; kth = mid; l = mid+1; &#125; else r = mid-1; &#125; // printf(&quot;%d KTH\\n&quot;, kth); solve(kth); // cout &lt;&lt; ans &lt;&lt; &quot;dada\\n&quot;; ans = ans * inv2 %mod; ans = ((ans - 1LL * (check(kth) - k) * kth%mod)%mod + mod)%mod; printf(&quot;%lld&quot;, ans); return 0;&#125; 9.17 åŸé¢˜èµ›ï¼Œskip 9.19 T1JOISC2013 T4 è¿™ä¸ªæ¸¸æˆè¦ç”¨åˆ°ä¸€äº›å†™æœ‰J,O,IJ,O,IJ,O,I ä¸­ä»»ä¸€æ–‡å­—çš„åœ†ç›˜ã€‚è¿™äº›åœ†ç›˜çš„ç›´å¾„äº’ä¸ç›¸åŒã€‚æ¸¸æˆå¼€å§‹æ—¶ï¼Œè¿™äº›åœ†ç›˜æŒ‰ç…§ç›´å¾„å¤§çš„ åœ¨ä¸‹é¢çš„è§„åˆ™å †å ã€‚ä½ éœ€è¦ç”¨è¿™äº›åœ†ç›˜åšå°½é‡å¤šçš„è¿·ä½  JOIOI å¡”ã€‚è¿·ä½  JOIOI å¡”ç”± ä¸ªåœ†ç›˜æ„æˆï¼Œä»ç›´å¾„è¾ƒå°çš„åœ†ç›˜å¼€å§‹åˆ†åˆ«ä¸ºJ,O,IJ,O,IJ,O,I æˆ–åˆ†åˆ«ä¸ºI,O,II,O,II,O,I ã€‚ä¸è¿‡ï¼Œæ¯ä¸ªåœ†ç›˜æœ€å¤šåªèƒ½ä½¿ç”¨ä¸€æ¬¡ ç°åœ¨ç»™å‡ºé•¿ä¸º nnn çš„å­—ç¬¦ä¸² sssï¼Œè¡¨ç¤ºç›´å¾„ä»å°åˆ°å¤§çš„åœ†ç›˜ä¸Šçš„æ–‡å­—ã€‚è¯·ç¼–å†™ç¨‹åºæ±‚å‡ºä½¿ç”¨è¿™äº›åœ†ç›˜èƒ½å¤Ÿåšå‡ºçš„è¿·ä½  JOIOI å¡”ä¸ªæ•°çš„æœ€å¤§å€¼ å€’å™æ‰«æç»´æŠ¤ i ,oi ,ioi, joi çš„ä¸ªæ•° å¦‚æœæœ‰ o ä¸ i åˆæˆ oi å¦‚æœæœ‰ i ä¸ ioi åˆæˆ ioi å¦‚æœæœ‰ j æŠŠ ioi æ‹†æˆ joi å’Œ i Code 12345678910111213141516for (int I = n; I; I--)&#123; if (s[I] == &#x27;J&#x27;) if (i &amp;&amp; oi) &#123; if (oi == ioi || i == ioi * 2) ioi--; oi--; i--; joi++; &#125; if (s[I] == &#x27;O&#x27;) oi = min(i, oi+1); if (s[I] == &#x27;I&#x27;) &#123; if (oi &gt; ioi &amp;&amp; i &gt; ioi * 2) ioi++; i++; &#125;&#125;printf(&quot;%d&quot;, ioi + joi); T2 nnn ä¸ªæ•° a1,â€¦,ana_1, \\dots, a_na1â€‹,â€¦,anâ€‹ï¼Œå®šä¹‰ f(i,j)=ai opt ajf(i,j) = a_i \\; opt \\; a_jf(i,j)=aiâ€‹optajâ€‹ï¼Œ g(i)=maxâ¡res=1iâˆ’1f(ai,ares),iâˆˆ[2,n]g(i)=\\max _{r e s=1}^{i-1} f\\left(a_{i}, a_{r e s}\\right), i \\in[2, n] g(i)=res=1maxiâˆ’1â€‹f(aiâ€‹,aresâ€‹),iâˆˆ[2,n] ä»¥åŠ g(i)g(i)g(i) çš„ä¸ªæ•° é€†å¤© dp ï¼ŒæŠŠç»“æœçš„å‰å››ä½å’Œåå››ä½åˆ†å¼€çœ‹ Code ggg è¡¨ç¤ºå¯¹åº”æƒ…å†µçš„ä¸ªæ•°123456789101112131415161718192021222324252627282930313233343536373839404142int n, TYPE;int ans, cnt;int f[MAXN][MAXN];int g[MAXN][MAXN];char op[5];int F (int x, int y)&#123; return op[1] == &#x27;a&#x27;? x&amp;y : op[1] == &#x27;o&#x27; ? x|y : x^y;&#125;int main()&#123; freopen(&quot;meltdown.in&quot;, &quot;r&quot;, stdin); freopen(&quot;meltdown.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%s%d&quot;, &amp;n, op+1, &amp;TYPE); memset(f, 0xcf, sizeof(f)); int x, y, now, mx; for (int k = 1; k &lt;= n; k++) &#123; scanf(&quot;%d&quot;, &amp;x); y = x &amp; S; x &gt;&gt;= 8; ans = -cjb; cnt = 0; for (int i = 0; i &lt;= S; i++) &#123; now = f[x][i] + F(i, y); if (now &gt; ans) &#123; ans = now; cnt = 0; &#125; if (now == ans) cnt += g[x][i]; &#125; for (int i = 0; i &lt;= S; i++) &#123; now = F(i, x) &lt;&lt; 8; if (f[i][y] &lt; now) &#123; f[i][y] = now, g[i][y] = 0; &#125; if (f[i][y] == now) g[i][y]++; &#125; if (k &gt; 1) &#123; if (TYPE) printf(&quot;%d %d\\n&quot;, ans, cnt); else printf(&quot;%d\\n&quot;, ans); &#125; &#125; return 0;&#125; T4P6965 ç»™å®š n ä¸ª01ä¸²ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²è‡³å¤šæœ‰ä¸€ä½æ˜¯æœªçŸ¥çš„ï¼Œå¯ä»¥å¡« 0 æˆ– 1 ï¼Œæ±‚æ˜¯å¦å­˜åœ¨ä¸€ç§æ–¹æ¡ˆï¼Œä½¿å¾—ä»»æ„ä¸€ä¸ªå­—ç¬¦ä¸²ä¸æ˜¯å…¶å®ƒä»»æ„ä¸€ä¸ªå­—ç¬¦ä¸²çš„å‰ç¼€ 01 è€ƒè™‘ 2-SAT ï¼Œæ˜¾ç„¶çš„æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸èƒ½ä¸å®ƒçš„å‰ç¼€åŒæ—¶å‡ºç°ï¼Œé‚£ä¹ˆä»–ä¸ä»–çš„å‰ç¼€è¿è¾¹ï¼Œn2n^2n2 Tæ‰ è€ƒè™‘ä¼˜åŒ–å»ºå›¾ï¼Œå…¨æ˜¯ 01 è¿˜å¯ä»¥æ–¹ä¾¿çš„ç»´æŠ¤å‰ç¼€ï¼Œè€ƒè™‘ 01Trie Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;#include &lt;type_traits&gt;#define MAXN 3000005using namespace std;int n;string s[MAXN];vector &lt;int&gt; e[MAXN];unordered_map &lt;string, int&gt; mp;vector &lt;int&gt; q[MAXN];void adde(int u, int v)&#123; e[u].push_back(v);&#125;namespace Trie&#123; int rt, tot; int N[MAXN]; int ch[MAXN][2]; void insert(string s, int id) &#123; int now = rt; for (int i = 0; s[i]; i++) &#123; int bit = s[i] - &#x27;0&#x27;; if (!ch[now][bit]) ch[now][bit] = ++tot; now = ch[now][bit]; &#125; q[now].push_back(id); &#125;&#125;using namespace Trie;#define inv(i) ((i &gt; n ? i - n : i + n))void build(int u, int fa)&#123; if (!u) return; N[u] = ++tot; if (fa) adde(u, fa), adde(N[fa], N[u]); for (int v : q[u]) &#123; adde(v, fa); adde(u, inv(v)); adde(N[u], inv(v)); &#125; for (int v : q[fa]) adde(v, N[u]); for (int v : q[u]) for (int z : q[u]) &#123; if (v != z) adde(v, inv(z)); &#125; build(ch[u][0], u); build(ch[u][1], u);&#125;int vis[MAXN];int dfn[MAXN], low[MAXN], T;int sta[MAXN], scc[MAXN], top;int cnt;void Tarjan(int u)&#123; // cout &lt;&lt; u &lt;&lt; &#x27;\\n&#x27;; dfn[u] = low[u] = ++T; sta[++top] = u; vis[u] = 1; for (auto v : e[u]) &#123; if (!dfn[v]) &#123; Tarjan(v); low[u] = min(low[u], low[v]); &#125;else if (vis[v]) low[u] = min(low[u], dfn[v]); &#125; if (low[u] == dfn[u]) &#123; ++cnt; while(sta[top] != u) &#123; int v = sta[top--]; scc[v] = cnt; vis[v] = 0; &#125; scc[sta[top]] = cnt; vis[sta[top--]] = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; rt = tot = n &lt;&lt; 1 | 1; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s[i]; if (++mp[s[i]] &gt;= 3) &#123; printf(&quot;NO&quot;); return 0; &#125; for (int j = 0; ; j++) &#123; if (s[i][j] == &#x27;?&#x27;) &#123; s[i][j] = &#x27;0&#x27;; insert(s[i], i); s[i][j] = &#x27;1&#x27;; insert(s[i], i+n); s[i][j] = &#x27;?&#x27;; break; &#125; if (j == s[i].size() - 1) &#123; insert(s[i], i); insert(s[i], i + n); break; &#125; &#125; &#125; build(rt, 0); for (int i = 1; i &lt;= tot; i++) if (!dfn[i]) Tarjan(i); for (int i = 1; i &lt;= n; i++) &#123; if (scc[i] == scc[i + n]) &#123; printf(&quot;NO&quot;); return 0; &#125; &#125; printf(&quot;YES\\n&quot;); for (int i = 1; i &lt;= n; i++) &#123; int len = s[i].size(); for (int j = 0; j &lt; len; j++) &#123; if (s[i][j] == &#x27;?&#x27;) &#123; s[i][j] = &#x27;0&#x27; + (scc[i] &gt; scc[i + n]); cout &lt;&lt; s[i] &lt;&lt; &#x27;\\n&#x27;; break; &#125; if (j == len-1) &#123; cout &lt;&lt; s[i] &lt;&lt; &#x27;\\n&#x27;; break; &#125; &#125; &#125; return 0;&#125; 9.20 T1 å¯¹äºä¸€ä¸ªåºåˆ— AAA ï¼Œä¸Šå‡å¯¹è¡¨ç¤º ai&lt;ai+1a_i &lt; a_{i+1}aiâ€‹&lt;ai+1â€‹ ï¼Œå®šä¹‰ XiX_iXiâ€‹ è¡¨ç¤ºåºåˆ—ä¸­å‰ iii ä¸ªå…ƒç´ å†…çš„ä¸Šå‡å¯¹çš„æ•°é‡ï¼Œå®šä¹‰ nb åºåˆ—ä¸ºæ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„åºåˆ—ï¼š a1=0a_1 = 0a1â€‹=0 aiâ©½Xiâˆ’1+1a_i \\leqslant X_{i-1}+1aiâ€‹â©½Xiâˆ’1â€‹+1 ä¸å­˜åœ¨ 1â‰¤i&lt;j&lt;kâ‰¤n1 \\leq i &lt; j &lt; k \\leq n1â‰¤i&lt;j&lt;kâ‰¤nï¼Œæ»¡è¶³ ak&lt;ai&lt;aja_k &lt; a_i &lt; a_jakâ€‹&lt;aiâ€‹&lt;ajâ€‹ æ±‚é•¿åº¦ä¸º nnn çš„ nb åºåˆ—çš„æ•°é‡ æ‰“è¡¨é¢˜ T2ARC111F ç»™å®šä¸€ä¸ªåˆå§‹ä¸º 000 çš„é•¿åº¦ä¸º nnn çš„åºåˆ—å’Œä¸€ä¸ªæ•° MMMï¼Œæœ‰ qqq æ¬¡æ“ä½œï¼š 1 l r v: ä½¿ alâˆ¼ara_l \\sim a_ralâ€‹âˆ¼arâ€‹ å¯¹ vvv å–æœ€å°å€¼ 2 l r v: ä½¿ alâˆ¼ara_l \\sim a_ralâ€‹âˆ¼arâ€‹ å¯¹ vvv å–æœ€å¤§å€¼ 3 l r: å°† alâˆ¼ara_l\\sim a_ralâ€‹âˆ¼arâ€‹ çš„å’ŒåŠ åˆ° ansansans ä¸Š 0â‰¤v&lt;m0 \\leq v &lt; m0â‰¤v&lt;m æ±‚æ‰€æœ‰å¯èƒ½çš„ ansansans çš„å’Œ è€ƒè™‘ä¸€ä¸ªä½ç½®åœ¨è¿™äº›æ“ä½œä¸­è¢«ä¿®æ”¹çš„å¯èƒ½ï¼Œä»¥åŠå¯èƒ½è¢«ä¿®æ”¹æˆä»€ä¹ˆå€¼åœ¨ç»è¿‡å¤æ‚çš„æ¨å¼å­ T3ARC120E æ•°è½´ä¸Šæœ‰ä¸€äº›ç‚¹ï¼Œæ¯ä¸€æ—¶åˆ»æ¯ä¸ªç‚¹éƒ½å¯ä»¥å‘å·¦æˆ–å‘å³ç§»åŠ¨ä¸€ä¸ªå•ä½è·ç¦»ï¼Œæ±‚å‡ºæœ€å°çš„éœ€è¦çš„æ—¶é—´ kkk ï¼Œæ¯ä¸€ä¸ª iii å’Œ i+1i+1i+1 è¿™ä¸¤ä¸ªç‚¹éƒ½é‡åˆè¿‡ä¸€æ¬¡ å¯¹äº iii ä¸ªç‚¹ï¼Œè®©ä»–å‘å³ï¼Œç¬¬ i+1i+1i+1 ä¸ªç‚¹å‘å·¦ï¼Œè¿™æ ·å¼ºåˆ¶åŒ¹é…è¿™ä¸¤ä¸ªç‚¹ï¼ŒDP f[i]f[i]f[i] è¡¨ç¤ºå¼ºåˆ¶åŒ¹é… iâˆ’1i-1iâˆ’1 å’Œ iii Code 1234a[0]=a[1],a[n+1]=a[n];f[2]=a[2]-a[1];for(int i=3;i&lt;=n+1;i++)f[i]=min(max(f[i-2],a[i]-a[i-3]),max(f[i-3],a[i]-a[i-4])); 9.22 T1ARC135F ä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— AAA ï¼Œæœ‰ kkk æ¬¡æ“ä½œï¼Œæ¯æ¬¡åˆ é™¤åºåˆ—ä¸­ä¸‹æ ‡ä¸º 3i+13i + 13i+1 çš„æ‰€æœ‰æ•° æ±‚ kkk æ¬¡æ“ä½œååºåˆ—ä¸­æ‰€æœ‰æ•°çš„å’Œ ä¸éš¾æƒ³åˆ° 111 æ¬¡æ“ä½œä»¥å âŒŠ3i+12âŒ‹\\left\\lfloor\\frac{3 i+1}{2}\\right\\rfloorâŒŠ23i+1â€‹âŒ‹ å°±æ˜¯ç¬¬ iii ä¸ªä½ç½®ä¸Šçš„æ•°æ˜¯å“ªä¸ªï¼Œé‚£ä¹ˆæˆ‘ä»¬è®¾ f(i)=âŒŠ3i+12âŒ‹f(i) = \\left\\lfloor\\frac{3 i+1}{2}\\right\\rfloorf(i)=âŒŠ23i+1â€‹âŒ‹ é‚£ä¹ˆ fk(i)f^k(i)fk(i) å°±æ˜¯ kkk æ­¤æ“ä½œåç¬¬ iii ä¸ªä½ç½®çš„æ•° æˆ‘ä»¬å¯ä»¥æ±‚å‡ºæ¯æ¬¡æ“ä½œåå‰©ä¸‹çš„æ•°ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ âˆ‘icntfk(i)\\sum\\limits_i^{cnt} f^k(i)iâˆ‘cntâ€‹fk(i) æš´åŠ›é€’æ¨çš„å¤æ‚åº¦æ˜¯ âˆ‘kcntkÃ—k\\sum\\limits_{}^k cnt_k\\times kâˆ‘kâ€‹cntkâ€‹Ã—k æ˜¾ç„¶çš„æ˜¯æ¯æ¬¡æ“ä½œåªä¼šå‰©ä¸‹ 23n\\frac{2}{3}n32â€‹n ä¸ªæ•°ï¼Œé‚£ä¹ˆæ€»æ—¶é—´å¤æ‚åº¦å¤§çº¦æ˜¯ nk(23k)nk(\\frac{2}{3}^k)nk(32â€‹k) çš„ï¼Œå½“ kkk å¤§ä¸€ç‚¹çš„æ—¶å€™å¯ä»¥é€šè¿‡ fk(n+xk)=fk(n)+3kf^k(n + x^k) = f^k(n) + 3^kfk(n+xk)=fk(n)+3k ï¼ŒæŠŠå¼å­å±•å¼€ä¸€å±‚å°±è¯å‡ºæ¥äº† æ‰€ä»¥æˆ‘ä»¬æšä¸¾æ¯ä¸€ä¸ªä½ç½® iiiï¼Œæ±‚ fk(i+2yj)=fx(fy(i+2yj))=fx(fy(i)+3yj)f^k(i + 2^yj) = f^x(f^y(i+2^yj)) = f^x(f^y(i) + 3^yj)fk(i+2yj)=fx(fy(i+2yj))=fx(fy(i)+3yj) T2ARC127E ç»™ A+BA + BA+B çš„åºåˆ— (x1,x2,â€¦,xA+N)(x_1, x_2, \\dots,x_{A+N})(x1â€‹,x2â€‹,â€¦,xA+Nâ€‹) ï¼ŒåŒ…å« AAA ä¸ª 111 å’Œ BBB ä¸ª 222ã€‚ ç»´æŠ¤ä¸€ä¸ªé›†åˆï¼Œå¦‚æœ xi=1x_i = 1xiâ€‹=1 ï¼Œé‚£ä¹ˆé€‰æ‹©ä¸€ä¸ª vï¼Œ1â‰¤vâ‰¤Avï¼Œ1 \\leq v \\leq Avï¼Œ1â‰¤vâ‰¤A å¦‚æœ xi=2x_i = 2xiâ€‹=2 ï¼Œé‚£ä¹ˆåˆ é™¤é›†åˆä¸­æœ€å¤§çš„æ•° æ±‚é›†åˆæœ€åæœ‰å¤šå°‘ç§å¯èƒ½çš„çŠ¶æ€ æˆ‘ä»¬æœ‰ä¸€ä¸ªç»“è®ºï¼Œå­—å…¸åºæ¯”å¯èƒ½çš„çŠ¶æ€å°çš„ä¸€å®šèƒ½æ»¡è¶³ï¼Œæ‰€ä»¥æˆ‘ä»¬æ±‚å‡ºå­—å…¸åºæœ€å¤§çš„é›†åˆç„¶åä»å­—å…¸åºæ¯”ä»–å°çš„çŠ¶æ€è½¬ç§» fi,j=fi,jâˆ’1+fiâˆ’1,jâˆ’1f_{i,j} = f_{i, j-1} + f_{i-1, j-1} fi,jâ€‹=fi,jâˆ’1â€‹+fiâˆ’1,jâˆ’1â€‹ fi,jf_{i,j}fi,jâ€‹ è¡¨ç¤ºå‰ iii ä¸ªå…ƒç´ ä¸­æœ€å¤§å€¼ä¸º jjj æœ‰å‡ ç§å¯èƒ½ 9.23 T1 ç»™å®šä¸€ä¸ªåºåˆ— aaa ï¼Œä¸¤ç§æ“ä½œ l m r å½’å¹¶ al,al+1,â€¦,am,am+1,am+2,â€¦,ar{a_l, a_{l+1}, \\dots, a_m}, {a_{m+1},a_{m+2},\\dots,a_{r}}alâ€‹,al+1â€‹,â€¦,amâ€‹,am+1â€‹,am+2â€‹,â€¦,arâ€‹ i è¯¢é—® aia_iaiâ€‹ çš„å€¼ å½’å¹¶æŒ‡çš„æ˜¯ä¸€è½®å½’å¹¶æ’åº å¯¹åºåˆ—å»ºå¹³è¡¡æ ‘ï¼Œæ¯æ¬¡å½’å¹¶åˆ†è£‚å‡º lâˆ¼ml \\sim mlâˆ¼m å’Œ m+1âˆ¼rm+1 \\sim rm+1âˆ¼r ï¼Œæ¯æ¬¡åœ¨ä¸€é¢—å­æ ‘ä¸­æŸ¥æ‰¾å°äºå¦é‚£ä¸ªä¸€æ£µå­æ ‘çš„æé•¿å‰ç¼€ï¼Œå¹³è¡¡æ ‘ç»´æŠ¤å°±è¡Œ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;#include &lt;time.h&gt;#define MAXN 100005using namespace std;int n, m;int a[MAXN];namespace FHQ_Treap&#123; int rt, tot; struct tree &#123; int siz, val, key, max, ch[2]; &#125;t[MAXN]; #define ls(i) (t[i].ch[0]) #define rs(i) (t[i].ch[1]) int new_node(int k) &#123; ++tot; t[tot].siz = 1; t[tot].val = k; t[tot].max = k; t[tot].key = rand(); return tot; &#125; void push_up(int i) &#123; t[i].siz = t[ls(i)].siz + t[rs(i)].siz + 1; t[i].max = max(max(t[ls(i)].max, t[rs(i)].max), t[i].max); &#125; int build(int l, int r) &#123; if (l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; int now = new_node(a[mid]); ls(now) = build(l, mid-1); rs(now) = build(mid+1, r); push_up(now); return now; &#125; int merge(int x, int y) &#123; if (!x || !y) return x | y; if (t[x].key &lt; t[y].key) &#123; rs(x) = merge(rs(x), y); push_up(x); return x; &#125; else &#123; ls(y) = merge(x, ls(y)); push_up(y); return y; &#125; &#125; void split_val(int i, int &amp;x, int &amp;y, int val) &#123; if (!i) &#123; x = y = 0; return; &#125; if (max(t[ls(i)].max, t[i].val) &lt;= val) &#123; x = i; split_val(rs(i), rs(x), y, val); &#125; else &#123; y = i; split_val(ls(i), x, ls(y), val); &#125; push_up(i); &#125; void split_siz(int i, int &amp;x, int &amp;y, int siz) &#123; if (!i) &#123; x = y = 0; return; &#125; if (t[ls(i)].siz &lt; siz) &#123; x = i; split_siz(rs(i), rs(x), y, siz-t[ls(i)].siz-1); &#125; else &#123; y = i; split_siz(ls(i), x, ls(y), siz); &#125; push_up(i); &#125; int find(int i) &#123; while(ls(i)) i = ls(i); return t[i].val; &#125; void solve(int l, int mid, int r) &#123; int a, b, c, d, e, f; split_siz(rt, a, b, l-1); split_siz(b, b, c, mid-l+1); split_siz(c, c, d, r-mid); rt = a; while(b &amp;&amp; c) &#123; int cur1 = find(b); int cur2 = find(c); if (cur1 &gt; cur2) &#123; swap(cur1, cur2); swap(b, c); &#125; split_val(b, e, b, cur2); rt = merge(rt, e); &#125; if (c) rt = merge(rt, c); rt = merge(rt, d); &#125; int print(int x) &#123; int a, b, c; split_siz(rt, a, b, x-1); split_siz(b, b, c, 1); int ans = t[b].val; rt = merge(merge(a, b), c); return ans; &#125;&#125;using namespace FHQ_Treap;void dfs(int u)&#123; if (ls(u)) dfs(ls(u)); cout &lt;&lt; t[u].val &lt;&lt; &#x27; &#x27;; if (rs(u)) dfs(rs(u));&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); srand(time(0)); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);rt = build(1, n); // dfs(rt); cout &lt;&lt; &#x27;\\n&#x27;; for (int i = 1; i &lt;= m; i++) &#123; int op; scanf(&quot;%d&quot;, &amp;op); if (op == 1) &#123; int l, mid, r; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;mid, &amp;r); solve(l, mid, r); // dfs(rt); cout &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; int x; scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\\n&quot;, print(x)); &#125; &#125; return 0;&#125; T2ARC112E ç»™å®šä¸€ä¸ªåºåˆ— , mmm æ¬¡æ“ä½œï¼Œåˆ é™¤ä¸€ä¸ªæ•°ï¼Œå¹¶æŠŠå®ƒåŠ åˆ°å¼€å¤´æˆ–ç»“å°¾æ±‚æ‰€æœ‰æ–¹æ¡ˆæ€»æ•°ï¼Œä¸¤ç§æ–¹æ¡ˆç›¸åŒï¼Œå½“ä¸”ä»…å½“æ¯æ¬¡æ“ä½œéƒ½é€‰æ‹©äº†ç›¸åŒå…ƒç´ ï¼Œç§»åŠ¨åˆ°äº†ç›¸åŒçš„æ–¹å‘ å¯¹æ¯ä¸ªæ•°è¿›è¡Œçš„æœ€åä¸€æ¬¡æ“ä½œï¼Œæ‰æ˜¯å†³å®šè¿™ä¸ªæ•°çš„ä½ç½®çš„æ“ä½œï¼Œç§°ä¹‹ä¸ºå…³é”®æ“ä½œ dpi+1,l,r=dpi,l,râˆ—2(l+r)+dpiâˆ’1,l+1,r+dpiâˆ’1,l,r+1dp_{i+1,l,r} = dp{i,l,r} * 2(l+r) + dp{i-1,l+1,r} + dp_{i-1,l,r+1}dpi+1,l,râ€‹=dpi,l,râˆ—2(l+r)+dpiâˆ’1,l+1,r+dpiâˆ’1,l,r+1â€‹ iii æ¬¡æ“ä½œï¼Œ lll æ¬¡å‘å·¦ï¼Œ rrr æ¬¡å‘å³ å®é™…ä¸Š lll å’Œ rrr çš„é¡ºåºæ²¡æœ‰å¿…è¦ dpi,j=dpi+1,jâˆ—2âˆ—j+dpi+1,jâˆ’1dp_{i, j} = dp_{i+1, j} * 2 * j + dp_{i+1, j-1}dpi,jâ€‹=dpi+1,jâ€‹âˆ—2âˆ—j+dpi+1,jâˆ’1â€‹ iii æ¬¡æ“ä½œï¼Œjjj æ¬¡å…³é”®æ“ä½œ T3ARC120F ç»™å®šä¸€ä¸ªåºåˆ— aaa ï¼Œå®šä¹‰ä¸€ä¸ªå­åºåˆ—æ˜¯ nb çš„ï¼Œæ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ : é•¿åº¦ä¸º kkk æ²¡æœ‰åŸåºåˆ—ä¸­è¿ç»­çš„ä¸¤ä¸ªå…ƒç´ åœ¨åºåˆ—ä¸­ æ±‚æ‰€æœ‰ nb åºåˆ—çš„å’Œ é¦–å…ˆä¸€ä¸ªåºåˆ— ä¸ç›¸é‚»é€‰ kkk ä¸ªçš„æ–¹æ¡ˆ Cnâˆ’k+1kC_{n-k+1}^kCnâˆ’k+1kâ€‹, è®°ä¸º CCC è€ƒè™‘æ±‚å‡ºæ¯ä¸€ä¸ªæ•°ä¼šåœ¨å¤šå°‘ç§æ–¹æ¡ˆä¸­å‡ºç°ï¼Œè®°ä¸º cntcntcnt å¦‚æœæ˜¯ä¸€ä¸ªç¯ï¼Œé‚£ä¹ˆ cnt=CÃ—kncnt = \\frac{C \\times k}{n}cnt=nCÃ—kâ€‹ ï¼Œè€Œæ˜¯ä¸€ä¸ªåºåˆ—ï¼Œåªæ˜¯å¤šäº† a1a_1a1â€‹ å’Œ ana_nanâ€‹ éƒ½é€‰çš„æƒ…å†µ 9.26 T1 çŒé­”äººæ°æ´›ç‰¹æ¥åˆ°äº†ç‰›å ¡ã€‚ç‰›å ¡å¯ä»¥è¢«è§†ä¸ºä¸€ä¸ªäºŒç»´å¹³é¢ï¼Œè€Œç‰›å ¡çš„è¡—é“å¯ä»¥è¢«è§†ä¸ºä¸€æ¡æ¡ç›´çº¿ã€‚å ¡å…±æœ‰ nnn æ¡å—åŒ—å‘è¡—é“ï¼Œå…¶ä¸­ç¬¬ iii æ¡ä¸ºç›´çº¿ x=aix = a_ix=aiâ€‹ ï¼Œå¦å¤–è¿˜æœ‰ mmm æ¡ä¸œè¥¿å‘è¡—é“ï¼Œå…¶ä¸­ç¬¬ iii æ¡ä¸ºç›´çº¿ y=biy= biy=bi ã€‚æ²¿ç€ç¬¬ iii æ¡å—åŒ—å‘è¡—é“è¡Œè¿› 111 å•ä½è·ç¦»éœ€è¦ tit_itiâ€‹ çš„æ—¶é—´ï¼Œè€Œæ²¿ç€ä»»æ„ä¸€æ¡ä¸œè¥¿å‘è¡—é“è¡Œè¿› 111 å•ä½è·ç¦»å‡éœ€è¦ t0t_0t0â€‹ çš„æ—¶é—´ã€‚ä»–å¸Œæœ›ä½ å¸®å¿™è®¡ç®—ä»åŸå¸‚å…¥å£ (0,0)(0,0)(0,0) å‡ºå‘åˆ°è¾¾å„ä¸ªåå­—è·¯å£çš„æœ€çŸ­æ—¶é—´ã€‚å…·ä½“æ¥è¯´ï¼Œä»¤ f(ai,bj)f(ai,bj)f(ai,bj) è¡¨ç¤ºä» (0,0)(0,0)(0,0) å‡ºå‘ï¼Œæ²¿ç€è¡—é“è¡Œè¿›å¹¶åˆ°è¾¾åå­—è·¯å£ (ai,bj)(ai,bj)(ai,bj) æ‰€éœ€çš„æœ€çŸ­æ—¶é—´ï¼Œæ°æ´›ç‰¹è¯·ä½ å¯¹äºæ‰€æœ‰ 1â‰¤iâ‰¤n1 \\leq i \\leq n1â‰¤iâ‰¤n åˆ†åˆ«è®¡ç®—ä¸‹å¼çš„å€¼ æ¨ªå‘çš„é“è·¯è´¹ç”¨æ˜¯å®Œå…¨ç›¸åŒçš„ã€‚ ç¬¬ä¸€ç§æƒ…å†µæ˜¯å¯ä»¥ O(1)O(1)O(1) æ±‚çš„ï¼Œå‘ç°æ¨ªç€èµ°ä¸€æ ·ï¼Œé‚£ä¹ˆæœ‰åŒºåˆ«çš„å°±æ˜¯ç«–ç€èµ°çš„è·¯ç¨‹å’Œæ¨ªç€å¤šèµ°å‡ºæ¥çš„ ä»¥æ¨ªç€èµ°åˆ°è·¯ç¨‹ä¸º xxx ï¼Œé‚£ä¹ˆç«–ç€çš„èŠ±è´¹æ˜¯ä¸€ä¸ªå¸¸æ•°ï¼Œæ¨ªç€çš„èŠ±è´¹æ˜¯ç³»æ•°ã€‚å¯ä»¥æ„é€ å‡ºä¸€ä¸ªä¸€æ¬¡å‡½æ•°ï¼Œæ–œç‡ä¼˜åŒ–ç»´æŠ¤ä¸Šå‡¸å£³ T2 ç»™ä¸€ä¸ªé•¿ä¸º nnn çš„åºåˆ—å’Œæ¨¡æ•°ï¼Œ333 ä¸­æ“ä½œï¼ŒåŒºé—´ä¹˜ï¼Œå•ç‚¹é™¤ï¼ŒæŸ¥è¯¢åŒºé—´å’Œ åŒºé—´ä¹˜å¾ˆç®€å•ï¼Œéš¾çš„æ˜¯å•ç‚¹é™¤ï¼Œæ¨¡æ•°ä¸ä¸€å®šæ˜¯è´¨æ•°ï¼Œæ‰€ä»¥ä¸ä¸€å®šæœ‰é€†å…ƒ æŠŠæ¨¡æ•°åˆ†è§£ï¼Œç»´æŠ¤æ¯ä¸ªæ•°å’Œæ¨¡æ•°çš„å…¬å…±è´¨å› æ•°ï¼Œå…ˆæŠŠè¿™äº›å› æ•°é™¤äº†ï¼Œå‰©ä¸‹çš„å°±æ˜¯å’Œæ¨¡æ•°äº’è´¨çš„ï¼Œå¯ä»¥æœ‰é€†å…ƒ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;bits/stdc++.h&gt;#include &lt;string&gt;#define ll long long#define MAXN 500005#define mul(x, y) ((x) = ((x) * (y))%mod)int n, m;ll mod, a[MAXN];ll prime[MAXN], mp[MAXN];int cntp;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if (b == 0) &#123; x = 1; y = 0; return; &#125; exgcd(b, a%b, y, x); y -= a / b * x;&#125;ll inv(ll val)&#123; ll a, b; exgcd(val, mod, a, b); return (a %mod + mod) %mod;&#125;ll ksm (ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a %mod; a = a * a %mod; b &gt;&gt;= 1; &#125; return ans;&#125;namespace Leitree&#123; int cnt[MAXN &lt;&lt; 2][20]; struct tree &#123; int l, r; ll d; ll sum, lz; &#125;t[MAXN &lt;&lt; 2]; #define ls(i) (i &lt;&lt; 1) #define rs(i) (i &lt;&lt; 1 | 1) void push_up(int i) &#123; t[i].sum = (t[ls(i)].sum + t[rs(i)].sum) %mod; &#125; void push_down(int i) &#123; mul(t[ls(i)].sum, t[i].lz); mul(t[ls(i)].lz, t[i].lz); mul(t[ls(i)].d, t[i].d); mul(t[rs(i)].sum, t[i].lz); mul(t[rs(i)].lz, t[i].lz); mul(t[rs(i)].d, t[i].d); t[i].d = t[i].lz = 1; for (int j = 1; j &lt;= cntp; j++) &#123; cnt[ls(i)][j] += cnt[i][j]; cnt[rs(i)][j] += cnt[i][j]; cnt[i][j] = 0; &#125; &#125; void build(int i, int l, int r) &#123; t[i].l = l; t[i].r = r; t[i].lz = 1; t[i].d = 1; if (l == r) &#123; t[i].sum = a[l]; ll x = a[l]; for (int j = 1; j &lt;= cntp; j++) &#123; while(x % prime[j] == 0) &#123; cnt[i][j]++; x /= prime[j]; &#125; &#125; t[i].d = x; return ; &#125; int mid = (l + r) &gt;&gt; 1; build(ls(i), l, mid); build(rs(i), mid+1, r); push_up(i); &#125; void add(int i, int l, int r, ll val) &#123; if (t[i].l &gt;= l &amp;&amp; t[i].r &lt;= r) &#123; mul(t[i].sum, val); mul(t[i].lz, val); for (int j = 1; j &lt;= cntp; j++) &#123; while (val % prime[j] == 0) &#123; cnt[i][j]++; val /= prime[j]; &#125; &#125; mul(t[i].d, val); return; &#125; push_down(i); if (t[ls(i)].r &gt;= l) add(ls(i), l, r, val); if (t[rs(i)].l &lt;= r) add(rs(i), l, r, val); push_up(i); &#125; void change(int i, int pos, ll val) &#123; if (t[i].l == pos &amp;&amp; t[i].r == pos) &#123; for (int j = 1; j &lt;= cntp; j++) while (val % prime[j] == 0) &#123; cnt[i][j]--; val /= prime[j]; &#125; mul(t[i].d, inv(val)); t[i].sum = t[i].d; for (int j = 1; j &lt;= cntp; j++) if (cnt[i][j]) &#123; mul(t[i].sum, ksm(prime[j], cnt[i][j])); &#125; return; &#125; push_down(i); int mid = (t[i].l + t[i].r) &gt;&gt; 1; if (pos &lt;= mid) change(ls(i), pos, val); else change(rs(i), pos, val); push_up(i); &#125; ll query(int i, int l, int r) &#123; if (t[i].l &gt;= l &amp;&amp; t[i].r &lt;= r) return t[i].sum %mod; push_down(i); ll ans = 0; if (t[ls(i)].r &gt;= l) ans = (ans + query(ls(i), l, r)) %mod; if (t[rs(i)].l &lt;= r) ans = (ans + query(rs(i), l ,r)) %mod; push_up(i); return ans; &#125; #undef ls #undef rs&#125;using namespace Leitree;void devide(ll x)&#123; for (ll p = 2; p * p&lt;= x; p++) &#123; if (x % p == 0) &#123; prime[++cntp] = p; &#125; while (x % p == 0) x /= p; &#125; if (x != 1) &#123; prime[++cntp] = x; &#125;&#125;int main()&#123; read(n, mod); for (int i = 1; i &lt;= n; i++) read(a[i]); devide(mod); build(1, 1, n); read(m); for (int i = 1; i &lt;= m; i++) &#123; int op; read(op); if (op == 1) &#123; int l, r; ll val; read(l, r, val); add(1, l, r, val); &#125; if (op == 2) &#123; int pos; ll val; read(pos, val); if (val == 1) continue; change(1, pos, val); &#125; if (op == 3) &#123; int l, r; read(l, r); printf(&quot;%d\\n&quot;, query(1, l, r) ); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"æ€»ç»“","slug":"æ€»ç»“","permalink":"https://ve1bae.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"è´ªå¿ƒ","slug":"è´ªå¿ƒ","permalink":"https://ve1bae.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"https://ve1bae.github.io/tags/dsu-on-tree/"},{"name":"æ•°å­¦ï¼Œæ•°è®º","slug":"æ•°å­¦ï¼Œæ•°è®º","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"}]},{"title":"è™šæ ‘","slug":"è™šæ ‘","date":"2022-08-17T14:05:51.000Z","updated":"2022-11-08T10:40:10.226Z","comments":true,"path":"2022/08/17/è™šæ ‘/","link":"","permalink":"https://ve1bae.github.io/2022/08/17/%E8%99%9A%E6%A0%91/","excerpt":"Virtual Tree","text":"Virtual Tree è™š ğŸŒ³ P2495 å¤§æ¦‚çš„æ„æ€æ—¶æœ‰ä¸€æ£µ nnn ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œ mmm æ¬¡è¯¢é—®ï¼Œæ–­ä¸€æ¡è¾¹éœ€è¦èŠ±è´¹ç›¸åº”çš„è´¹ç”¨ï¼Œæ¯æ¬¡è¯¢é—® kkk ä¸ªç‚¹ä½¿ä¸€å·èŠ‚ç‚¹å’Œå®ƒä»¬ä¸è¿é€šæœ€å°‘çš„ä»£ä»·ï¼Œæ–­çš„è¾¹ä¸ä¼šç»§æ‰¿åˆ°ä¸‹ä¸€æ¬¡è¯¢é—®ã€‚ nâ©½2.5Ã—105, mâ©½5Ã—105,âˆ‘kâ©½5Ã—105n \\leqslant 2.5 \\times 10^5,\\ m \\leqslant 5 \\times 10^5, \\sum k \\leqslant 5 \\times 10^5nâ©½2.5Ã—105, mâ©½5Ã—105,âˆ‘kâ©½5Ã—105 é¦–å…ˆæˆ‘ä»¬å¯ä»¥æ ‘å½¢dpï¼Œf[i]f[i]f[i] è¡¨ç¤ºåˆ‡æ–­ä»¥ iii ä¸ºæ ¹çš„å­æ ‘ä¸­æ‰€æœ‰è¯¢é—®ç‚¹çš„ä»£ä»·ï¼Œc[i]c[i]c[i] è¡¨ç¤º uuu åˆ°1å·èŠ‚ç‚¹è·¯å¾„ä¸Šè¾¹æƒçš„æœ€å°å€¼ã€‚ å½“ç‚¹ uuu æœ¬èº«æ˜¯è¯¢é—®ç‚¹æ—¶ï¼Œ f[u]=c[u]f[u] = c[u]f[u]=c[u] ï¼Œå¦åˆ™f[u]=min(c[u],âˆ‘f[v]),vâˆˆson(u)f[u] = min(c[u], \\sum f[v]),v \\in son(u)f[u]=min(c[u],âˆ‘f[v]),vâˆˆson(u) æœ€åç­”æ¡ˆä¸º f[1]f[1]f[1] ï¼Œæ—¶é—´å¤æ‚åº¦ O(nm)O(nm)O(nm) ï¼Œè‚¯å®šè¿‡ä¸å»ï¼Œä½†æ˜¯æˆ‘ä»¬å‘ç°æœ‰äº›ç‚¹æ ¹æœ¬æ²¡å¿…è¦è·‘ æ¯”å¦‚è¯´å­æ ‘å†…ä¸€ä¸ªè¯¢é—®ç‚¹éƒ½æ²¡æœ‰çš„èŠ‚ç‚¹ï¼Œæ‰€ä»¥è€ƒè™‘ä¼˜åŒ–è¿™æ£µæ ‘ã€‚ å»ºè™šæ ‘ é¦–å…ˆæ¯æ¬¡è¯¢é—®ç‚¹æ—¶å¿…é¡»è¦ä¿ç•™çš„ï¼Œè€Œåˆè¦ä¸æ”¹å˜èŠ‚ç‚¹çš„è¾ˆåˆ†å…³ç³»ï¼Œè¿˜è¦è®©èŠ‚ç‚¹æ•°å°½é‡å°‘ æ‰€ä»¥æˆ‘ä»¬æŠŠè¯¢é—®ç‚¹å’Œå®ƒä»¬ä¸¤ä¸¤ä¹‹é—´çš„ LCA ä¿ç•™ï¼Œä½†æ˜¯æˆ‘ä»¬ä¹Ÿä¸èƒ½ k2k^2k2 æšä¸¾è¯¢é—®ç‚¹çš„LCA æ‰€ä»¥ç”¨å•è°ƒæ ˆçš„æ€æƒ³ï¼Œç»´æŠ¤æ ‘ä¸Šçš„ä¸€æ¡é“¾ï¼ŒDFS åºå•è°ƒé€’å¢ å…ˆé¢„å¤„ç† dfsdfsdfs åºï¼Œç„¶åå°†è¯¢é—®ç‚¹æŒ‰ dfsdfsdfs åºæ’åºï¼Œå¼€å§‹å…ˆå°†ç¬¬ä¸€ä¸ªç‚¹åŠ å…¥æ ˆä¸­ uuu è¡¨ç¤ºå½“å‰è¦åŠ å…¥çš„ç‚¹ï¼Œ lcalcalca è¡¨ç¤º uuu ä¸æ ˆé¡¶çš„ lcalcalca åˆ†ä¸ºä¸¤ç§æƒ…å†µ æ ˆé¡¶å°±æ˜¯ lcalcalca ï¼Œè¯´æ˜æ ˆé¡¶ä¸ uuu åœ¨ä¸€æ¡é“¾ä¸Šï¼Œç›´æ¥æŠŠ uuu jåŠ å…¥æ ˆ æ ˆé¡¶ä¸æ˜¯ lcalcalca ï¼Œå¼¹å‡ºæ ˆé¡¶ç›´åˆ° uuu ä¸æ ˆé¡¶åœ¨ä¸€æ¡é“¾ä¸Šï¼Œä¹Ÿå°±æ˜¯è¯´è·³åˆ° dfn åºå¤§äºæ ˆé¡¶ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;#define ll long long#define cjb 1145141919810#define MAXN 250005#define V Vshojousing namespace std;int n, m, k;int a[MAXN];int vis[MAXN];#define pir pair &lt;int, ll&gt;#define dis second#define to firstvector &lt;pir&gt; e[MAXN];vector &lt;int&gt; Vshojo[MAXN];ll c[MAXN];int T;int fa[MAXN], siz[MAXN], dep[MAXN];int son[MAXN], top[MAXN], dfn[MAXN];void dfs1(int u, int dad)&#123; dfn[u] = ++T; siz[u] = 1; fa[u] = dad; dep[u] = dep[dad] + 1; for(pir y : e[u]) &#123; int v = y.to; if(v == dad) continue; c[v] = min(c[u], y.dis); dfs1(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if(son[u]) dfs2(son[u], tup); for(pir y : e[u]) &#123; int v = y.to; if(v == fa[u] || v == son[u]) continue; dfs2(v, v); &#125;&#125;int LCA(int u, int v)&#123; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt;= dep[top[v]]) u = fa[top[u]]; else v = fa[top[v]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;bool cmp(int a, int b)&#123; return dfn[a] &lt; dfn[b];&#125;void build()&#123; int sta[MAXN], top = 0; sort(a + 1, a + 1 + k, cmp); sta[++top] = 1; for(int i = 1; i &lt;= k; i++) &#123; int lca = LCA(a[i], sta[top]); if(lca != sta[top]) &#123; while(dfn[lca] &lt; dfn[sta[top-1]]) &#123; V[sta[top]].push_back(sta[top-1]); V[sta[top-1]].push_back(sta[top]); top--; &#125; V[lca].push_back(sta[top]); V[sta[top]].push_back(lca); if(dfn[sta[top-1]] != dfn[lca]) sta[top] = lca; else top--; &#125; sta[++top] = a[i]; &#125; for(int i = 1; i &lt; top; i++) &#123; V[sta[i]].push_back(sta[i+1]); V[sta[i+1]].push_back(sta[i]); &#125;&#125;ll dp(int u, int fa)&#123; ll ans = 0; for(int v : V[u]) &#123; if(v == fa) continue; ll s = dp(v, u); if(vis[v]) ans += c[v], vis[v] = 0; else ans += min(c[v], s); &#125; V[u].clear(); return ans;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++) &#123; int u, v; ll w; scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w); e[u].push_back(make_pair(v, w)); e[v].push_back(make_pair(u, w)); &#125; c[1] = cjb; dfs1(1, 0); dfs2(1, 1); scanf(&quot;%d&quot;, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d&quot;, &amp;k); for(int j = 1; j &lt;= k; j++) scanf(&quot;%d&quot;, &amp;a[j]), vis[a[j]] = 1; build(); printf(&quot;%lld\\n&quot;,dp(1, 0)); &#125; return 0;&#125;","categories":[],"tags":[{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://ve1bae.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"è™šæ ‘","slug":"è™šæ ‘","permalink":"https://ve1bae.github.io/tags/%E8%99%9A%E6%A0%91/"}]},{"title":"ç‚¹åˆ†æ²»","slug":"ç‚¹åˆ†æ²»","date":"2022-08-17T13:37:29.000Z","updated":"2022-11-08T07:42:45.290Z","comments":true,"path":"2022/08/17/ç‚¹åˆ†æ²»/","link":"","permalink":"https://ve1bae.github.io/2022/08/17/%E7%82%B9%E5%88%86%E6%B2%BB/","excerpt":"æ·€ç²‰è´¨","text":"æ·€ç²‰è´¨ ç‚¹åˆ†æ²» å¯ä»¥å¤„ç†ä¸€äº›æœ‰å…³æ ‘ä¸Šè·¯å¾„çš„é—®é¢˜ï¼Œå…ˆçœ‹é¢˜ 8ï¸âƒ£ P3806 é¦–å…ˆå¯¹äºä¸€ä¸ªç‚¹ uuu å’Œå®ƒçš„å­æ ‘ä¸­ä»»æ„ä¸€ä¸ªç‚¹ vvv ï¼Œ dis(v)dis(v)dis(v) è¡¨ç¤º vvv åˆ° uuu çš„è·¯å¾„æƒå€¼å’Œ è€ƒè™‘å¼€ä¸€ä¸ªæ¡¶ u[k]u[k]u[k] è®°å½•æ˜¯å¦å­˜åœ¨ dis(v)=kdis(v) = kdis(v)=k é‚£ä¹ˆä¸åœ¨åŒä¸€ä¸ªå­æ ‘çš„ä¸¤ä¸ªç‚¹çš„è´¡çŒ®å°±å¥½ç®—äº† å¯¹äºä¸€ä¸ªå­˜åœ¨çš„ u[w],w&lt;=ku[w],w &lt;= ku[w],w&lt;=k å¦‚æœå­˜åœ¨ u[kâˆ’w]u[k-w]u[kâˆ’w] é‚£ä¹ˆå°±å­˜åœ¨è¿™æ ·ä¸€ä¸ªç‚¹å¯¹ å¯¹äºåœ¨åŒä¸€ä¸ªå­æ ‘å†…ç‚¹çš„è´¡çŒ®ï¼Œæˆ‘ä»¬æŠŠ uuu åˆ å»,æŠŠæ ‘æ‹†å¼€é€’å½’åˆ°è¿™äº›å­æ ‘ä¸­ä¸‹å»æ±‚è§£ è‚¯å®šæ˜¯æ‹†æˆçš„å­æ ‘å¤§å°è¶Šå‡è¡¡è¶Šå¥½ï¼Œæ‰€ä»¥æ¯æ¬¡èŠ‚ç‚¹ uuu çš„é€‰å–è¦è®²ç©¶ä¸€ç‚¹ æ¯æ¬¡é€‰å–å½“å‰æ ‘çš„é‡å¿ƒä½œä¸º uuu ï¼Œæ€»æ—¶é—´å¤æ‚åº¦ O(nlogn)O(nlogn)O(nlogn) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;#define MAXN 10005#define MAXK 10000005#define ll long long#define cjb 1145141919using namespace std;namespace F_star&#123; int cnte = 0, head[MAXN]; struct edge &#123; int to, nxt; ll dis; &#125;e[MAXN &lt;&lt; 1]; void adde(int u, int v, ll w) &#123; e[++cnte].to = v; e[cnte].dis = w; e[cnte].nxt = head[u]; head[u] = cnte; &#125;&#125;using namespace F_star;struct query&#123; int k, ans;&#125;que[105];int n,m;int siz[MAXN];int root, sixz, sum;ll dis[MAXN];bool vis[MAXN];bool t[MAXK+5];void get_zx(int u) //æ‰¾é‡å¿ƒ&#123; int msiz = 0; // ä¸èƒ½å®šä¹‰æˆå…¨å±€å˜é‡ siz[u] = 1; vis[u] = true; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(vis[v]) continue; get_zx(v); siz[u] += siz[v]; msiz = max(msiz, siz[v]); &#125; msiz = max(msiz, sum - siz[u]); if(msiz &lt; sixz) &#123;sixz = msiz; root = u;&#125; vis[u] = false;&#125;ll sta1[MAXN], top1;ll sta2[MAXN], top2;int debug;void get_dis(int u) //å¤„ç†å­æ ‘å†…ä¸ªèŠ‚ç‚¹åˆ°å½“å‰æ ¹çš„è·¯å¾„æƒå€¼&#123; if(dis[u] &gt; MAXK) return; vis[u] = true; sta1[++top1] = dis[u]; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(vis[v]) continue; dis[v] = dis[u] + e[i].dis; get_dis(v); &#125; vis[u] = false;&#125;void get_ans(int u) //ç»Ÿè®¡ç­”æ¡ˆ&#123; t[0] = 1; top2 = 0; vis[u] = true; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(vis[v]) continue; top1 = 0; dis[v] = e[i].dis; get_dis(v); for(int j = 1; j &lt;= top1; j++) &#123; for(int k = 1; k &lt;= m; k++) //åˆ†åˆ«ç»Ÿè®¡æ¯ä¸ªè¯¢é—® &#123; if(sta1[j] &lt;= que[k].k) que[k].ans |= t[que[k].k - sta1[j]]; &#125; &#125;//å…ˆç»Ÿè®¡åœ¨åŠ å…¥è´¡çŒ®ï¼Œä¿è¯ç»Ÿè®¡çš„æ˜¯ä¸åŒå­æ ‘çš„ä¸¤ç‚¹çš„è´¡çŒ® for(int j = 1; j &lt;= top1; j++) sta2[++top2] = sta1[j], t[sta1[j]] = 1; //åŠ å…¥å­æ ‘è´¡çŒ® &#125; for(int i = 1; i &lt;= top2; i++) //æ¸…æ¥šè´¡çŒ® t[sta2[i]] = 0; vis[u] = false;&#125;void solve(int u) //åˆ†æ²»å‡½æ•°&#123; get_ans(u); vis[u] = true; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(vis[v]) continue; sum = siz[v]; sixz = cjb; get_zx(v); solve(root); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n, &amp;m); for(int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); adde(u, v, w); adde(v, u, w); &#125; for(int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;,&amp;que[i].k); sum = n; sixz = cjb; get_zx(1); solve(root); for(int i = 1; i &lt;= m; i++) printf(que[i].ans ? &quot;AYE\\n&quot; : &quot;NAY\\n&quot;); return 0;&#125; P4178 Tree ç»å…¸é¢˜ç»™å®šä¸€ä¸ª nnn ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ±‚æ ‘ä¸Šä¸¤ç‚¹è·ç¦»å°äºç­‰äº kkk çš„ç‚¹å¯¹æ•°é‡ å’Œæ¿å­é¢˜ç›¸æ¯”ï¼Œè¯¢é—®ä»æ˜¯å¦å­˜åœ¨å˜ä¸ºäº†æŸ¥è¯¢ç‚¹å¯¹æ•°é‡ï¼Œè€Œä¸”ä¸å†ç­‰äºè€Œæ˜¯å°äºç­‰äº å°äºç­‰äºçš„è¯ï¼Œæˆ‘ä»¬å¯¹æ¡¶æ±‚ä¸€ä¸ªå‰ç¼€å’Œï¼Œå°±å¯ä»¥åšåˆ° O(1)O(1)O(1) æŸ¥è¯¢ å‘ç°åŠ è´¡çŒ®å®é™…ä¸Šæ˜¯å•ç‚¹ä¿®æ”¹ï¼ŒæŸ¥è¯¢æ˜¯åŒºé—´æŸ¥è¯¢ï¼Œä½¿ç”¨æ•°æ®ç»“æ„ç»´æŠ¤æ¡¶å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦ O(nlog2n)O(nlog^2n)O(nlog2n) æ¨èä½¿ç”¨æ ‘çŠ¶æ•°ç»„ P2634 å›½å®¶é›†è®­é˜Ÿ èªèªå¯å¯ ç»™å®šä¸€ä¸ª nnn ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ±‚æ ‘ä¸Šä¸¤ç‚¹è·ç¦»çš„æ˜¯ 333 çš„å€æ•°çš„ç‚¹å¯¹æ•°é‡ å¤„ç†æƒå€¼æ˜¯ % 3\\% \\ 3% 3 ï¼Œæ­£å¸¸ç»´æŠ¤å³å¯","categories":[],"tags":[{"name":"ç‚¹åˆ†æ²»","slug":"ç‚¹åˆ†æ²»","permalink":"https://ve1bae.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"}]},{"title":"æ ‘çš„åŒæ„","slug":"æ ‘çš„åŒæ„","date":"2022-08-17T13:29:48.000Z","updated":"2022-11-08T10:40:03.519Z","comments":true,"path":"2022/08/17/æ ‘çš„åŒæ„/","link":"","permalink":"https://ve1bae.github.io/2022/08/17/%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/","excerpt":"æŸä¸çŸ¥åçš„ AHU ç®—æ³• å’Œ æ ‘å“ˆå¸Œ","text":"æŸä¸çŸ¥åçš„ AHU ç®—æ³• å’Œ æ ‘å“ˆå¸Œ æ ‘åŒæ„é—®é¢˜ å®šä¹‰ æœ‰æ ¹æ ‘åŒæ„ å¯¹äºä¸¤é¢—æœ‰æ ¹æ ‘ T1(V1,E1,r1)T_1(V_1,E_1,r_1)T1â€‹(V1â€‹,E1â€‹,r1â€‹) å’Œ T2(V2,E2,r2)T_2(V_2,E_2,r_2)T2â€‹(V2â€‹,E2â€‹,r2â€‹) å­˜åœ¨ä¸€ä¸ªåŒå°„ Ï†:V1â†’V2\\varphi: V_1 \\rightarrow V_2Ï†:V1â€‹â†’V2â€‹ ï¼Œä½¿å¾— âˆ€u,vâˆˆV1,(u,v)âˆˆE1 âŸº (Ï†(u),Ï†(v))âˆˆE2\\forall u,v \\in V_1,(u,v) \\in E_1 \\iff (\\varphi(u),\\varphi(v)) \\in E_2 âˆ€u,vâˆˆV1â€‹,(u,v)âˆˆE1â€‹âŸº(Ï†(u),Ï†(v))âˆˆE2â€‹ ä¸” Ï†(r1)=r2\\varphi(r_1) = r_2Ï†(r1â€‹)=r2â€‹ æˆç«‹ï¼Œé‚£ä¹ˆç§°æœ‰æ ¹æ ‘ T1T_1T1â€‹ å’Œ T2T_2T2â€‹ åŒæ„ã€‚ æ— æ ¹æ ‘åŒæ„ å¯¹äºä¸¤é¢—æ— æ ¹æ ‘ T1(V1,E1)T_1(V_1,E_1)T1â€‹(V1â€‹,E1â€‹) å’Œ T2(V2,E2)T_2(V_2,E_2)T2â€‹(V2â€‹,E2â€‹) å­˜åœ¨ä¸€ä¸ªåŒå°„ Ï†:V1â†’V2\\varphi: V_1 \\rightarrow V_2Ï†:V1â€‹â†’V2â€‹ ï¼Œä½¿å¾— âˆ€u,vâˆˆV1,(u,v)âˆˆE1 âŸº (Ï†(u),Ï†(v))âˆˆE2\\forall u,v \\in V_1,(u,v) \\in E_1 \\iff (\\varphi(u),\\varphi(v)) \\in E_2 âˆ€u,vâˆˆV1â€‹,(u,v)âˆˆE1â€‹âŸº(Ï†(u),Ï†(v))âˆˆE2â€‹ é‚£ä¹ˆç§°æœ‰æ ¹æ ‘ T1T_1T1â€‹ å’Œ T2T_2T2â€‹ åŒæ„ã€‚ æ˜ å°„æŒ‡ä¸¤ä¸ªå…ƒç´ çš„é›†ä¹‹é—´å…ƒç´ ç›¸äº’å¯¹æ˜ çš„å…³ç³» è®¾ fff æ˜¯ä»é›†åˆ AAA åˆ°é›†åˆ bbb çš„æ˜ å°„ï¼Œè‹¥ f(A)=Bf(A) = Bf(A)=B ï¼Œå³ BBB ä¸­ä»»ä¸€å…ƒç´  bbb éƒ½æ˜¯ AAA ä¸­æŸå…ƒç´ çš„åƒï¼Œåˆ™ç§° fff ä¸º AAA åˆ° BBB ä¸Šçš„æ»¡å°„ï¼› è‹¥å¯¹ AAA ä¸­ä»»æ„ä¸¤ä¸ªä¸åŒå…ƒç´  a1â‰ a2a_1 \\ne a_2a1â€‹î€ =a2â€‹ï¼Œå®ƒä»¬çš„åƒ f1â‰ f2f_1 \\ne f_2f1â€‹î€ =f2â€‹ï¼Œåˆ™ç§° fff ä¸º AAA åˆ° BBB çš„å•å°„ï¼› è‹¥æ˜ å°„ fff æ—¢æ˜¯å•å°„ï¼Œåˆæ˜¯æ»¡å°„ï¼Œé‚£ä¹ˆç§° fff ä¸º AAA åˆ° BBB çš„åŒå°„ æˆ‘çœ‹ä¸æ‡‚ ğŸ˜…ğŸ˜…ğŸ˜… ä½†æ˜¯æ— å…³ç´§è¦ å¦‚æœæŠŠ T1T_1T1â€‹ ä¸Šçš„èŠ‚ç‚¹é‡æ–°æ ‡å·ä½¿å¾— T1T_1T1â€‹ ä¸ T2T_2T2â€‹ å®Œå…¨ç›¸åŒï¼Œé‚£ä¹ˆä¸¤æ ‘åŒæ„ è¿˜æœ‰å°±æ˜¯æœ‰æ ¹æ ‘åŒæ„ï¼Œæ— æ ¹æ ‘åŒæ„ æœ‰æ ¹æ ‘åŒæ„æ˜¾ç„¶æ›´ç®€å•ï¼Œè€ƒè™‘æ— æ ¹æ ‘è½¬æ¢æˆæœ‰æ ¹æ ‘åŒæ„ï¼Œæ²¡æœ‰æ ¹æˆ‘ä»¬å°±æ•´ä¸€ä¸ªæ ¹ çœ‹åˆ°ä»æ ‘ä¸Šå–å‡ºä¸€ä¸ªç‚¹æ¥ï¼Œè€ƒè™‘æ‰¾æ ‘çš„é‡å¿ƒ æˆ‘ä»¬çŸ¥é“ä¸€æ£µæ ‘å¯èƒ½æœ‰ä¸€ä¸ªæˆ–ä¸¤ä¸ªé‡å¿ƒï¼Œæ‰€ä»¥åˆ†ä¸ºè¿™å‡ ç§æƒ…å†µ ä¸¤æ£µæ ‘é‡å¿ƒæ•°é‡ä¸åŒï¼Œé‚£ä¹ˆä¸åŒæ„ é‡å¿ƒæ•°é‡éƒ½ä¸º 1ï¸âƒ£ é‚£ä¹ˆä¸¤æ£µæ ‘åˆ†åˆ«ä»¥å®ƒä»¬çš„é‡å¿ƒä¸ºæ ¹çš„æœ‰æ ¹æ ‘åŒæ„çš„è¯ï¼Œè¿™ä¸¤é¢—æ ‘å°±æ„ å¦åˆ™ä¸åŒæ„ ä¸­å¿ƒæ•°é‡éƒ½ä¸º 2ï¸âƒ£ é‚£ä¹ˆä¸¤æ£µæ ‘åˆ†åˆ«ä»¥ä»–ä»¬çš„é‡å¿ƒä¸ºæœ‰æ ¹æ ‘ä¸­ï¼Œæœ‰ä¸€å¯¹åŒæ„çš„è¯ï¼Œè¿™ä¸¤æ£µ æ ‘å°±åŒæ„ï¼ˆæˆ–çš„å…³ç³»ï¼‰ï¼Œå¦åˆ™ä¸åŒæ„ AHUç®—æ³• å‰ç½®ï¼šæ‹¬å·åº æŠŠä¸€æ£µæ ‘ç”¨æ‹¬å·è¡¨ç¤ºï¼Œæ¯æ£µå­æ ‘ç”¨ä¸€å¯¹æ‹¬å·æ‹¬èµ·æ¥ è¿™é¢—æ ‘çš„æ‹¬å·åºå°±æ˜¯( () (()) () ()) æ ‡ä¸Šå·å°±æ˜¯(1 (0) (4(5)) (8) (9)) æ‰€ä»¥ä¸€é¢—æœ‰æ ¹æ ‘å­˜åœ¨ä¸€ä¸ªå”¯ä¸€çš„æ‹¬å·åºï¼Œè€Œä¸”è¿™ä¸ªæ‹¬å·åºå¯ä»¥çœ‹æˆç”±ä»–çš„å­—æ•°çš„æ‹¬å·åºæ‹¼æ¥è€Œæ¥çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æ”¹å˜ä¸€ä¸‹å­æ ‘æ‹¼æ¥çš„é¡ºåºï¼Œå¾—åˆ°çš„æ–°æ‹¬å·åºå¯¹åº”çš„æ ‘ä¸åŸæ ‘åŒæ„ é€’å½’æ±‚æ‹¬å·åºæ—¶ï¼ŒæŠŠå­æ ‘çš„æ‹¬å·åºæ’ä¸ªåºå†æ‹¼æ¥ï¼Œæ¯”è¾ƒè¿™æ ·å¾—åˆ°çš„æ‹¬å·åºå°±è¡Œäº† O(nlogn)O(nlogn)O(nlogn) ç”¨è¿™ç§æ–¹å¼éœ€è¦æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œè€Œä¸”å½“æ ‘æ˜¯ä¸€æ¡é“¾æ—¶å­—ç¬¦ä¸²ä¼šå¾ˆé•¿ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ O(n2)O(n^2)O(n2) è€ƒè™‘æŠŠæ‹¬å·åºæ¢æˆæ•°å€¼ï¼Œå¯¹äºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå®ƒçš„æ‹¬å·åºåªä¸ä»–çš„å„¿å­èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯å®ƒçš„æ·±åº¦+1çš„èŠ‚ç‚¹æœ‰å…³ï¼Œæ‰€ä»¥å¯ä»¥æŠŠæ ‘åˆ†å±‚ï¼Œç„¶åç”¨èŠ‚ç‚¹åœ¨å®ƒæ‰€åœ¨çš„å±‚çš„æ’åä»£æ›¿æ‹¬å·ï¼Œè¿™æ ·ä¹‹åï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„æ‹¬å·åºå˜æˆäº†ä¸€ä¸ªå¤§å°æ˜¯èŠ‚ç‚¹å­—æ•°å¤§å°çš„æ•°ç»„ï¼Œå¯¹æ•°ç»„è¿›è¡Œæ¯”è¾ƒå°±è¡Œè¾£ ç®—æ³•æµç¨‹ æ‰¾é‡å¿ƒï¼Œé‡å¿ƒæ•°é‡ä¸åŒ return false DFSå¤„ç†å‡ºèŠ‚ç‚¹æ·±åº¦ï¼ŒæŠŠæ·±åº¦ç›¸åŒçš„èŠ‚ç‚¹æ”¾åˆ°ä¸€ä¸ªæ•°ç»„ä¸­ ä»å°åˆ°å¤§æšä¸¾æ·±åº¦ï¼Œåˆå¹¶å„¿å­æ‹¬å·åºï¼Œæ’åºï¼Œå¤„ç†å½“å‰æ‹¬å·åº 123456789101112131415161718192021222324252627282930313233void AHU()&#123; for(int i = n-1; i &gt;= 0; i--) &#123; for(int j = 0; j &lt; lv[i].size(); j++) &#123; int v = lv[i+1][j]; f[fa[v]].push_back(dis[v]); &#125; sort(lv[i].begin(), lv[i].end(), cmp); int cnt = 0; for(int j = 0; j &lt; lv[i].size(); j++) &#123; if(g[lv[i][j]] != g[lv[i][j - 1]]) cnt++; dis[lv[i][j]] = cnt; &#125; &#125;&#125; //å»ºè¾¹ï¼Œæ‰¾é‡å¿ƒ,é¢„å¤„ç†æ·±åº¦å’Œçˆ¶äº² if(rt1.size() != rt2.size()) &#123;printf(&quot;NO&quot;); return 0;&#125; fa[rt1[0]] = 0; fa[rt2[0]] = 0; dfs(rt1[0]); dfs(rt2[0]); AHU(); if(g[rt1[0]] == g[rt2[0]]) &#123;printf(&quot;YES&quot;); return 0;&#125; if(rt2.size() == 1) &#123;printf(&quot;NO&quot;); retuen 0;&#125; fa[rt[2]] = 0; dfs(rt2[1]); AHU(); printf(g[rt1[0]] == g[rt2[0]] ? &quot;YES&quot; : &quot;NO&quot;); æ ‘å“ˆå¸Œ æŠŠæ ‘æ˜ å°„æˆä¸€ä¸ªå“ˆå¸Œå€¼ï¼Œä¸»è¦æœ‰ä¸‰ç§æ–¹æ³• æ–¹æ³•ä¸€ fu=sizeuÃ—âˆ‘fson(u,i)Ã—seediâˆ’1f_u = size_u \\times \\sum f_{son(u,i)} \\times seed^{i-1} fuâ€‹=sizeuâ€‹Ã—âˆ‘fson(u,i)â€‹Ã—seediâˆ’1 fuf_ufuâ€‹ è¡¨ç¤º uuu ä¸ºæ ¹çš„å­æ ‘çš„ hash å€¼ sizesizesize æ˜¯ä»¥ uuu ä¸ºæ ¹çš„å­æ ‘å¤§å° son(u,i)son(u,i)son(u,i) è¡¨ç¤º uuu çš„å„¿å­ä»¬æŒ‰ fff æ’åºåç¬¬ iii ä¸ªå„¿å­ seedseedseed æ˜¯ä¸€ä¸ªå¤§è´¨æ•° æ–¹æ³•äºŒ fu=â¨fson(u,i)Ã—seed+sizeson(u,i)f_{u}=\\bigoplus f_{son(u,i)}\\times seed+size_{son(u,i)} fuâ€‹=â¨fson(u,i)â€‹Ã—seed+sizeson(u,i)â€‹ son(u,i)son(u,i)son(u,i) è¡¨ç¤ºå„¿å­èŠ‚ç‚¹ï¼ˆä¸æ’åºï¼‰ â¨\\bigoplusâ¨ ç–‘æƒ‘å’Œ å› ä¸ºæ˜¯å¼‚æˆ–ï¼Œå½“å­˜åœ¨å¤šæ£µæœ¬è´¨ç›¸åŒçš„å­æ ‘æ—¶ï¼Œè¿™ç§å­æ ‘å‡ºç°æ¬¡æ•°1ï¼Œ3ï¼Œ5â€¦æ—¶æ— æ³•åŒºåˆ† æ–¹æ³•ä¸‰ fu=1+âˆ‘fson(u,i)Ã—prime(sizeson(u,i))f_{u}=1+\\sum f_{son(u,i)} \\times prime(size_{son(u,i)}) fuâ€‹=1+âˆ‘fson(u,i)â€‹Ã—prime(sizeson(u,i)â€‹) prime(i)prime(i)prime(i) ç¬¬ iii ä¸ªè´¨æ•° ä½¿ç”¨è¿™ç§æ–¹æ³•éœ€è¦å…ˆåˆ¤å®šä¸€ä¸‹å­æ ‘å¤§å° æˆ‘ä»¬æ±‚å‡ºçš„æ˜¯å­æ ‘çš„ hash å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´å½“é€‰å–çš„æ ¹å¯¹åŠ²æ—¶ä¸¤æ£µæ ‘æ‰ä¼šåˆ¤ä¸ºåŒæ„ ä¸€ç§æ–¹æ³•æ˜¯æš´åŠ›æšä¸¾ä»¥æ¯ä¸ªèŠ‚ç‚¹ä¸ºæ ¹æ—¶çš„ hash å¦ä¸€ç§æ–¹æ³•æ˜¯æ‰¾é‡å¿ƒï¼Œä»¥é‡å¿ƒä¸ºæ ¹è¿›è¡Œ hash å¹³å¸¸ä½¿ç”¨ä¹Ÿå¯ä»¥æ‰¾é‡å¿ƒæ¥å‡å°‘å†²çª æ¯”å¦‚æ ‘æ˜¯ä¸€æ¡é“¾ï¼Œè®¡ç®— hash å€¼æ—¶å‘ç°ä¹˜ä»¥ seedseedseed çš„æ¬¡æ•°ä¼šå¾ˆå°‘","categories":[],"tags":[{"name":"æ ‘åŒæ„","slug":"æ ‘åŒæ„","permalink":"https://ve1bae.github.io/tags/%E6%A0%91%E5%90%8C%E6%9E%84/"}]},{"title":"Dsu on tree","slug":"Dsu-on-tree","date":"2022-08-17T10:46:59.000Z","updated":"2022-11-08T10:40:14.667Z","comments":true,"path":"2022/08/17/Dsu-on-tree/","link":"","permalink":"https://ve1bae.github.io/2022/08/17/Dsu-on-tree/","excerpt":"æ ‘ä¸Šè«é˜Ÿï¼ˆè¿«çœŸ","text":"æ ‘ä¸Šè«é˜Ÿï¼ˆè¿«çœŸ æ ‘ä¸Šå¯å‘å¼åˆå¹¶ dsu on ğŸŒ³ ä¸€èˆ¬ç”¨æ¥å¤„ç†ä¸€äº›å¸¦æœ‰å¦‚ä¸‹ç‰¹å¾çš„æ ‘ä¸Šé—®é¢˜ ä¸å¸¦ä¿® å¯¹äºå­æ ‘çš„è¯¢é—® è€ƒè™‘ O(n2)O(n^2)O(n2) æš´åŠ›ï¼Œéå†èŠ‚ç‚¹å­æ ‘ç»Ÿè®¡ç­”æ¡ˆï¼Œç„¶åæ¸…é™¤å­æ ‘çš„è´¡çŒ®é˜²æ­¢å¯¹å®ƒçš„å…„å¼Ÿé€ æˆå½±å“ æˆ‘ä»¬å‘ç°æœ‰ä¸€æ£µå­æ ‘çš„è´¡çŒ®å¯ä»¥ä¸æ¸…ç©ºï¼Œç›´æ¥é€’å½’åŠ åˆ°å½“å‰èŠ‚ç‚¹çš„è´¡çŒ®é‡Œ æ˜¾ç„¶æ˜¯ä¸æ¸…ç©ºçš„å­æ ‘è¶Šå¤§è¶Šå¥½ï¼Œæ‰€ä»¥è€ƒè™‘é‡é“¾å‰–åˆ†ï¼Œä¿ç•™èŠ‚ç‚¹é‡å„¿å­æ‰€åœ¨çš„å­æ ‘ ç®—æ³•æµç¨‹ï¼š é¢„å¤„ç†å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„é‡å„¿å­ é€’å½’ç»Ÿè®¡è½»å„¿å­ç­”æ¡ˆï¼Œæ¸…é™¤ ç»Ÿè®¡é‡å„¿å­çš„ç­”æ¡ˆï¼Œä¸æ¸…é™¤è´¡çŒ® æœ€åç»Ÿè®¡å½“å‰èŠ‚ç‚¹çš„ç­”æ¡ˆï¼Œå› ä¸ºæ¸…æ¥šäº†è½»å„¿å­çš„è´¡çŒ®ï¼Œè¦å†åŠ å›æ¥ dsu on tree å°±æ˜¯ç‰ˆå­ï¼Œç»Ÿè®¡å’Œæ¸…é™¤è´¡çŒ®éœ€è¦çµæ´»è¿ç”¨ CF375D ç»™å®šä¸€æ£µ nnn ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ ¹èŠ‚ç‚¹ä¸º 111ã€‚æ¯ä¸ªèŠ‚ç‚¹ä¸Šæœ‰ä¸€ä¸ªé¢œè‰² cic_iciâ€‹ã€‚mmm æ¬¡æ“ä½œã€‚æ¯æ¬¡è¯¢é—®åœ¨ä»¥ uuu ä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œå‡ºç°æ¬¡æ•° â‰¥k\\ge kâ‰¥k çš„é¢œè‰²æœ‰å¤šå°‘ç§ çº¯çº¯æ»´æ¿å­ï¼Œç»´æŠ¤ä¸¤ä¸ªæ¡¶ cnt[i] è¡¨ç¤ºé¢œè‰² i çš„å‡ºç°æ¬¡æ•° cntt[i] è¡¨ç¤ºå‡ºç°æ¬¡æ•°å¤§äºç­‰äº i çš„é¢œè‰²æœ‰å¤šå°‘ä¸ª Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int n, m, c[MAXN];int siz[MAXN], son[MAXN];int cnt[MAXN], cntt[MAXN];int ans[MAXN], Ans;namespace F_star&#123; int cnte = 0, head[MAXN]; struct edge &#123; int to, nxt; &#125;e[MAXN &lt;&lt; 1]; void adde(int u, int v) &#123; e[++cnte].to = v; e[cnte].nxt = head[u]; head[u] = cnte; &#125;&#125;using namespace F_star;struct query&#123; int id, val;&#125;;vector &lt;query&gt; v[MAXN];void dfs(int u, int fa)&#123; siz[u] = 1; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; dfs(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;//åŠ å•ç‚¹è´¡çŒ®ï¼Œåˆ å•ç‚¹è´¡çŒ®void add(int u)&#123; cnt[c[u]]++; cntt[cnt[c[u]]]++;&#125;void del(int u)&#123; cntt[cnt[c[u]]]--; cnt[c[u]]--;&#125;//åŠ å­æ ‘è´¡çŒ®ï¼Œåˆ å­æ ‘è´¡çŒ®void adds(int u, int fa)&#123; add(u); for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; adds(v, u); &#125;&#125;void clannad(int u, int fa)&#123; del(u); for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; clannad(v, u); &#125;&#125;void dsu(int u, int fa)&#123; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa || v == son[u]) continue; dsu(v, u); clannad(v, u); //é€’å½’ç»Ÿè®¡è½»å„¿å­ç­”æ¡ˆï¼Œå¹¶æ¸…é™¤è´¡çŒ® &#125; if(son[u]) dsu(son[u], u); //ç»Ÿè®¡é‡å„¿å­ç­”æ¡ˆ for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa || v == son[u]) continue; adds(v, u); // æŠŠè½»å„¿å­è´¡çŒ®åŠ è¿›æ¥ &#125; add(u); //åŠ å…¥å½“å‰èŠ‚ç‚¹ for(int i = 0; i &lt; v[u].size(); i++) ans[v[u][i].id] = cntt[v[u][i].val];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;,&amp;c[i]); for(int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); adde(u, v); adde(v, u); &#125; for(int i = 1; i &lt;= m; i++) &#123; int u, k; scanf(&quot;%d%d&quot;,&amp;u,&amp;k); v[u].push_back(query&#123;i, k&#125;); &#125; dfs(1, 0); dsu(1, 0); for(int i = 1; i &lt;= m; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; CF600E ç»™å®šä¸€æ£µ nnn ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ ¹èŠ‚ç‚¹ä¸º 111ã€‚æ¯ä¸ªèŠ‚ç‚¹ä¸Šæœ‰ä¸€ä¸ªé¢œè‰² cic_iciâ€‹ã€‚è¯¢é—®å­æ ‘å†…å‡ºç°æ¬¡æ•°æœ€å¤šçš„é¢œè‰²çš„ç¼–å·å’Œ ç¨å¾®ä¸æ˜¯é‚£ä¹ˆæ¿ï¼Œä½†è¿˜æ˜¯è¯¥å’‹åŠå’‹åŠï¼Œç”¨ä¸€ä¸ªæ ˆç»´æŠ¤å‡ºç°äº†å“ªäº›é¢œè‰²ï¼ŒåŠ¨æ€ç»´æŠ¤æœ€å¤§å€¼å³å¯ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define MAXN 100005#define ll long longusing namespace std;int n;int c[MAXN], cnt[MAXN], maxt;ll ans[MAXN], Ans;namespace F_star&#123; int cnte = 0, head[MAXN]; struct edge &#123; int to, nxt; &#125;e[MAXN &lt;&lt; 1]; void adde(int u, int v) &#123; e[++cnte].to = v; e[cnte].nxt = head[u]; head[u] = cnte; &#125; &#125;using namespace F_star;int siz[MAXN], son[MAXN];void dfs(int u, int fa)&#123; siz[u] = 1; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; dfs(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;int sta[MAXN], top;//æ¸…ç©ºè´¡çŒ®void clannad()&#123; while(top) cnt[sta[top--]] = 0; maxt = Ans = 0;&#125;void add(int u)&#123; ++cnt[c[u]]; sta[++top] = c[u]; //åŠ å…¥è´¡çŒ®å¹¶å¤„ç†ç­”æ¡ˆ if(cnt[c[u]] &gt; maxt) &#123; maxt = cnt[c[u]]; Ans = c[u]; &#125; else if(cnt[c[u]] == maxt) Ans += c[u]; &#125;void adds(int u, int fa)&#123; add(u); for(int i = head[u]; i; i = e[i].nxt) &#123; if(e[i].to != fa) adds(e[i].to, u); &#125;&#125;void dsu(int u, int fa)&#123; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == son[u] || v == fa) continue; dsu(v, u); clannad(); &#125; if(son[u]) dsu(son[u], u); for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == son[u] || v == fa) continue; adds(v, u); &#125; add(u); ans[u] = Ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;,&amp;c[i]); for(int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); adde(u, v); adde(v, u); &#125; dfs(1, 0); dsu(1, 0); for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;,ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"https://ve1bae.github.io/tags/dsu-on-tree/"}]},{"title":"æ ‘åŸºç¡€","slug":"æ ‘åŸºç¡€","date":"2022-08-17T10:45:00.000Z","updated":"2022-11-08T10:40:05.930Z","comments":true,"path":"2022/08/17/æ ‘åŸºç¡€/","link":"","permalink":"https://ve1bae.github.io/2022/08/17/%E6%A0%91%E5%9F%BA%E7%A1%80/","excerpt":"ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³","text":"ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ğŸŒ³ ğŸŒ³ç›¸å…³ å®šä¹‰ æ£®æ—ï¼Œçˆ¶äº²ï¼Œç¥–å…ˆï¼Œæ·±åº¦ï¼ŒäºŒå‰æ ‘ï¼Œæ»¡äºŒå‰æ ‘ éå† å…ˆåºéå† æ ¹ â†’\\rightarrowâ†’ å·¦ â†’\\rightarrowâ†’ å³ 123456void prebl(int now)&#123; printf(&quot;%d &quot;,now) prebl(ls(now)); prebl(rs(now));&#125; ä¸­åºéå† å·¦ â†’\\rightarrowâ†’ æ ¹ â†’\\rightarrowâ†’ å³ 123456void midbl(int now)&#123; printf(&quot;%d &quot;,now) midbl(ls(now)); midbl(rs(now));&#125; ååºéå† å·¦ â†’\\rightarrowâ†’ å³ â†’\\rightarrowâ†’ æ ¹ 123456void nxtbl(int now)&#123; nxtbl(ls(now)); nxtbl(rs(now)); printf(&quot;%d &quot;,now)&#125; æ ‘çš„ç›´å¾„ æ ‘ä¸Šä»»æ„ä¸¤ä¸ªç‚¹ä¹‹é—´æœ€é•¿çš„ç®€å•è·¯å¾„ ä¸¤æ¬¡DFS å…ˆä»ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ uuu å‡ºå‘ï¼Œæ‰¾åˆ°è·ç¦»å®ƒæœ€è¿œçš„ vvv å†æ‰¾åˆ°è·ç¦» vvv æœ€è¿œçš„ zzz ï¼Œé‚£ä¹ˆ (u,z)(u, z)(u,z) å°±æ˜¯æ ‘çš„ä¸€æ¡ç›´å¾„ è¯æ˜ å½“å­˜åœ¨è´Ÿè¾¹æƒæ—¶ï¼Œç¬¬ä¸€æ¬¡dfsæ‰¾åˆ°çš„ vvv ä¸ä¸€å®šæ˜¯ç›´å¾„çš„ç«¯ç‚¹ï¼Œæ‰€ä»¥è¿™ä¸ªæ–¹æ³•ä¸èƒ½å¤„ç†è´Ÿè¾¹ 123456789101112131415161718void dfs(int u, int fa)&#123; for(int i = head[u]; i; i = e[i].nxt) &#123; int x = e[i].to; if(x == fa) continue; dis[x] = dis[u] + e[i].dis; if(dis[x] &gt; dis[v]) v = x; dfs(x, u); &#125;&#125;int main()&#123; dfs(u, 0); dis[v] = 0; dfs(v, 0); printf(&quot;%d&quot;, dis[v]);&#125; æ ‘å½¢DP 1234567891011121314151617int d1[MAXN], d2[MAXN], d;void dfs(int u, int fa)&#123; d1[u] = d2[u] = 0; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; dfs(v, u); if(d1[v] + e[i].dis &gt; d1[u]) &#123; d2[u] = d1[u]; d1[u] = d1[v] + e[i].dis; &#125;else if(d1[v] + e[i].dis &gt; d2[u]) d2[u] = d1[v] + e[i].dis; &#125; d = max(d, d1[u] + d2[u]);&#125; æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(n)O(n)O(n) P3629 k = 1æ—¶ï¼Œåªè¦æŠŠç›´å¾„çš„ä¸¤ä¸ªç«¯ç‚¹è¿èµ·æ¥å°±è¡Œ ans=(nâˆ’1)âˆ—2âˆ’(dâˆ’1ans = (n-1)*2 - (d-1ans=(nâˆ’1)âˆ—2âˆ’(dâˆ’1) åŠ ä¸€æ¡è¾¹å°±ä¼šå½¢æˆä¸€ä¸ªç¯ï¼Œæˆ‘ä»¬è€ƒè™‘ç¬¬äºŒæ¡è¾¹å½¢æˆçš„ç¯ä¸ç¬¬ä¸€æ¡è¾¹æœ‰æ²¡æœ‰é‡å çš„éƒ¨åˆ† å¦‚æœæ²¡æœ‰çš„è¯ï¼Œç›´æ¥åŠ ä¸Šå°±è¡Œï¼Œå¦‚æœæœ‰çš„è¯ï¼Œé‡å éƒ¨åˆ†å°±éœ€è¦å¤šèµ°ä¸€æ¬¡ å¦‚æœæˆ‘ä»¬ç¬¬ä¸€æ¬¡è·‘ç›´å¾„æ—¶ï¼Œæœªæ¥ä¼šé‡å çš„è¾¹è·‘äº†ä¸€æ¬¡ï¼Œä½†æ˜¯éœ€è¦å¤šè·‘ä¸€æ¬¡ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨ç¬¬äºŒæ¬¡è·‘ç›´å¾„æ—¶ï¼ŒæŠŠé‡å çš„è¾¹çš„æƒå€¼è®¾æˆ -1 ans=(nâˆ’1)âˆ—2âˆ’(d1âˆ’1)âˆ’(d2âˆ’1)=nâˆ—2âˆ’d1âˆ’d2ans = (n - 1)*2 - (d_1-1) - (d_2 -1) = n*2 - d_1 - d_2ans=(nâˆ’1)âˆ—2âˆ’(d1â€‹âˆ’1)âˆ’(d2â€‹âˆ’1)=nâˆ—2âˆ’d1â€‹âˆ’d2â€‹ æ ‘çš„é‡å¿ƒ å½“ä»¥æ ‘ä¸Šä¸€ç‚¹ä¸ºæ ¹æ—¶ï¼Œä»–çš„æ‰€æœ‰å­æ ‘çš„ç»“ç‚¹æ•°çš„æœ€å¤§å€¼æœ€å°ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹å°±æ˜¯æ ‘çš„é‡å¿ƒ ä¹Ÿå°±æ˜¯è¯´é‡å¿ƒæŠŠæ ‘ç›¸å¯¹å¹³å‡çš„åˆ†ä¸ºäº†å‡ ä¸ªéƒ¨åˆ† æ€§è´¨ ä¸€æ£µæ ‘æœ€å¤šæœ‰ä¸¤ä¸ªé‡å¿ƒï¼Œå¦‚æœæœ‰ä¸¤ä¸ªï¼Œè¿™ä¸¤ä¸ªé‡å¿ƒæ˜¯ç›¸é‚»çš„ ä»é‡å¿ƒåˆ°æ‰€æœ‰ç‚¹çš„è·ç¦»å’Œæ˜¯æœ€å°çš„ æ–°åŠ ä¸€ä¸ªèŠ‚ç‚¹æˆ–åˆ å»ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‡å¿ƒæœ€å¤šç§»åŠ¨ä¸€æ¡è¾¹ ä¸¤æ£µæ ‘åˆå¹¶ï¼Œæ–°çš„é‡å¿ƒåœ¨åŸæ¥ä¿©ä¸ªé‡å¿ƒçš„è¿çº¿ä¸Š ä¸ä¼šè¯ï¼Œæ„Ÿæ€§ç†è§£ æˆ‘ä»¬é€‰ä¸€ä¸ªç‚¹ä¸ºæ ¹dfsï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹ä¸‹æ–¹çš„å­æ ‘å¤§å°å’Œç‚¹ä¸Šæ–¹çš„å­æ ‘å¤§å° 1234567891011121314151617181920int zx, sizx = 1145141919;int siz[MAXN], msiz[MAXN];//siz[u] uä¸‹æ–¹å­æ ‘å¤§å°ï¼Œmsiz[u]uæœ€å¤§çš„å­æ ‘å¤§å°void dfs(int u, int fa)&#123; siz[u] = 1; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; dfs(v, u); siz[u] += siz[v]; msiz[u] = max(msiz[u], siz[v]); &#125; msiz[u] = max(msiz[u], n - siz[u]); if(msiz[u] &lt; sizx) sizx = msiz[u];&#125;for(int i = 1; i &lt;= n; i++)&#123; if(msiz[i] == sizx) rt[++cnt] = i;&#125; ğŸŒ³ ä¸Šé—®é¢˜ æœ€è¿‘å…¬å…±ç¥–å…ˆLCA å€å¢ 12345678910111213141516171819void dfs(int u, int dad)&#123; dep[u] = dep[dad] + 1; fa[u][0] = dad; for(int i = 1; i &lt;= l2g[dep[u]]; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for(int i = head[u]; i; i = e[i].nxt) if(e[i].to != dad) dfs(e[i].to, u);&#125;int lca(int x, int y)&#123; if(dep[x] &lt; dep[y]) swap(x, y); while(dep[x] &gt; dep[y]) x = fa[x][l2g[dep[x] - dep[y]] - 1]; if(x == y) return x; for(int k = l2g[dep[x]] - 1; k &gt;= 0; k--) &#123; if(fa[x][k] != fa[y][k]) x = fa[x][k], y = fa[y][k]; &#125; return fa[x][0];&#125; RMQ dfséå†è¿™æ£µæ ‘ï¼Œæ¯åˆ°è¾¾ä¸€ä¸ªèŠ‚ç‚¹å°±è®°å½•ä¸‹æ¥ï¼ˆåŒ…æ‹¬å›æº¯ï¼‰ï¼Œå¾—åˆ°çš„åºåˆ—ç§°ä¸ºæ¬§æ‹‰åº æ¬§æ‹‰åº 1 2 4 2 5 2 1 3 1 ididid è®°å½•èŠ‚ç‚¹ç¬¬ä¸€æ¬¡å‡ºç°åœ¨æ¬§æ‹‰åºçš„ç¼–å· æ‰€ä»¥ä» uuu åˆ° vvv ä¸€å®šç»è¿‡ lca(u,v)lca(u, v)lca(u,v) ä½†ä¸ä¼šç»è¿‡ lca(u,v)lca(u, v)lca(u,v) çš„çˆ¶äº²ï¼Œæ‰€ä»¥ å®ƒä»¬è·¯å¾„é‡ ididid æœ€å°çš„å°±æ˜¯ lcalcalca å…ˆdfsæ±‚å‡ºæ¬§æ‹‰åºå†ç»´æŠ¤åŒºé—´æœ€å€¼å°±è¡Œè¾£ 12345678910111213141516171819202122232425int dfn[N &lt;&lt; 1], dep[N &lt;&lt; 1], T = 0;void dfs(int u, int dp)&#123; dfn[++T] = u; pos[u] = T; dep[T] = dp; for(int i = head[u]; i; i = e[i].nxt) &#123; dfs(e[i].to, dp + 1); dfn[++T] = u; dep[T] = dp; &#125;&#125;void initst()&#123; lg[0] = -1; for(int i = 1; i &lt;= (N &lt;&lt; 1); ++i) lg[i] = lg[i &gt;&gt; 1] + 1; for(int i = 1; i &lt;= (N &lt;&lt; 1) - 1; ++i) st[0][i] = dfn[i]; for(int i = 1; i &lt;= lg[(N &lt;&lt; 1) - 1]; ++i) for(int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= ((N &lt;&lt; 1) - 1); j++) st[i][j] = dep[st[i - 1][j]] &lt; dep[st[i - 1][j + (1 &lt;&lt; i - 1)]] ? st[i - 1][j] : st[i - 1][j + (1 &lt;&lt; i - 1)];&#125; æ ‘å‰– é‡é“¾å‰–åˆ† æŒ‰å­æ ‘å¤§å°åˆ†æˆè½»å„¿å­å’Œé‡å„¿å­ï¼Œé€šå‘é‡å„¿å­çš„è¾¹æ„æˆé‡é“¾ï¼Œè¿™æ ·æŠŠæ ‘æ•´æˆäº†çº¿æ€§ç»“æ„ å›¾ç‰‡æ¥è‡ªoi-wiki ä¸¤æ¬¡dfs 1234567891011121314151617181920212223242526int fa[MAXN], dep[MAXN], siz[MAXN], son[MAXN];// èŠ‚ç‚¹çˆ¶äº² èŠ‚ç‚¹æ·±åº¦ å­æ ‘å¤§å° é‡å„¿å­int id[MAXN], top[MAXN], cnt;// èŠ‚ç‚¹æ–°ç¼–å· é“¾é¡¶èŠ‚ç‚¹void dfs1(int u, int dad)&#123; siz[u] = 1; fa[u] = dad; dep[u] = dep[dad]+1; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == dad) continue; dfs(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; id[u] = ++cnt; if(son[u]) dfs2(son[u], tup); for(int i = head[u]; i; i = e[i].to) &#123; int v = e[i].to; if(v == son[u] || v == fa[u]) continue; dfs2(v, v); &#125;&#125; LCA æ ‘å‰–æ±‚å‡º depdepdep å’Œ toptoptop å¯¹äº uuu å’Œ vvv ï¼Œå¦‚æœä»–ä»¬åœ¨ä¸€æ¡é“¾ä¸Šï¼Œé‚£ä¹ˆå®ƒä»¬é‡æ·±åº¦å°çš„é‚£ä¸ªå°±æ˜¯ lcalcalca å¦‚æœä¸åœ¨ä¸€æ¡é“¾ä¸Šï¼Œé‚£å°±æŠŠæ‰€åœ¨é“¾çš„é“¾é¡¶æ·±åº¦æ·±çš„å‘ä¸Šè·³ï¼Œç›´åˆ°åœ¨ä¸€æ¡é“¾ä¸Š 123456789int lca(int u, int v)&#123; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) u = fa[top[u]]; else v = fa[top[v]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125; P3384 æ ‘å‰–ä¹‹åçº¿æ®µæ ‘ç»´æŠ¤ï¼ŒåŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æ±‚å’Œ P2146","categories":[],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"https://ve1bae.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"ç‚¹åˆ†æ²»","slug":"ç‚¹åˆ†æ²»","permalink":"https://ve1bae.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"æ ‘åŒæ„","slug":"æ ‘åŒæ„","permalink":"https://ve1bae.github.io/tags/%E6%A0%91%E5%90%8C%E6%9E%84/"}]},{"title":"è«é˜Ÿå­¦ä¹ ç¬”è®°","slug":"è«é˜Ÿå­¦ä¹ ç¬”è®°","date":"2022-08-14T00:04:32.000Z","updated":"2022-11-14T11:16:13.036Z","comments":true,"path":"2022/08/14/è«é˜Ÿå­¦ä¹ ç¬”è®°/","link":"","permalink":"https://ve1bae.github.io/2022/08/14/%E8%8E%AB%E9%98%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"æè«é˜Ÿé•¿ç®—æ³•","text":"æè«é˜Ÿé•¿ç®—æ³• è«é˜Ÿæ˜¯ä¸€ç§ ç¦»çº¿ æ•°æ®ç»“æ„ï¼Œè§£å†³åŒºé—´é—®é¢˜çš„æ•°æ®ç»“æ„ï¼Œä¸»è¦çš„æ€æƒ³æ˜¯é€šè¿‡å¯¹åŒºé—´ç¦»çº¿ä¸‹æ¥ï¼Œæ’åºå‡å°‘å·¦å³ç«¯ç‚¹æŒ‡é’ˆçš„ç§»åŠ¨æ¬¡æ•°ï¼Œä»è€Œè¾¾åˆ°ä¼˜é›…çš„æš´åŠ›çš„ç›®çš„ å½“æˆ‘ä»¬çœ‹åˆ°åŒºé—´é—®é¢˜æ— æ³•ç”¨çº¿æ®µæ ‘ç­‰å¸¸è§„æ•°æ®ç»“æ„å¾ˆéš¾ç»´æŠ¤æ—¶ï¼Œä¸å¦¨è€ƒè™‘è«é˜Ÿ ç®—æ³•æµç¨‹å¤§æ¦‚å°±æ˜¯ï¼š å¯¹è¯¢é—®ç¦»çº¿ï¼Œç„¶åæ’åº ç§»åŠ¨å·¦å³ç«¯ç‚¹å¤„ç†è¯¢é—® æ™®é€šè«é˜Ÿ ç®—æ³•æœ¬èº«å¾ˆç®€å•ï¼Œæ‰€ä»¥æˆ‘ä»¬é€šè¿‡ä¾‹é¢˜è®²è§£ å¯¹è¯¢é—®åˆ†å—ï¼Œå—é•¿ n\\sqrt{n}nâ€‹ æŠŠè¯¢é—®æŒ‰å·¦ç«¯ç‚¹æ‰€åœ¨å—æ’åºï¼Œåœ¨ä¸€ä¸ªå—å†…çš„æŒ‰å³ç«¯ç‚¹æ’åºï¼Œå½“åŒºé—´ç§»åŠ¨è®¡ç®—è´¡çŒ®æ˜¯ O(1)O(1)O(1) æ—¶ï¼Œæ•´ä½“ç®—æ³•å¤æ‚åº¦ O(nn)O(n \\sqrt{n})O(nnâ€‹) è¶… ğŸ” åŸºç¡€ P3901 æ•°åˆ—æ‰¾ä¸åŒ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— a1,a2,â€¦,ana_1, a_2, \\dots , a_na1â€‹,a2â€‹,â€¦,anâ€‹ï¼Œæ¯æ¬¡è¯¢é—® [l,r][l, r][l,r] çš„åŒºé—´å†… al,al+1,â€¦,ara_l, a_l+1, \\dots, a_ralâ€‹,alâ€‹+1,â€¦,arâ€‹ æ˜¯å¦äº’ä¸ç›¸åŒ è«é˜Ÿå…¥é—¨é¢˜ï¼Œå¼€ä¸€ä¸ªæ¡¶è®°å½•å½“å‰åŒºé—´æ¯ä¸€ä¸ªæ•°å­—çš„å‡ºç°æ¬¡æ•°ï¼Œç„¶ååœ¨ç»Ÿè®¡åªå‡ºç°ä¸€æ¬¡çš„æ•°çš„ä¸ªæ•°ï¼Œå¦‚æœè¿™ä¸ªè¿™ä¸ªæ¬¡æ•°ç­‰äºåŒºé—´é•¿åº¦å°± Yes ï¼Œå¦åˆ™ No code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int n,m,q,a[MAXN];int size,ans[MAXN];struct node&#123; int l,r,num; friend bool operator &lt; (node x,node y) &#123; if(x.l /size != y.l /size) return x.l/size &lt; y.l/size; else return x.r &lt; y.r; &#125;&#125;que[MAXN];int L,R,cnt,t[MAXN];void add(int x)&#123; if(!t[a[x]]) cnt++; t[a[x]]++;&#125;void del(int x)&#123; if(t[a[x]]==1) cnt--; t[a[x]]--;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); size = pow(n, 0.5); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= m; i++) &#123; que[i].num = i; scanf(&quot;%d%d&quot;, &amp;que[i].l, &amp;que[i].r); &#125; sort(que + 1, que + 1 + m); L = 1; R = 0; for(int i = 1; i &lt;= m; i++) &#123; int l = que[i].l , r = que[i].r; while(L &gt; l) add(--L); while(R &lt; r) add(++R); while(L &lt; l) del(L++); while(R &gt; r) del(R--); if(cnt == (r - l + 1)) ans[que[i].num] = 1; &#125; for(int i = 1; i &lt;= m; i++) &#123; if(ans[i]) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; return 0;&#125; æ³¨æ„å¤„ç†ç«¯ç‚¹ç§»åŠ¨æ—¶çš„é¡ºåºï¼Œæœ‰å¾ˆå¤šæ­£ç¡®çš„å†™æ³•ï¼Œä½†ä¸€èˆ¬ä¿è¯å…ˆåŠ ååˆ  SP3267 DQUERY - D-query ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— a1,a2,â€¦,ana_1, a_2, \\dots , a_na1â€‹,a2â€‹,â€¦,anâ€‹ï¼Œæ¯æ¬¡è¯¢é—® [l,r][l, r][l,r] çš„åŒºé—´å†…æœ‰å¤šå°‘ä¸åŒçš„æ•°å­— å’Œä¸Šä¸€é“é¢˜åŒå€ç»éªŒï¼Œåªè¦è¾“å‡ºåªå‡ºç°ä¸€æ¬¡çš„æ•°çš„ä¸ªæ•°å°±è¡Œè¾£ è¿˜æ˜¯åŸºç¡€ P2709 å°Bçš„è¯¢é—® ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— a1,a2,â€¦,ana_1, a_2, \\dots, a_na1â€‹,a2â€‹,â€¦,anâ€‹ï¼Œå€¼åŸŸä¸º kkk ï¼Œæ¯æ¬¡ç»™å®šä¸€ä¸ªåŒºé—´ [l,r][l, r][l,r]ï¼Œæ±‚ï¼š âˆ‘i=1kcnti2\\sum\\limits_{i = 1}^k cnt_i^2 i=1âˆ‘kâ€‹cnti2â€‹ cnticnt_icntiâ€‹ æŒ‡æ•°å­— iii åœ¨ [l,r][l, r][l,r] åŒºé—´å†…å‡ºç°çš„æ¬¡æ•° ç¨å¾®éœ€è¦ä¸€ç‚¹æ€è€ƒï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ (a+b)2=a2+2ab+b2(ci+1)2âˆ’(ci)2=2Ã—ci+1(a+b)^2 = a^2 + 2ab + b^2 \\\\ (c_i + 1)^2 - (c_i)^2 = 2 \\times c_i + 1 (a+b)2=a2+2ab+b2(ciâ€‹+1)2âˆ’(ciâ€‹)2=2Ã—ciâ€‹+1 code 12345678910void add(int pos)&#123; cnt[a[pos]]++; ANS += 2*cnt[a[pos]]-1;&#125;void del(int pos)&#123; cnt[a[pos]]--; ANS -= 2*cnt[a[pos]]+1;&#125; P1494 å° Z çš„è¢œå­ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ—ï¼Œæ¯ä¸€ä¸ªå…ƒç´ å¯¹åº”ä¸€ä¸ªé¢œè‰²ï¼Œæ¯æ¬¡è¯¢é—®åŒºé—´ [l,r][l, r][l,r] å†…éšæœºé€‰å‡ºä¸¤ä¸ªå…ƒç´ ï¼Œå®ƒé¢œè‰²ç›¸åŒçš„æ¦‚ç‡ é¦–å…ˆï¼Œé€‰å‡ºä¸€ğŸ‘é¢œè‰²çš„æ–¹æ¡ˆæ•° â€‹âˆ‘i=lrcnt[i]âˆ—(cnt[i]âˆ’1)ï¼Œcnt[i]&gt;=2â€‹ \\sum\\limits_{i = l}^{r} cnt[i]âˆ—(cnt[i]âˆ’1)ï¼Œcnt[i]&gt;=2 â€‹i=lâˆ‘râ€‹cnt[i]âˆ—(cnt[i]âˆ’1)ï¼Œcnt[i]&gt;=2 æ€»æ–¹æ¡ˆæ•° C2lenC_{2}^{len} C2lenâ€‹ ç„¶åè€ƒè™‘åŒºé—´ç§»åŠ¨é€ æˆçš„å½±å“ code AnsAnsAns è¡¨ç¤ºé€‰å‡ºç›¸åŒé¢œè‰²çš„æ–¹æ¡ˆæ•°12345678910111213void add(int pos)&#123; ANS -= cnt[a[pos]]*(cnt[a[pos]]-1); cnt[a[pos]]++; ANS += cnt[a[pos]]*(cnt[a[pos]]-1);&#125;void del(int pos)&#123; ANS -= cnt[a[pos]]*(cnt[a[pos]]-1); cnt[a[pos]]--; ANS += cnt[a[pos]]*(cnt[a[pos]]-1);&#125; ä¹±ä¸ƒå…«ç³Ÿ P4462 CQOI2018å¼‚æˆ–åºåˆ— ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn åºåˆ—å’Œ kkk ï¼Œæ¯æ¬¡æŸ¥è¯¢åŒºé—´ [l,r][l, r][l,r] å†…æœ‰å¤šå°‘å­åŒºé—´å¼‚æˆ–å’Œç­‰äº kkk å› ä¸ºè¦å¤„ç†åŒºé—´çš„å¼‚æˆ–å’Œï¼Œè€ƒè™‘å‰ç¼€å’Œï¼Œè¿™æ · âŠ•lr=âŠ•1râˆ§âŠ•1lâˆ’1\\oplus_l^r = \\oplus_1^r \\land \\oplus_1^{l-1}âŠ•lrâ€‹=âŠ•1râ€‹âˆ§âŠ•1lâˆ’1â€‹ é‚£ä¹ˆæ¯åŠ å…¥ä¸€ä¸ªæ•° xxx ï¼Œä¸å®ƒå¯¹ç­”æ¡ˆæœ‰è´¡çŒ®çš„æ•°çš„å‰ç¼€å’Œ yyy ï¼Œä¸€å®šæ˜¯ xâŠ•y=kx \\oplus y = kxâŠ•y=k ï¼Œæ‰€ä»¥æ‰¾å‡ºè¿™æ ·çš„æ•°æœ‰å‡ ä¸ªå°±å¥½äº† code sumsumsum è¡¨ç¤ºå¼‚æˆ–å’Œ12345678910void add(int pos)&#123; ANS += cnt[sum[pos]^k]; cnt[sum[pos]]++;&#125;void del(int pos)&#123; cnt[sum[pos]]--; ANS -= cnt[sum[pos]^k];&#125; åŒå€ç»éªŒ CF617E P3730 è¿™é‡Œç”¨åˆ°äº†è«é˜Ÿå¸¸å¸¸ä¼šä¸€èµ·ç”¨çš„ä¸€ä¸ªä¸œè¥¿ï¼Œå€¼åŸŸåˆ†å—ã€‚å¸¸å¸¸ç”¨æ¥ä¼˜åŒ–æŸ¥è¯¢çš„å¤æ‚åº¦ ç»Ÿè®¡ç­”æ¡ˆæ—¶ï¼Œå¦‚æœä¸€ä¸ªä¸€ä¸ªæšä¸¾çš„è¯ï¼Œè‚¯å®šä¸è¡Œï¼Œæ‰€ä»¥å¯¹æ¡¶ä¹Ÿåˆ†ä¸ªå—ï¼Œä¸€å—ä¸€å—çš„æšä¸¾æ¥æ‰¾åˆ°ç­”æ¡ˆåœ¨å“ªä¸ªå—ã€‚ Code cnt è¡¨ç¤ºç»å…¸æ¡¶ cntt è¡¨ç¤ºå¯¹å‡ºç°æ¬¡æ•°cntå¼€çš„æ¡¶ã€‚cnbt æ˜¯å¯¹ cnt çš„å€¼åŸŸåˆ†å—å¼€çš„æ¡¶1234567891011121314151617181920212223242526272829303132void add(int x)&#123; cntt[cnt[x]]--; cnbt[bel[cnt[x]]]--; cnt[x]++; cnbt[bel[cnt[x]]]++; cntt[cnt[x]]++;&#125;void del(int x)&#123; cntt[cnt[x]]--; cnbt[bel[cnt[x]]]--; cnt[x]--; cnbt[bel[cnt[x]]]++; cntt[cnt[x]]++;&#125;int get_ans(int k)&#123; int i; for (i = 1; i &lt;= cntb; i++) &#123; if (k - cnbt[i] &lt;= 0) break; k -= cnbt[i]; &#125; if (i == cntb + 1) return -1; for (int j = L[i]; j &lt;= R[i]; j++) &#123; if (k - cntt[j] &lt;= 0) return j; k -= cntt[j]; &#125; return 114514;&#125; åŒæ ·å¯ä»¥ è«é˜Ÿ+å€¼åŸŸåˆ†å— çš„é¢˜ P4147 P4396 AHOI2013 åŒæ ·å¯ä»¥å€¼åŸŸåˆ†å—ï¼Œä½†æ˜¯è¿™é‡Œä»‹ç»å¤šä¸ª logloglog çš„åšæ³• ç»å…¸æ¡¶ï¼Œç„¶åæ•´ä¿©å€¼åŸŸæ ‘çŠ¶æ•°ç»„åˆ†åˆ«ç»´æŠ¤ä¸¤ä¸ªç­”æ¡ˆã€‚ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int n, m, a[MAXN], SIZE;#define bel(i) (i / SIZE + 1)struct query&#123; int l, r, a, b, id;&#125;que[MAXN];struct BIt&#123; int lim, t[MAXN]; #define lowbit(i) (i &amp; -i) void init(int x) &#123;lim = x;&#125; void add(int i, int val) &#123; if (!i) return; while (i &lt;= lim) t[i] += val, i += lowbit(i); &#125; int query(int i, int res = 0) &#123; while (i) res += t[i], i -= lowbit(i); return res; &#125;&#125;t1, t2;int cnt[MAXN];void add(int pos)&#123; if (cnt[a[pos]] == 0) t2.add(a[pos], 1); cnt[a[pos]]++; t1.add(a[pos], 1);&#125;void del(int pos)&#123; if (cnt[a[pos]] == 1) t2.add(a[pos], -1); cnt[a[pos]]--; t1.add(a[pos], -1);&#125;int ans1[MAXN], ans2[MAXN];int main()&#123; read(n, m); SIZE = sqrt(n); int mxz = 0; for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt;= m; i++) &#123; int l, r, a, b; read(l, r, a, b); que[i] = &#123;l, r, a - 1, b, i&#125;; mxz = max(&#123;mxz, a, b&#125;); &#125; t1.init(mxz); t2.init(mxz); sort(que + 1, que + 1 + m, [&amp;](query a, query b) &#123; if (bel(a.l) != bel(b.l)) return a.l &lt; b.l; return bel(a.l) &amp; 1 ? a.r &lt; b.r : a.r &gt; b.r; &#125;); int L = 1, R = 0; for (int i = 1; i &lt;= m; i++) &#123; int l = que[i].l, r = que[i].r; while (L &gt; l) add(--L); while (R &lt; r) add(++R); while (L &lt; l) del(L++); while (R &gt; r) del(R--); ans1[que[i].id] = t1.query(que[i].b) - t1.query(que[i].a); ans2[que[i].id] = t2.query(que[i].b) - t2.query(que[i].a); &#125; for (int i = 1; i &lt;= m; i++) print(ans1[i], &#x27; &#x27;), print(ans2[i], &#x27;\\n&#x27;); return 0;&#125; tips ä¸€ä¸ªæœ‰ç‚¹ç”¨çš„ä¼˜åŒ–ã€‚ è€ƒè™‘æˆ‘ä»¬æ­£å¸¸æ’åºçš„ç»“æœï¼Œå³ç«¯ç‚¹æ’äº†åºå¤§æ¦‚æ˜¯è¿™æ ·çš„ã€‚ è¿™æ ·å­å·¦ç«¯ç‚¹åˆ°äº†æ–°å—ä¹‹åï¼Œå³ç«¯ç‚¹å¤§æ¦‚ä¼šç§»åŠ¨å›¾ä¸­çº¢è‰²çš„è·ç¦» æ¢ä¸€ä¸ªæ–¹å¼æ’åºï¼Œå¦‚æœå·¦ç«¯ç‚¹æ˜¯å¥‡æ•°ï¼ŒæŒ‰å³ç«¯ç‚¹å‡åºï¼Œå³ç«¯ç‚¹æ˜¯å¶æ•°ï¼ŒæŒ‰å³ç«¯ç‚¹é™åºã€‚è¿™æ ·ä»¥åå¤§æ¦‚æ˜¯è¿™æ ·çš„ æœ‰ç‚¹æ—¶å€™ä¼˜åŒ–è¿˜æŒºæ˜æ˜¾çš„ï¼Œä¸€èˆ¬å«è¿™ä¸ªå¥‡å¶ä¼˜åŒ– å¸¦ä¿®è«é˜Ÿ æˆ‘ä»¬çŸ¥é“ä¸€èˆ¬ç¦»çº¿ç®—æ³•æ˜¯ä¸èƒ½å¸¦ä¿®çš„ï¼Œä½†æ˜¯å¦‚æœä¿®æ”¹äº§ç”Ÿçš„å½±å“å¯ä»¥æ–¹ä¾¿åˆ é™¤çš„æ·»åŠ åˆ°ç­”æ¡ˆä¸­ä¹Ÿä¸æ˜¯ä¸è¡Œ ä¸€èˆ¬è«é˜Ÿçš„è¯¢é—®éƒ½æœ‰ä¸¤ç»´ï¼Œå¸¦ä¿®è«é˜Ÿå°±å¤šäº†ä¸€ä¸ªæŒ‰ä¿®æ”¹å†³å®šçš„æ—¶é—´ç»´åº¦ï¼Œæ’åºæ—¶æŠŠæ—¶é—´ä½œä¸ºç¬¬ä¸‰å…³é”®å­—æ’åºå³å¯ è¿˜æœ‰å’Œæ™®é€šè«é˜Ÿçš„ä¸ä¸€æ ·çš„å°±æ˜¯ï¼Œè¿™æ¬¡å—é•¿ä¸º n23n^{\\frac{2}{3}}n32â€‹ ï¼Œæ’åºæ˜¯å…ˆæŒ‰å·¦ç«¯ç‚¹æ‰€åœ¨å—æ’åºï¼Œå†æŒ‰å³ç«¯ç‚¹æ‰€åœ¨å—æ’åºï¼Œæœ€åæŒ‰æ—¶é—´æ’åºï¼Œè‡³äºä¸ºä»€ä¹ˆ æˆ‘ä¸åˆ°å•Š æ—¶é—´å¤æ‚åº¦ O(n53)O(n^{\\frac{5}{3}})O(n35â€‹) P1903 æ•°é¢œè‰² ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— a1,a2,â€¦,ana_1, a_2, \\dots , a_na1â€‹,a2â€‹,â€¦,anâ€‹ï¼Œæ¯æ¬¡è¯¢é—® [l,r][l, r][l,r] çš„åŒºé—´å†…æœ‰å¤šå°‘ä¸åŒçš„æ•°å­—ï¼Œå•ç‚¹ä¿®æ”¹ å’Œ SP3267 ç›¸æ¯”ï¼Œå°±æ˜¯å¤šäº†ä¸€ä¸ªä¿®æ”¹æ“ä½œ è€ƒè™‘å¦‚ä½•å®ç°ä¿®æ”¹ï¼Œå®é™…ä¸Šæˆ‘ä»¬åªè¦æŠŠåŸæ¥ä½ç½®æ•°å­—çš„è´¡çŒ®åˆ æ‰ï¼Œå†åŠ å…¥æ–°æ•°å­—äº§ç”Ÿçš„è´¡çŒ®å°±è¡Œè¾£è¿˜è¦è€ƒè™‘çš„å°±æ˜¯æˆ‘ä»¬æ’åºæ—¶ï¼Œæ—¶é—´æ˜¯ç¬¬ä¸‰å…³é”®å­—ï¼Œæ‰€ä»¥ä¼šå‡ºç°ä¿®æ”¹å®Œå†ä¿®æ”¹å›å»çš„æƒ…å†µï¼Œå¦‚ä½•å®ç°è¿™æ ·ä¸€ä¸ªå›æº¯çš„è¿‡ç¨‹å‘¢ï¼Œæœ‰ä¸€ä¸ªå·§å¦™çš„åšæ³• code 1234567891011121314151617181920212223242526272829303132333435363738394041for(int i = 1;i &lt;= m;i++)&#123; char o; int a,b; scanf(&quot;%c %d %d&quot;, &amp;o, &amp;a, &amp;b); if(o == &#x27;Q&#x27;) &#123; cntq++; que[cntq].l = a; que[cntq].r = b; que[cntq].num = cntq; que[cntq].t = cntc; &#125; else &#123; cntc++; c[cntc].pos = a; c[cntc].val = b; &#125;&#125;void change(int now)&#123; if(c[now].pos &gt;= L &amp;&amp; c[now].pos &lt;= R) //å¦‚æœä¿®æ”¹ä½ç½®å¯¹ç­”æ¡ˆæœ‰è´¡çŒ® &#123; del(a[c[now].pos]); //åˆ å»åŸæ¥è´¡çŒ® add(c[now].val); //æ·»åŠ ç°åœ¨è´¡çŒ® &#125; swap(c[now].val,a[c[now].pos]); //æŠŠç°åœ¨çš„å€¼å’Œè¦ä¿®æ”¹çš„å€¼äº¤æ¢ï¼Œä»¥ä¾¿å›æº¯&#125;for(int i = 1;i &lt;= cntq;i++)&#123; int l = que[i].l , r = que[i].r , t = que[i].t; while(L &gt; l) add(a[--L]); while(R &lt; r) add(a[++R]); while(L &lt; l) del(a[L++]); while(R &gt; r) del(a[R--]); while(T &lt; t) change(++T); //ä¿®æ”¹æ—¶é—´ç»´åº¦ while(T &gt; t) change(T--); ans[que[i].num] = ANS;&#125; åŒå€ç»éªŒ UVA12345 CF940F Machine Learning ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— a1,a2,â€¦,ana_1, a_2, \\dots , a_na1â€‹,a2â€‹,â€¦,anâ€‹ï¼Œæ¯æ¬¡è¯¢é—® [l,r][l, r][l,r] åŒºé—´æ•°å­—å‡ºç°æ¬¡æ•°çš„ mexmexmex ï¼Œå•ç‚¹ä¿®æ”¹ mexmexmex æŒ‡çš„æ˜¯ä¸€äº›æ•°å­—é‡Œæ²¡æœ‰å‡ºç°çš„æœ€å°çš„è‡ªç„¶æ•° å’Œä¸Šé¢æœ‰é“é¢˜ä¸€æ ·ï¼Œæ‚¨ä¹Ÿå¯ä»¥å€¼åŸŸåˆ†å—ï¼Œä½†æ˜¯è¿™ä¸ªé¢˜æ•°æ®æ¯”è¾ƒæ°´ã€‚å¯ä»¥ç›´æ¥æš´åŠ›æ±‚ mexmexmex for(ANS = 1;cntt[ANS] &gt; 0;ANS++); ans[que[i].num] = ANS; è¿˜æœ‰å°±æ˜¯è®°å¾—ç¦»æ•£åŒ–ä¸€ä¸‹ å›æ»šè«é˜Ÿ å›æ»šè«é˜Ÿï¼Œåªä¸åˆ é™¤æˆ–ä¸æ·»åŠ çš„è«é˜Ÿæ¯”å¦‚è¯´è¿™é“é¢˜ JOISC2014 ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nnn çš„åºåˆ— a1,a2,â€¦,ana_1, a_2, \\dots , a_na1â€‹,a2â€‹,â€¦,anâ€‹ï¼Œæ¯æ¬¡è¯¢é—® [l,r][l, r][l,r] åŒºé—´æ•°å­—æœ€å¤§çš„é‡è¦åº¦ã€‚å®šä¹‰ä¸€ä¸ªæ•°å­— xxx çš„é‡è¦åº¦ä¸º xÃ—cntxx \\times cnt_xxÃ—cntxâ€‹ æ˜æ˜¾ä¸èƒ½åƒæ™®é€šè«é˜Ÿä¸€æ ·ç›´æ¥åŒºé—´ç§»åŠ¨ï¼Œå› ä¸ºåˆ é™¤ä¸€ä¸ªæ•°çš„è´¡çŒ®å¾ˆéš¾ç»´æŠ¤ï¼Œæ‰€ä»¥è€ƒè™‘é¿å…åˆ é™¤æ“ä½œã€‚ æˆ‘ä»¬å¯ä»¥å¤‡ä»½ä¸€ä¸ªç‰ˆæœ¬çš„ç­”æ¡ˆï¼Œç„¶åé€šè¿‡å›æº¯åˆ°è¿™ä¸ªç‰ˆæœ¬æ¥å®ç°åˆ é™¤ äºæ˜¯æœ‰äº†è¿™æ ·ä¸€ä¸ªæ€è·¯ï¼š å¯¹è¯¢é—®åˆ†å—ï¼Œå·¦ç«¯ç‚¹ä¸€ä¸ªå—å†…æŒ‰å³ç«¯ç‚¹æ’åºï¼Œå¦åˆ™æŒ‰å·¦ç«¯ç‚¹æ‰€åœ¨å—æ’åº å¦‚æœè¯¢é—®åœ¨ä¸€ä¸ªå—å†…ï¼Œç›´æ¥æš´åŠ›ï¼Œå› ä¸ºå—é•¿æœ€å¤š n\\sqrt{n}nâ€‹ ï¼Œå•æ¬¡è¯¢é—® O(n)O(\\sqrt n)O(nâ€‹) æ¯å½“å·¦ç«¯ç‚¹ç§»åŠ¨ä¸€ä¸ªæ•´å—ï¼Œå°±åˆå§‹åŒ– L ä¸ºå—çš„å·¦ç«¯ç‚¹ï¼ŒR ä¸ºå—çš„å·¦ç«¯ç‚¹å‡ä¸€ï¼ŒåŸç†å’Œæ™®é€šè«é˜Ÿçš„ L = 1, R = 0 ä¸€æ · æˆ‘ä»¬è¯¢é—®ä¿è¯äº†åŒä¸€ä¸ªå—å†…çš„å³ç«¯ç‚¹å•è°ƒå¢ï¼Œæ‰€ä»¥ä¸ç”¨åˆ é™¤å³ç«¯ç‚¹ç§»åŠ¨äº§ç”Ÿçš„è´¡çŒ®ï¼Œä½†æ˜¯å·¦ç«¯ç‚¹ä¸ä¸€æ ·ï¼Œæ‰€ä»¥å¤‡ä»½å·¦ç«¯ç‚¹ç­”æ¡ˆï¼Œæ·»åŠ åå›æº¯ ã€‚ä¹Ÿå¯ä»¥è¯´åˆ›é€ ä¸€ä¸ªå·¥å…·äººå­˜æ¡£ï¼Œç”¨å®ƒå»å¤„ç†å·¦ç«¯ç‚¹çš„ç§»åŠ¨ code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103int n, m, SIZE;int a[MAXN], h[MAXN];int bel[MAXN];namespace BLOCK //åˆ†å—é¢„å¤„ç†&#123; int cnt; int L[MAXN], R[MAXN]; void pre_block() &#123; SIZE = sqrt(n); cnt = n / SIZE; for (int i = 1; i &lt;= cnt; i++) &#123; L[i] = R[i-1]+1; R[i] = i * SIZE; &#125; if(R[cnt] &lt; n) &#123; L[cnt+1] = R[cnt]+1; R[cnt+1] = n; cnt++; &#125; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = L[i]; j &lt;= R[i]; j++) bel[j] = i; &#125; &#125; #define BK BLOCK&#125;int L = 1, R = 0; ll Ans; ll ans[MAXN];int cnt[MAXN], cut[MAXN];// ä¸€ä¸ªç»´æŠ¤åŒºé—´ç§»åŠ¨ï¼Œä¸€ä¸ªç»´æŠ¤åŒä¸€ä¸ªå—å†…çš„æš´åŠ›void pre_lsh()// å€¼åŸŸ 1e9,ç»å…¸ç¦»æ•£åŒ–&#123; sort(h + 1, h + 1 + n); int len = unique(h+1, h+1+n) - h - 1; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(h+1, h+1+len, a[i]) - h;&#125;void add(int pos, ll &amp;res)// åŠ è´¡çŒ®&#123; cnt[a[pos]]++; res = max(res, cnt[a[pos]] * 1LL * h[a[pos]]);&#125;void del(int pos)// åˆ è´¡çŒ®&#123; cnt[a[pos]]--;&#125;int main()&#123; n = read(); m = read(); for (int i = 1; i &lt;= n; i++) a[i] = h[i] = read(); BK::pre_block(); pre_lsh(); for (int i = 1; i &lt;= m; i++) &#123; q[i].l = read(); q[i].r = read(); q[i].id = i; &#125; sort(q + 1, q + 1 + m, cmp); int last = 0; // ä¸Šä¸€ä¸ªè¯¢é—®å·¦ç«¯ç‚¹æ‰€åœ¨å— for (int i = 1; i &lt;= m; i++) &#123; int l = q[i].l, r = q[i].r; if (bel[l] == bel[r]) // ä¸€ä¸ªå—å†…ï¼Œç›´æ¥æš´åŠ› &#123; for (int j = l; j &lt;= r; j++) &#123; cut[a[j]]++; ans[q[i].id] = max(ans[q[i].id], h[a[j]]*1LL*cut[a[j]]); &#125; for (int j = l; j &lt;= r; j++) cut[a[j]]--; continue; &#125; if (bel[l] != last) // åˆ°è¾¾æ–°å—ï¼Œåˆå§‹åŒ– &#123; while(R &gt; BK::R[bel[l]]) del(R--); while(L &lt; BK::R[bel[l]]+1) del(L++); Ans = 0; last = bel[l]; &#125; while (R &lt; r) add(++R, Ans); // æ·»åŠ å³ç«¯ç‚¹ int LL = L; ll res = Ans; // å¤‡ä»½ç­”æ¡ˆï¼Œå¤„ç†å·¦ç«¯ç‚¹çš„ç§»åŠ¨ while (LL &gt; l) add(--LL, res); while (LL &lt; L) del(LL++); // åˆ é™¤å·¦ç«¯ç‚¹ ans[q[i].id] = res; &#125; for (int i = 1 ; i &lt;= m; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;&#125; æ ‘ä¸Šè«é˜Ÿ è¿™é‡Œä»‹ç»ä½¿ç”¨æ‹¬å·åºçš„æ ‘ä¸Šè«é˜Ÿ æˆ‘ä»¬çŸ¥é“è«é˜Ÿå’Œå…³é”®æ‰€åœ¨æ˜¯åŒºé—´ç«¯ç‚¹çš„ç§»åŠ¨ï¼Œæ‰€ä»¥å¾—æŠŠæ•°æ•´åˆ°åºåˆ—ä¸Šå»ï¼Œè€ƒè™‘ä¸€æ£µæ ‘çš„æ‹¬å·åº è¿™æ£µæ ‘çš„æ‹¬å·åºæ˜¯ 1 3 5 5 7 7 6 6 3 4 8 8 4 2 2 1 å¯ä»¥å‘ç°çš„æ˜¯æ¯ä¸ªèŠ‚ç‚¹éƒ½åœ¨æ‹¬å·åºä¸Šå‡ºç°äº†ä¸¤æ¬¡ï¼Œè€Œä¸”å®ƒå‡ºç°çš„ä¸¤ä¸ªä½ç½®ä¹‹é—´æ˜¯å®ƒçš„å­æ ‘ã€‚ é‚£ä¹ˆä¸¤ä¸ªèŠ‚ç‚¹æ‹¬å·åºä¹‹é—´å¯èƒ½ä¼šå‡ºç°æŸ¥è¯¢çš„èŠ‚ç‚¹çš„å…„å¼ŸèŠ‚ç‚¹ï¼Œè€Œè¿™äº›èŠ‚ç‚¹æ˜¯ä¸éœ€è¦çš„ã€‚ä½†æ˜¯æ˜¯ dfs åºï¼Œé‚£ä¹ˆè¿™äº›èŠ‚ç‚¹è¦ä¹ˆä¸ä¼šå‡ºç°ï¼Œè¦ä¹ˆå‡ºç°æ°å¥½ä¸¤æ¬¡ã€‚è€Œä¸”ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æ‹¬å·åºæ˜¯ä¸å«æœ‰ä»–ä»¬çš„ LCA çš„ æ¯”å¦‚è¯´æˆ‘ä»¬è¦æŸ¥è¯¢èŠ‚ç‚¹ 7 å’Œ èŠ‚ç‚¹ 4 ä¹‹é—´ï¼Œåæ˜ åˆ°æ‹¬å·åºä¸Šå°±æ˜¯ 7 6 6 3 4 ä½†å®é™…ä¸Šåº”è¯¥æœ‰ 7 3 1 4 è¿™äº›èŠ‚ç‚¹ ç¼ºå°‘äº†å®ƒä»¬çš„ LCA ï¼Œè€Œä¸”å¤šäº†èŠ‚ç‚¹ 6 ï¼Œå‘ç°åƒ 6 è¿™æ ·å¤šå‡ºæ¥çš„èŠ‚ç‚¹ä¸€å®šä¼šå‡ºç°ä¸¤æ¬¡ï¼Œä¸å¦¨å°†è®¡å°±è®¡ï¼Œå¯ä»¥æ‰“ä¸€ä¸ªæ ‡è®°ï¼Œç¬¬ä¸€æ¬¡å‡ºç°å°±åŠ è´¡çŒ®ï¼Œç¬¬äºŒæ¬¡å‡ºç°å°±åˆ è´¡çŒ®ï¼Œç„¶åå†ç‰¹åˆ¤ LCA è¿˜æœ‰å°±æ˜¯å¦‚æœè¯¢é—®çš„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹ä¸€å°±æ˜¯ä»–ä»¬çš„ LCA çš„è¯ï¼Œæ‹¬å·åºä¸Šæ˜¯åŒ…å« LCA çš„ï¼Œç‰¹åˆ¤ä¸€ä¸‹ SP10707 Count on a tree II ç»™å®š nnn ä¸ªç»“ç‚¹çš„æ ‘ï¼Œæ¯ä¸ªç»“ç‚¹æœ‰ä¸€ç§é¢œè‰²ã€‚ mmm æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ç»™å‡º u,vu,vu,v ï¼Œå›ç­” u,vu,vu,v ä¹‹é—´çš„è·¯å¾„ä¸Šçš„ç»“ç‚¹çš„ä¸åŒé¢œè‰²æ•°ã€‚ çº¯çº¯æ»´æ¿å­é¢˜ç»“åˆä»£ç ç†è§£ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138int n, m, SIZE;int a[MAXN], b[MAXN];int bel[MAXN];struct query&#123; int l, r, u, v, id, lca;&#125;que[MAXM];bool cmp(query a, query b)&#123; if (bel[a.l] != bel[b.l]) return bel[a.l] &lt; bel[b.l]; if (bel[a.l] % 2) return a.r &lt; b.r; else return a.r &gt; b.r; &#125;vector &lt;int&gt; e[MAXN];int euler_cnt;int euler[MAXN*2], in[MAXN], out[MAXN];int siz[MAXN], dep[MAXN], fa[MAXN], top[MAXN], son[MAXN];// dfs æ•´æ‹¬å·åºï¼Œé¡ºä¾¿æ ‘å‰–LCAvoid dfs1(int u, int dad)&#123; euler[in[u] = ++euler_cnt] = u; // æ‹¬å·åºä¸­ç¬¬ä¸€æ¬¡å‡ºç° fa[u] = dad; siz[u] = 1; dep[u] = dep[dad] + 1; for (int v : e[u]) if (v != dad) &#123; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; &#125; euler[out[u] = ++euler_cnt] = u; // æ‹¬å·åºä¸­ç¬¬äºŒæ¬¡å‡ºç°&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if (son[u]) dfs2(son[u], tup); for (int v : e[u]) if (v != son[u] &amp;&amp; v != fa[u]) &#123; dfs2(v, v); &#125;&#125;int LCA(int u, int v)&#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;int L = 1, R = 0, Ans;int cnt[MAXM];int vis[MAXN]; // è®°å½•ç¬¬ä¸€æ¬¡è¿˜æ˜¯ç¬¬äºŒæ¬¡void add(int pos)&#123; cnt[a[pos]]++; if (cnt[a[pos]] == 1) Ans++;&#125;void del(int pos)&#123; cnt[a[pos]]--; if (cnt[a[pos]] == 0) Ans--;&#125;void change(int pos)&#123; int u = euler[pos]; vis[u] ? del(u) : add(u); vis[u] ^= 1;&#125;int ans[MAXM];int main()&#123; read(n, m); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); b[i] = a[i]; &#125; // ç¦»æ•£åŒ– sort(b + 1, b + 1 + n); int len = unique(b + 1, b + 1 + n) - b - 1; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b; for (int i = 1; i &lt; n; i++) &#123; int u, v; read(u, v); e[u].push_back(v); e[v].push_back(u); &#125; dfs1(1, 0); dfs2(1, 1); SIZE = pow(euler_cnt, 0.5); // æ‹¬å·åºä¸Šè«é˜Ÿï¼Œæ³¨æ„å—é•¿ for (int i = 1; i &lt;=euler_cnt; i++) bel[i] = i / SIZE + 1; for (int i = 1; i &lt;= m; i++) &#123; int u, v; read(u, v); que[i].id = i; if (in[u] &gt; in[v]) swap(u, v); // å…ˆåé¡ºåº que[i].u = u; que[i].v = v; // æ ¹æ® LCA åˆ†æƒ…å†µ if (u == LCA(u, v)) &#123; que[i].l = in[u]; que[i].r = in[v]; que[i].lca = 0; &#125; else &#123; que[i].l = out[u]; que[i].r = in[v]; que[i].lca = LCA(u, v); &#125; &#125; sort(que+1, que+1+m, cmp); for (int i = 1; i &lt;= m; i++) &#123; int l = que[i].l, r = que[i].r; while (L &gt; l) change(--L); while (L &lt; l) change(L++); while (R &lt; r) change(++R); while (R &gt; r) change(R--); // ç‰¹åˆ¤ LCA if (que[i].lca) change(in[que[i].lca]); ans[que[i].id] = Ans; if (que[i].lca) change(in[que[i].lca]); &#125; for (int i = 1; i &lt;= m; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; P4074 WC2013 ç³–æœå…¬å›­ ç³–æœå…¬å›­çš„ç»“æ„ååˆ†å¥‡ç‰¹ï¼Œå½¢å¼åŒ–ä¸ºä¸€æ£µ nnn ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œä¸€å…±æœ‰ mmm ç§ç³–æœï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ç§ç³–æœ CiC_iCiâ€‹æ¥åˆ°å…¬å›­é‡Œæ¸¸ç©çš„æ¸¸å®¢éƒ½ä¸å–œæ¬¢èµ°å›å¤´è·¯ï¼Œä»–ä»¬æ€»æ˜¯ä»æŸä¸ªç‰¹å®šçš„æ¸¸è§ˆç‚¹å‡ºå‘å‰å¾€å¦ä¸€ä¸ªç‰¹å®šçš„æ¸¸è§ˆç‚¹ï¼Œå¹¶æ¸¸è§ˆé€”ä¸­çš„æ™¯ç‚¹ï¼Œè¿™æ¡è·¯çº¿ä¸€å®šæ˜¯å”¯ä¸€çš„ã€‚ä»–ä»¬ç»è¿‡æ¯ä¸ªæ¸¸è§ˆç‚¹ï¼Œéƒ½å¯ä»¥å“å°åˆ°ä¸€é¢—å¯¹åº”ç§ç±»çš„ç³–æœã€‚æ ¹æ®æ¸¸å®¢ä»¬çš„åé¦ˆæ‰“åˆ†ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ç³–æœçš„ç¾å‘³æŒ‡æ•°ï¼Œ ç¬¬ iii ç§ç³–æœçš„ç¾å‘³æŒ‡æ•°ä¸º ViV_iViâ€‹ã€‚å¦å¤–ï¼Œå¦‚æœä¸€ä½æ¸¸å®¢åå¤åœ°å“å°åŒä¸€ç§ç±»çš„ç³–æœï¼Œä»–è‚¯å®šä¼šè§‰å¾—æœ‰ä¸€äº›è…»ã€‚æ ¹æ®é‡åŒ–ç»Ÿè®¡ï¼Œæˆ‘ä»¬å¾—åˆ°äº†æ¸¸å®¢ç¬¬ iii æ¬¡å“å°æŸç±»ç³–æœçš„æ–°å¥‡æŒ‡æ•° WiW_iWiâ€‹ã€‚å¦‚æœä¸€ä½æ¸¸å®¢ç¬¬ iii æ¬¡å“å°ç¬¬ jjj ç§ç³–æœï¼Œé‚£ä¹ˆä»–çš„æ„‰æ‚¦æŒ‡æ•° HHH å°†ä¼šå¢åŠ å¯¹åº”çš„ç¾å‘³æŒ‡æ•°ä¸æ–°å¥‡æŒ‡æ•°çš„ä¹˜ç§¯ï¼Œå³ VjV_jVjâ€‹Ã—WiW_iWiâ€‹ã€‚è¿™ä½æ¸¸å®¢æ¸¸è§ˆå…¬å›­çš„æ„‰æ‚¦æŒ‡æ•°æœ€ç»ˆå°†æ˜¯è¿™äº›ä¹˜ç§¯çš„å’Œã€‚ç³–æœå…¬å›­çš„å·¥ä½œäººå‘˜å° A æ¥åˆ°äº†ä¸€ä¸ªä»»åŠ¡ï¼Œé‚£å°±æ˜¯æ ¹æ®å…¬å›­æœ€è¿‘çš„æ•°æ®ç»Ÿè®¡å‡ºæ¯ä½æ¸¸å®¢æ¸¸ç©å…¬å›­çš„æ„‰æ‚¦æŒ‡æ•°ã€‚ä½†æ•°å­¦ä¸å¥½çš„å° A ä¸€çœ‹åˆ°å¯†å¯†éº»éº»çš„æ•°å­—å°±è§‰å¾—å¤´æ™•ï¼Œä½œä¸ºå° A æœ€å¥½çš„æœ‹å‹ï¼Œä½ å†³å®šå¸®ä»–ä¸€æŠŠã€‚ å½¢å¼åŒ–ä¸€ä¸‹ï¼ŒæŸ¥è¯¢ä¸€æ¡è·¯å¾„ä¸Šçš„ âˆ‘itotviÃ—âˆ‘jcntiwj\\sum\\limits_{i}^{tot} v_i \\times \\sum\\limits_{j}^{cnt_i}w_jiâˆ‘totâ€‹viâ€‹Ã—jâˆ‘cntiâ€‹â€‹wjâ€‹ tottottot è¡¨ç¤ºè·¯å¾„ä¸Šä¸€å…±å‡ºç°äº†å‡ ç§é¢œè‰²ï¼Œcnticnt_icntiâ€‹ è¡¨ç¤ºç¬¬ iii ç§é¢œè‰²å‡ºç°äº†å‡ æ¬¡ æ ‘ä¸Šå¸¦ä¿®è«é˜Ÿï¼Œå½“ä½œæ¿å­å§ å•ç‚¹çš„è´¡çŒ®åŠ å‡ä¹Ÿå¾ˆå¥½ç»´æŠ¤ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112int n, m, q, SIZE;int a[MAXN];int v[MAXN], w[MAXN], c[MAXN];vector &lt;int&gt; e[MAXN];int euler[MAXN * 2], euler_cnt;int in[MAXN], out[MAXN];int siz[MAXN], son[MAXN], dep[MAXN];int top[MAXN], fa[MAXN];void dfs1(int u, int dad)&#123; fa[u] = dad; dep[u] = dep[dad] + 1; siz[u] = 1; euler[in[u] = ++euler_cnt] = u; for (int v : e[u]) if (v != dad) &#123; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; &#125; euler[out[u] = ++euler_cnt] = u;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if(son[u]) dfs2(son[u], tup); for (int v : e[u]) if (v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v);&#125;int LCA(int u, int v)&#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;int cntq, cntc;struct query &#123; int l, r, u, v, lca, t, id; &#125;que[MAXN];struct modify &#123; int pos, val; &#125;mdf[MAXN];bool cmp (query a, query b)&#123; if (a.l / SIZE != b.l / SIZE) return a.l / SIZE &lt; b.l / SIZE; if (a.r / SIZE != b.r / SIZE) return a.r &lt; b.r; return a.t &lt; b.t;&#125;int cnt[MAXN], vis[MAXN];int L = 1, R = 0, T;ll Ans, ans[MAXN];void add(int pos) &#123; Ans += 1LL * v[c[pos]] * w[++cnt[c[pos]]]; &#125;void del(int pos) &#123; Ans -= 1LL * v[c[pos]] * w[cnt[c[pos]]--]; &#125;void work(int pos) &#123; vis[pos] ? del(pos) : add(pos); vis[pos] ^= 1; &#125;void change(int T)&#123; int pos = mdf[T].pos; if (vis[pos]) &#123; work(pos); swap(mdf[T].val, c[pos]); work(pos); &#125; else swap(mdf[T].val, c[pos]);&#125;int main()&#123; read(n, m, q); for (int i = 1; i &lt;= m; i++) read(v[i]); for (int i = 1; i &lt;= n; i++) read(w[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); e[u].push_back(v); e[v].push_back(u); &#125; for (int i = 1; i &lt;= n; i++) read(c[i]); dfs1(1, 0); dfs2(1, 1); SIZE = pow(euler_cnt, 0.66666667); for (int i = 1; i &lt;= q; i++) &#123; int op, x, y; read(op, x, y); if (op == 1) &#123; cntq++; if (in[x] &gt; in[y]) swap(x, y); int lca = LCA(x, y); if (x == lca) que[cntq] = &#123; in[x], in[y], x, y, 0 , cntc, cntq&#125;; else que[cntq] = &#123; out[x], in[y], x, y, lca, cntc, cntq&#125;; &#125; else &#123; mdf[++cntc] = &#123;x, y&#125;; &#125; &#125; sort(que+1, que+1+cntq, cmp); for (int i = 1; i &lt;= q; i++) &#123; int l = que[i].l, r = que[i].r, t = que[i].t; while (L &gt; l) work(euler[--L]); while (L &lt; l) work(euler[L++]); while (R &lt; r) work(euler[++R]); while (R &gt; r) work(euler[R--]); while (T &lt; t) change(++T); while (T &gt; t) change(T--); if (que[i].lca) work(que[i].lca); ans[que[i].id] = Ans; if (que[i].lca) work(que[i].lca); &#125; for (int i = 1; i &lt;= cntq; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"å¤šé¡¹å¼","slug":"å¤šé¡¹å¼","date":"2022-07-21T00:05:20.000Z","updated":"2022-11-08T07:43:39.627Z","comments":true,"path":"2022/07/21/å¤šé¡¹å¼/","link":"","permalink":"https://ve1bae.github.io/2022/07/21/%E5%A4%9A%E9%A1%B9%E5%BC%8F/","excerpt":"å¤šé¡¹å¼å¤šé¡¹å¼å¤šé¡¹å¼å¤šåƒğŸ’©å¤šé¡¹å¼å¤šé¡¹å¼å¤šé¡¹å¼","text":"å¤šé¡¹å¼å¤šé¡¹å¼å¤šé¡¹å¼å¤šåƒğŸ’©å¤šé¡¹å¼å¤šé¡¹å¼å¤šé¡¹å¼ ä¸€äº›å®šä¹‰ å•ä½æ ¹ xn=1x^n = 1xn=1 åœ¨å¤æ•°åŸŸå†…çš„nä¸ªè§£ï¼Œæˆ‘ä»¬æŠŠè¿™äº›è§£ç§°ä¸ºå•ä½æ ¹ wnkw_{n}^{k}wnkâ€‹ å…¶ä¸­ kâˆˆ[0,nâˆ’1]k \\in [0, n-1]kâˆˆ[0,nâˆ’1] ï¼Œå•ä½æ ¹æŠŠå•ä½åœ†nç­‰åˆ† å•ä½æ ¹çš„æ€§è´¨ wnn=1w_n^n = 1wnnâ€‹=1 wnk+n=wnkw_n^{k+n} = w_n^{k}wnk+nâ€‹=wnkâ€‹ ç”»å›¾ç†è§£ wnk+n2=âˆ’wnkw_n^{k+\\frac{n}{2}} = -w_n^kwnk+2nâ€‹â€‹=âˆ’wnkâ€‹ ç”»å›¾ç†è§£ wdkdk=wnkw_{dk}^{dk} = w_n^{k}wdkdkâ€‹=wnkâ€‹ çº¦åˆ†ï¼Ÿ å•ä½æ ¹åæ¼” [kâˆ£n]=1kâˆ‘i=0kâˆ’1wkni[k \\mid n] = \\frac{1}{k}\\sum\\limits_{i = 0}^{k-1} w_k^{ni} [kâˆ£n]=k1â€‹i=0âˆ‘kâˆ’1â€‹wkniâ€‹ å¤šé¡¹å¼çš„è¡¨ç¤º å¯¹äºä¸€ä¸ªå¤šé¡¹å¼ f(x)=âˆ‘i=0naixif(x) = \\sum\\limits_{i = 0}^n a_ix^if(x)=i=0âˆ‘nâ€‹aiâ€‹xi æˆ‘ä»¬å¯ä»¥é€šè¿‡ç³»æ•°å³ (a0,a1,a2,..,an)(a_0,a_1,a_2,..,a_n)(a0â€‹,a1â€‹,a2â€‹,..,anâ€‹) è¡¨ç¤ºè¿™ä¸ªå¤šé¡¹å¼ ç§°ä¸º ç³»æ•°è¡¨ç¤º è¿˜æœ‰ä¸€ç§è¡¨ç¤ºï¼Œå«åš ç‚¹å€¼è¡¨ç¤º æˆ‘ä»¬çŸ¥é“å¯¹äºä¸€ä¸ª nnn æ¬¡å¤šé¡¹å¼ å®ƒå¯ä»¥ç”± n+1n+1n+1 ä¸ªå¤šé¡¹å¼ä¸Šçš„ç‚¹å€¼ç¡®å®š å°±æ˜¯ç”¨è¿™ n+1n+1n+1 ä¸ªç‚¹å€¼æ¥è¡¨ç¤ºè¿™ä¸ªå¤šé¡¹å¼ FFT å¯ä»¥å¿«é€Ÿè§£å†³å¤šé¡¹å¼ä¹˜æ³•é—®é¢˜ ä¾‹å¦‚ A(x)âˆ—B(x)=C(x)A(x)*B(x) = C(x)A(x)âˆ—B(x)=C(x) é‚£ä¹ˆ C(x)C(x)C(x) çš„æ¬¡æ•°å°±æ˜¯ AAA å’Œ bbb åŠ èµ·æ¥ å…ˆæ•´ç‚¹æœ´ç´ çš„å—· ä¸€é¡¹ä¸€é¡¹ä¹˜ä¸Šå»çš„å¤æ‚åº¦ä¸º O(n2)O(n^2)O(n2) æˆ‘ä»¬éœ€è¦è¿›è¡Œä¸€äº›ä¼˜åŒ– è€ƒè™‘ç”¨ç‚¹å€¼æ¥æ“ä½œ ç”¨ç‚¹ç—£è¡¨ç¤º AAA å’Œ BBB A(x)={(x0,A(x0)),(x1,A(x0)),(x2,A(x2)),...,(xn,A(xn))}B(x)={(x0,B(x0)),(x1,B(x0)),(x2,B(x2)),...,(xn,B(xn))}A(x) = \\left\\{ (x_0,A(x_0)), (x_1,A(x_0)), (x_2,A(x_2)), ...,(x_n,A(x_n))\\right\\}\\\\ B(x) = \\left\\{ (x_0,B(x_0)), (x_1,B(x_0)), (x_2,B(x_2)), ...,(x_n,B(x_n)) \\right\\} A(x)={(x0â€‹,A(x0â€‹)),(x1â€‹,A(x0â€‹)),(x2â€‹,A(x2â€‹)),...,(xnâ€‹,A(xnâ€‹))}B(x)={(x0â€‹,B(x0â€‹)),(x1â€‹,B(x0â€‹)),(x2â€‹,B(x2â€‹)),...,(xnâ€‹,B(xnâ€‹))} é‚£ä¹ˆ C(x)={(x0,A(x0)âˆ—B(x0)),...,((xn+m),A(xn+m)âˆ—B(xn+m))}C(x) = \\left\\{ (x_0,A(x_0)*B(x_0)),...,((x_{n+m}),A(x_{n+m})*B(x_{n+m})) \\right\\} C(x)={(x0â€‹,A(x0â€‹)âˆ—B(x0â€‹)),...,((xn+mâ€‹),A(xn+mâ€‹)âˆ—B(xn+mâ€‹))} æ‰€ä»¥æˆ‘ä»¬ç°åœ¨å¯ä»¥åœ¨ O(n)O(n)O(n) çš„æ—¶é—´å†…è®¡ç®—äº† æˆ‘ä»¬è¿˜éœ€è¦æŠŠç³»æ•°è¡¨ç¤ºæ¢ä½ç‚¹å€¼è¡¨ç¤º å†æŠŠç»“æœçš„ç‚¹å€¼è¡¨ç¤ºæ¢ä½ç³»æ•°è¡¨ç¤º ç¬¬ä¸€æ­¥ DFT ç³»æ•° â†’\\rightarrowâ†’ ç‚¹å€¼ æŠŠé¡¹æ•°æŒ‰å¥‡å¶åˆ†å¼€è€ƒè™‘ \\begin{align} A(x) &amp;= \\sum\\limits_{i = 0}^n a_ix^i\\nonumber \\\\ &amp;=(a_0 + a_2x^2 +a_4x^4+\\dots+a_{n-2}x^{n-2})\\nonumber \\\\ &amp;+(a_1x+a_3{x^3}+a_5{x^5}+ \\dots+a_{n-1}x^{n-1})\\nonumber \\end{align} ä»¤ \\begin{align} A_1(x) &amp;= (a_0 + a_2x +a_4x^2+\\dots+a_{n-2}x^{\\frac{n}{2}-1})\\nonumber\\\\ A_2(x) &amp;= (a_1x+a_3x+a_5{x^2}+ \\dots+a_{n-1}x^{\\frac{n}{2}-1})\\nonumber \\end{align} é‚£ä¹ˆ A(x)=A1(x2)+xA2(x2)A(x) = A_1(x^2) + xA2(x^2) A(x)=A1â€‹(x2)+xA2(x2) æˆ‘ä»¬æŠŠ x=wnkx = w_n^kx=wnkâ€‹ ä»£å…¥ A(wnk)=A1(wn2k)+wnkA2(wn2k)A(w_n^k) = A_1(w_n^{2k}) + w_n^kA_2(w_n^{2k}) A(wnkâ€‹)=A1â€‹(wn2kâ€‹)+wnkâ€‹A2â€‹(wn2kâ€‹) å†å¸¦ä¸ª x=wnk+n2x = w_n^{k+\\frac{n}{2}}x=wnk+2nâ€‹â€‹ \\begin{align} A(w_n^{k+\\frac{n}{2}}) &amp;= A_1(w_n^{2k+n}) + w_n^{k+\\frac{n}{2}}A_2(w_n^{2k+n})\\nonumber\\\\ &amp;=A_1(w_n^{2k}) - w_n^kA_2(w_n^{2k})\\nonumber \\end{align} wnn=1w_n^n = 1wnnâ€‹=1 wnk+n2=âˆ’wnkw_n^{k+\\frac{n}{2}} = -w_n^kwnk+2nâ€‹â€‹=âˆ’wnkâ€‹ æˆ‘ä»¬è§‚å¯Ÿå¾—åˆ°çš„ä¸¤ä¸ªç‹®å­ï¼Œå‘ç°åªæœ‰ A2A_2A2â€‹ çš„ç³»æ•°ä¸åŒ æˆ‘ä»¬å¯ä»¥é€’å½’æ±‚å‡º wnkw_n^kwnkâ€‹ çš„ A1A_1A1â€‹ å’Œ A2A_2A2â€‹ æ¥è®¡ç®— AAA ç¬¬äºŒæ­¥ IDFT ç‚¹å€¼ â†’\\rightarrowâ†’ ç³»æ•° IDFT(Inv_DFT) DFTçš„é€†è¿‡ç¨‹ ä»å®šä¹‰å‡ºå‘ Ci=Ajâˆ—Bi=âˆ‘j=0iâˆ’1ajâˆ—biâˆ’jâˆ’1C_i = A_j*B_i = \\sum\\limits_{j=0}^{i-1} a_j *b_{i-j-1}Ciâ€‹=Ajâ€‹âˆ—Biâ€‹=j=0âˆ‘iâˆ’1â€‹ajâ€‹âˆ—biâˆ’jâˆ’1â€‹ ä»¤ q=j,p=iâˆ’jâˆ’1q = j, p = i-j-1q=j,p=iâˆ’jâˆ’1 åˆ™ Ci=âˆ‘pâˆ‘qapâˆ—bq[p+q==n]C_i = \\sum\\limits_{p}\\sum\\limits_{q} a_p *b_q [p+q == n]Ciâ€‹=pâˆ‘â€‹qâˆ‘â€‹apâ€‹âˆ—bqâ€‹[p+q==n] =âˆ‘pâˆ‘qapâˆ—bq[nâˆ£p+qâˆ’i]=\\sum\\limits_{p}\\sum\\limits_{q} a_p *b_q [n\\mid p+q-i]=pâˆ‘â€‹qâˆ‘â€‹apâ€‹âˆ—bqâ€‹[nâˆ£p+qâˆ’i] å•ä½æ ¹åæ¼” =âˆ‘pâˆ‘qapâˆ—bqâˆ‘j=01nwn(p+qâˆ’i)j= \\sum_p\\sum_qa_p*b_q \\sum\\limits_{j=0}\\frac{1}{n}w_n^{(p+q-i)j}=âˆ‘pâ€‹âˆ‘qâ€‹apâ€‹âˆ—bqâ€‹j=0âˆ‘â€‹n1â€‹wn(p+qâˆ’i)jâ€‹ é‚£ä¹ˆ nCi=âˆ‘pâˆ‘qapâˆ—bqâˆ‘j=0wn(p+qâˆ’i)jnC_i =\\sum_p\\sum_qa_p*b_q \\sum\\limits_{j=0}w_n^{(p+q-i)j}nCiâ€‹=âˆ‘pâ€‹âˆ‘qâ€‹apâ€‹âˆ—bqâ€‹j=0âˆ‘â€‹wn(p+qâˆ’i)jâ€‹ æŠŠ p,q,ip, q, ip,q,i åˆ†é…ä¸€ä¸‹ï¼Œå†æŠŠ jjj æåˆ°å‰è¾¹å» nCi=âˆ‘jwnâˆ’ij(âˆ‘pwnjpap)(âˆ‘qwnjqbq)nC_i = \\sum_j w_n^{-ij}(\\sum_p w_n^{jp} a_p)(\\sum_q w_n^{jq} b_q)nCiâ€‹=âˆ‘jâ€‹wnâˆ’ijâ€‹(âˆ‘pâ€‹wnjpâ€‹apâ€‹)(âˆ‘qâ€‹wnjqâ€‹bqâ€‹) åé¢ä¸¤ä¸ª âˆ‘\\sumâˆ‘ è²Œä¼¼å°±æ˜¯ AAA å’Œ BBB åœ¨ wnjw_n^jwnjâ€‹ çš„ç‚¹å€¼ï¼Ÿå°±æ˜¯æˆ‘ä»¬ DFT çš„ç»“æœ äºæ˜¯æˆ‘ä»¬ä»£å…¥ wnjw_n^jwnjâ€‹ å†DFTä¸€éå°±èƒ½å¾—åˆ° Aâˆ’1A^{-1}Aâˆ’1 è¿˜æœ‰æ›´é…·ç‚«çš„ O(n)O(n)O(n) æ–¹æ³• è§‚å¯Ÿæˆ‘ä»¬æŒ‰å¥‡å¶æ‹†å¼€æ—¶çš„ç»“æœ æ°å¥½æ˜¯åŸåºåˆ—ä¸‹æ ‡çš„äºŒè¿›åˆ¶åè½¬ä¸€ä¸‹ï¼Œæˆ‘ä»¬å°±å¯ä»¥çœå»æŒ‰å¥‡å¶åˆ†ç±»çš„æ—¶é—´ä½†æ˜¯ä¸ä¼šå†™ Code é€’å½’ç‰ˆæœ¬å„¿ è’Ÿè’»ä¸ä¼šå†™éé€’å½’çš„æ cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cmath&gt;#define MAXN 3000005using namespace std;struct complex&#123; double x,y; complex operator + (complex b) &#123;return complex&#123;x+b.x, y+b.y&#125;;&#125; complex operator - (complex b) &#123;return complex&#123;x-b.x, y-b.y&#125;;&#125; complex operator * (complex b) &#123;return complex&#123;x*b.x - y*b.y, x*b.y + y*b.x&#125;;&#125;&#125;A[MAXN],B[MAXN];int n,m;const double pi = acos(-1.0);void FFT(int limit, complex *a, int opt)&#123; if(limit == 1) return; complex a1[limit&gt;&gt;1], a2[limit&gt;&gt;1]; for(int i = 0; i &lt; limit; i += 2) &#123; a1[i&gt;&gt;1] = a[i]; a2[i&gt;&gt;1] = a[i+1]; &#125; FFT(limit&gt;&gt;1, a1, opt); FFT(limit&gt;&gt;1, a2, opt); complex wn = complex&#123;cos(2.0 * pi/limit), opt*sin(2.0*pi/limit)&#125;; complex w = complex&#123;1, 0&#125;; for(int i = 0; i &lt; (limit&gt;&gt;1); i++, w = w*wn) &#123; a[i] = a1[i] + w*a2[i]; a[i + (limit&gt;&gt;1)] = a1[i] - w*a2[i]; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 0; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;A[i].x); for(int i = 0; i &lt;= m; i++) scanf(&quot;%lf&quot;, &amp;B[i].x); int lmt = 1; while(lmt &lt;= n+m) lmt &lt;&lt;= 1; FFT(lmt, A, 1); FFT(lmt, B, 1); for(int i = 0; i &lt;= lmt; i++) A[i] = A[i] * B[i]; FFT(lmt, A, -1); for(int i = 0; i &lt;= n+m; i++) printf(&quot;%d &quot;, (int)(A[i].x/lmt+0.5));&#125; NTT æˆ‘ä»¬çœ‹åˆ°åœ¨ FFT ä¸­ï¼Œå¤æ•°å’Œä¸‰è§’å‡½æ•°ä¼šæŸå¤±å¾ˆå¤§çš„ç²¾åº¦ï¼Œä¹Ÿæœ‰äº†ä¸èƒ½å–æ¨¡çš„é™åˆ¶ï¼Œæ‰€ä»¥ä¹Ÿæœ‰å¦ä¸€ä¸ªåšæ³•â€“NTT åŸæ ¹ çš„æ€§è´¨å’Œå•ä½æ ¹å¾ˆç›¸ä¼¼ ä»¤ ggg ä¸º æ¨¡ ppp ä¸‹çš„åŸæ ¹ï¼Œæˆ‘ä»¬æœ‰ gpâˆ’1â‰¡1 (mod p)g^{p-1} \\equiv 1 \\ (mod\\ p)gpâˆ’1â‰¡1 (mod p) ï¼Œæ‰€ä»¥å¯ä»¥æŠŠå•ä½æ ¹ wnkw_n^kwnkâ€‹ æ¢æˆ gnkg_n^kgnkâ€‹ ä¸€èˆ¬çš„ NTT æ¨¡æ•° 998244353 çš„åŸæ ¹ä¸º 3 çœ‹åˆ°åˆ«çš„æ¨¡æ•°éœ€è¦è€ƒè™‘ä¸€ä¸‹åŸæ ¹æ˜¯å‡ æˆ–è€…å†™å¤šæ¨¡æ•° NTT ï¼Œä½†æˆ‘ä¸ä¼šï¼Œæ‰€ä»¥é€‰æ‹©å¯„æ‰ NTT 123456789101112131415161718192021void NtT(ll *A, int opt)&#123; for(int i = 0; i &lt; limit; i++) if(i &lt; r[i]) swap(A[i], A[r[i]]); for(int mid = 1; mid &lt; limit; mid &lt;&lt;= 1) &#123; ll wn = ksm(opt == 1 ? yp : zp, (p-1)/(mid &lt;&lt; 1)); for(int j = 0; j &lt; limit; j += (mid &lt;&lt; 1)) &#123; ll w = 1; for(int k = 0; k &lt; mid; k++, w = w*wn%p) &#123; ll x = A[j + k], y = w * A[j + k + mid]%p; A[j + k] = (x + y)%p; A[j + k + mid] = (x - y +p)%p; &#125; &#125; &#125;&#125; å¤šé¡¹å¼æ±‚é€† å¯¹äºä¸€ä¸ªå¤šé¡¹å¼ FFF å¦‚æœæœ‰ Fâˆ—Gâ‰¡1 (mod xn)F * G \\equiv 1 \\ (mod \\ x^n) Fâˆ—Gâ‰¡1 (mod xn) é‚£ä¹ˆç§° GGG å³ Fâˆ’1F^{-1}Fâˆ’1 ä¸º FFF çš„é€†å…ƒ æ—¢ç„¶æœ‰ Fâˆ—Gâ‰¡1 (mod xn)F * G \\equiv 1 \\ (mod \\ x^n) Fâˆ—Gâ‰¡1 (mod xn) é‚£ä¹ˆåŒæ · \\begin{align} F * H &amp;\\equiv 1 \\ (mod \\; x^{\\frac{n}{2}}) \\nonumber\\\\ G &amp;\\equiv H (mod \\; x^{\\frac{n}{2}}) \\nonumber\\\\ (G - H) &amp;\\equiv 0 (mod \\; x^{\\frac{n}{2}}) \\nonumber\\\\ (G - H)^2 &amp;\\equiv 0 (mod \\; x^n) \\nonumber\\\\ G^2 + H^2 - 2GH &amp;\\equiv 0 (mod \\; x^n) \\nonumber\\\\ F(G^2 + H^2 - 2GH) &amp;\\equiv 0 (mod \\; x^n) \\nonumber\\\\ G + FH^2 - 2H &amp;\\equiv 0 (mod \\; x^n) \\nonumber\\\\ G &amp;\\equiv 2H - FH^2 (mod \\; x^n) \\nonumber \\end{align} æ¨å‡ºå¼å­é€’å½’ ğŸ†˜ å®Œäº† å¤šé¡¹å¼å¯¹æ•°å‡½æ•° (å¤šé¡¹å¼ lnâ¡\\lnln ) å¤šé¡¹å¼ F(x)F(x)F(x) å’Œ G(x)G(x)G(x) ï¼Œ Gâ‰¡lnâ¡F(mod xn)G \\equiv \\ln F (mod \\; x^n)Gâ‰¡lnF(modxn) ï¼Œæ±‚ GGG å¾— ğŸ”ª ä¸€ä¸‹ \\begin{align} G &amp;\\equiv \\ln F \\; (mod \\; x^n) \\nonumber\\\\ G&#039; &amp;\\equiv \\ln F&#039; \\; (mod \\; x^n) \\nonumber\\\\ G &amp;\\equiv \\ln(F)&#039; F&#039; \\; (mod \\; x^n) \\nonumber\\\\ G &amp;\\equiv \\frac{F&#039;}{F} \\; (mod \\; x^n) \\nonumber \\end{align} æ‰€ä»¥æ±‚ä¸ªå¯¼å†æ•´ä¸€ä¸ª FFF çš„é€†å…ƒå¾—åˆ° Gâ€²G&#x27;Gâ€² å†å¯„å›å»å°±è¡Œè¾£ å¤šé¡¹å¼æŒ‡æ•°å‡½æ•° ï¼ˆå¤šé¡¹å¼ expâ¡\\expexp aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","categories":[],"tags":[{"name":"æ•°å­¦ï¼Œæ•°è®º","slug":"æ•°å­¦ï¼Œæ•°è®º","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"}]},{"title":"ç±»æ¬§å‡ é‡Œå¾—","slug":"ç±»æ¬§å‡ é‡Œå¾—","date":"2022-07-18T00:04:31.000Z","updated":"2022-11-08T07:43:44.521Z","comments":true,"path":"2022/07/18/ç±»æ¬§å‡ é‡Œå¾—/","link":"","permalink":"https://ve1bae.github.io/2022/07/18/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"çœŸå¤šå•Šéº»éº»åœ°","text":"çœŸå¤šå•Šéº»éº»åœ° Begin f(a,b,c,n)=âˆ‘i=0nâŒŠai+bcâŒ‹f(a,b,c,n) = \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{a_i + b}{c}\\right \\rfloor f(a,b,c,n)=i=0âˆ‘nâ€‹âŒŠcaiâ€‹+bâ€‹âŒ‹ å…ˆè€ƒè™‘ aâ©¾ca \\geqslant caâ©¾c æˆ– bâ©¾cb \\geqslant cbâ©¾c æ—¶çš„æƒ…å†µï¼Œç›´æ¥æŠŠé™¤æ‹†å¼€ f(a,b,c,n)=âˆ‘i=0nâŒŠai+bcâŒ‹=âˆ‘i=0nâŒŠaicâŒ‹+âˆ‘i=0nâŒŠbcâŒ‹+âˆ‘i=0nâŒŠai%c+b%ccâŒ‹f(a,b,c,n) = \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor\\\\ = \\sum\\limits_{i = 0}^n \\lfloor \\frac{ai}c \\rfloor + \\sum\\limits_{i = 0}^n \\lfloor \\frac bc \\rfloor + \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{ai \\% c + b\\%c}{c}\\right \\rfloor f(a,b,c,n)=i=0âˆ‘nâ€‹âŒŠcai+bâ€‹âŒ‹=i=0âˆ‘nâ€‹âŒŠcaiâ€‹âŒ‹+i=0âˆ‘nâ€‹âŒŠcbâ€‹âŒ‹+i=0âˆ‘nâ€‹âŒŠcai%c+b%câ€‹âŒ‹ å‘ç°å·¦è¾¹æ˜¯ç­‰å·®æ•°åˆ—ï¼Œå³è¾¹æ˜¯é€’å½’çš„å½¢å¼ f(a,b,c,n)=n(n+1)2âŒŠaicâŒ‹+nâŒŠbcâŒ‹+f(a%c,b%c,c,n)f(a,b,c,n) = \\frac{n(n+1)}{2} \\lfloor \\frac{ai}c \\rfloor + n\\lfloor \\frac bc \\rfloor + f(a\\%c,b\\%c,c,n) f(a,b,c,n)=2n(n+1)â€‹âŒŠcaiâ€‹âŒ‹+nâŒŠcbâ€‹âŒ‹+f(a%c,b%c,c,n) å†æ¥è€ƒè™‘ a&lt;ca \\lt ca&lt;c å’Œ b&lt;cb &lt; cb&lt;c çš„æƒ…å†µï¼Œæˆ‘ä»¬å˜ä¸€ä¸‹ f(a,b,c,n)=âˆ‘i=0nâŒŠai+bcâŒ‹=âˆ‘i=0nâˆ‘j=0âŒŠai+bcâŒ‹âˆ’11f(a,b,c,n) = \\sum\\limits_{i=0}^n \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor = \\sum\\limits_{i=0}^n \\sum\\limits_{j=0}^{\\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor -1} 1 f(a,b,c,n)=i=0âˆ‘nâ€‹âŒŠcai+bâ€‹âŒ‹=i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcai+bâ€‹âŒ‹âˆ’1â€‹1 ç„¶åæŠŠ jjj ç§»åˆ° iii å‰é¢å»ï¼Œä»¤ m=âŒŠan+bcâŒ‹m = \\left \\lfloor \\frac{an + b}{c}\\right \\rfloorm=âŒŠcan+bâ€‹âŒ‹ =âˆ‘j=0mâˆ’1âˆ‘i=0n[j&lt;âŒŠai+bcâŒ‹]=\\sum\\limits_{j=0}^{m -1} \\sum\\limits_{i=0}^n \\left[j &lt; \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor \\right] =j=0âˆ‘mâˆ’1â€‹i=0âˆ‘nâ€‹[j&lt;âŒŠcai+bâ€‹âŒ‹] å°è¯•æŠŠæ¡ä»¶å˜ä¸€å˜ \\begin{align} [j &lt; \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor] &amp;= [j+1 \\leqslant \\frac{ai + b}{c}] = [jc+c \\leqslant ai+b] \\nonumber\\\\ &amp;= [ai \\geqslant jc+c-b] = [ai \\geqslant jc+c-b-1]\\nonumber \\end{align} è¿™æ · \\begin{align} f(a,b,c,n) &amp;= \\sum\\limits_{j=0}^{m-1}\\sum\\limits_{i=0}^n \\left[i &gt;= \\frac{jc+c-b-1}{a} \\right] \\nonumber\\\\ &amp;= \\sum\\limits_{j=0}^{m-1} \\left ( n-\\frac{jc+c-b-1}{a} \\right ) \\nonumber\\\\ &amp;= nm - f(c,c-b-1,a,m-1) \\nonumber \\end{align} ç„¶åå‘ç°å¯æ±‚ å¯ä»¥å‘ç°æˆ‘ä»¬é€’å½’çš„è¿‡ç¨‹ç±»ä¼¼äºè¾—è½¬ç›¸é™¤ï¼Œå› æ­¤è¿™ä¸ªç®—æ³•å«åš â€˜â€™ç±»æ¬§å‡ é‡Œå¾—â€˜â€™ã€‚ æ‹“å±• g(a,b,c,n)=âˆ‘i=0nâŒŠai+bcâŒ‹ih(a,b,c,n)=âˆ‘i=0nâŒŠai+bcâŒ‹2g(a,b,c,n) = \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{a_i + b}{c}\\right \\rfloor i \\\\ h(a,b,c,n) = \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{a_i + b}{c}\\right \\rfloor^2 g(a,b,c,n)=i=0âˆ‘nâ€‹âŒŠcaiâ€‹+bâ€‹âŒ‹ih(a,b,c,n)=i=0âˆ‘nâ€‹âŒŠcaiâ€‹+bâ€‹âŒ‹2 g ç»å…¸åˆ†æƒ…å†µ aâ©¾ca \\geqslant caâ©¾c æˆ– bâ©¾cb \\geqslant cbâ©¾c æ—¶ \\begin{align} g(a,b,c,n) &amp;= \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor i \\nonumber\\\\ &amp;= \\sum\\limits_{i = 0}^n \\lfloor \\frac{ai}c \\rfloor i + \\sum\\limits_{i = 0}^n \\lfloor \\frac bc \\rfloor i+ \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{ai \\% c + b\\%c}{c}\\right \\rfloor i \\nonumber\\\\ &amp;= \\lfloor \\frac{a}{c} \\rfloor \\frac{n(n+1)(2n+1)}{6} + \\lfloor \\frac{b}{c} \\rfloor \\frac{n(n+1)}{2}\\nonumber\\\\ &amp;+ g(a\\%c, b \\% c, c, n)\\nonumber \\end{align} a&lt;ca \\lt ca&lt;c å’Œ b&lt;cb &lt; cb&lt;c æ—¶ ä»¤ m=âŒŠan+bcâŒ‹m = \\lfloor \\frac{an + b}{c} \\rfloorm=âŒŠcan+bâ€‹âŒ‹ \\begin{align} g(a,b,c,n) &amp;= \\sum\\limits_{j=0}^{m -1} \\sum\\limits_{i=0}^n \\left[j &lt; \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor \\right]i \\nonumber\\\\ &amp;=\\sum\\limits_{j=0}^{m -1} \\sum\\limits_{i=0}^n \\left[i &gt;= \\frac{jc+c-b-1}{a} \\right]i \\nonumber \\end{align} ä»¤ t=jc+bâˆ’câˆ’1t = jc+b-c-1t=jc+bâˆ’câˆ’1 \\begin{align} g(a,b,c,n) &amp;= \\sum\\limits_{j=0}^{m-1} \\frac{1}{2} (t+n+1)(n-t) \\nonumber\\\\ &amp;= \\frac{1}{2} \\left [ nm(m+1) - \\sum_{j=0}^{m-1}t^2 - \\sum_{j=0}^{m-1}t \\right ] \\nonumber\\\\ &amp;= \\frac{1}{2} \\left [ mn(n+1) - h(c, c-b-1, a, m-1) - f(c, c-b-1, a, m-1) \\right] \\nonumber \\end{align} h çœŸ ğŸ” 8ï¸âƒ£ ğŸ´ ğŸš ï¼Œä¸æ¨äº† æ³¨æ„ n2n^2n2 æ¢æˆ 2n(n+1)2âˆ’n2 \\frac{n(n+1)}{2} - n22n(n+1)â€‹âˆ’n ä¹Ÿå°±æ˜¯ (2âˆ‘i=0n)âˆ’n\\left( 2\\sum\\limits_{i=0}^{n} \\right) - n(2i=0âˆ‘nâ€‹)âˆ’n è¿™æ ·å­å°±æ²¡æœ‰ âˆ‘Ã—âˆ‘\\sum \\times \\sumâˆ‘Ã—âˆ‘ äº† aâ©¾ca \\geqslant caâ©¾c æˆ– bâ©¾cb \\geqslant cbâ©¾c æ—¶ \\begin{align} h(a,b,c,n) &amp;= h(a \\% c, b \\% c, c, n)\\nonumber\\\\ &amp;+ 2 \\lfloor \\frac{b}{c} \\rfloor f(a \\%c, b\\%c,c,n) + 2 \\lfloor \\frac{b}{c} \\rfloor g(a \\%c, b\\%c,c,n)\\nonumber\\\\ &amp;+ \\lfloor \\frac{a}{c} \\rfloor^2 \\frac{n(n+1)(2n+1)}{6} + \\lfloor \\frac{b}{c} \\rfloor^2(n+1) + \\lfloor \\frac{a}{c} \\rfloor\\lfloor \\frac{b}{c} \\rfloor n(n+1)\\nonumber \\end{align} a&lt;ca \\lt ca&lt;c å’Œ b&lt;cb &lt; cb&lt;c æ—¶ \\begin{align} h(a,b,c,n) &amp;= nm(m+1) \\nonumber\\\\ &amp;- 2g(c, c-b-1, a, m-1) - 2f(c, c-b-1, a, m-1) - f(a, b, c, n)\\nonumber \\end{align} cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int t;ll n,a,b,c;const ll p = 998244353;const ll inv2 = 499122177;const ll inv6 = 166374059;struct node&#123; ll f, g, h;&#125;;node work(ll a, ll b, ll c, ll n)&#123; ll ac = a/c, bc = b/c, m = (a*n+b)/c, n1 = n+1, n2 = n*2+1; node x; if(a == 0) &#123; x.f = bc*n1%p; x.g = bc*n%p * n1%p * inv2%p; x.h = bc*bc%p * n1%p; return x; &#125; if(a &gt;= c || b &gt;= c) &#123; x.f = n*n1%p * inv2%p * ac%p + bc*n1%p; x.g = ac*n%p * n1%p * n2%p * inv6%p + bc * n%p * n1%p *inv2%p; x.h = ac*ac%p * n%p * n1%p * n2%p *inv6%p + bc*bc%p * n1%p + ac*bc%p * n%p * n1%p; x.f %= p; x.g %= p; x.h %= p; node e = work(a%c, b%c, c, n); x.h = (x.h + e.h + 2 * bc%p * e.f%p + 2 * e.g%p * ac%p)%p; x.f = (x.f + e.f)%p; x.g = (x.g + e.g)%p; x.h %= p; return x; &#125; node e = work(c, c-b-1, a, m-1); x.f = ((n * m%p - e.f)%p + p)%p; x.g = ((n * m%p * n1%p - e.h - e.f) * inv2%p +p) %p; x.h = ((n * m%p * (m+1)%p - 2*e.g - 2*e.f - x.f)%p + p)%p; return x;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;a,&amp;b,&amp;c); node ans = work(a, b, c, n); printf(&quot;%lld %lld %lld\\n&quot;,ans.f, ans.h, ans.g); &#125; return 0;&#125;","categories":[],"tags":[{"name":"æ•°å­¦ï¼Œæ•°è®º","slug":"æ•°å­¦ï¼Œæ•°è®º","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"}]},{"title":"äºŒæ¬¡å‰©ä½™","slug":"äºŒæ¬¡å‰©ä½™","date":"2022-07-13T00:01:28.000Z","updated":"2022-11-08T07:43:42.438Z","comments":true,"path":"2022/07/13/äºŒæ¬¡å‰©ä½™/","link":"","permalink":"https://ve1bae.github.io/2022/07/13/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/","excerpt":"è§£å¦‚ä¸‹çš„æ–¹ç¨‹ x2â‰¡ n (mod p)x^2 \\equiv \\, n \\ (mod \\; p) x2â‰¡n (modp)","text":"è§£å¦‚ä¸‹çš„æ–¹ç¨‹ x2â‰¡ n (mod p)x^2 \\equiv \\, n \\ (mod \\; p) x2â‰¡n (modp) å‰ç½® æˆ‘ä»¬å¼•å…¥ LegendreLegendreLegendre è®°å· (pn)={1 p ä¸º n çš„äºŒæ¬¡å‰©ä½™âˆ’1 p ä¸º n éäºŒæ¬¡å‰©ä½™0nâ‰¡0(\\frac p n) = \\begin{cases} 1 &amp;\\text { $p$ ä¸º $n$ çš„äºŒæ¬¡å‰©ä½™} \\\\ -1 &amp;\\text { $p$ ä¸º $n$ éäºŒæ¬¡å‰©ä½™} \\\\ 0 &amp;\\text{$n \\equiv 0$} \\end{cases} (npâ€‹)=â©âªâªâ¨âªâªâ§â€‹1âˆ’10â€‹ p ä¸º n çš„äºŒæ¬¡å‰©ä½™ p ä¸º n éäºŒæ¬¡å‰©ä½™nâ‰¡0â€‹ å¼•ç†ä¸€ï¼š (np)â‰¡npâˆ’12 (mod p)(\\frac{n}{p}) \\equiv n^{\\frac{p-1}{2}} \\ (mod \\ p) (pnâ€‹)â‰¡n2pâˆ’1â€‹ (mod p) è¯æ˜ï¼š è‹¥ nnn ä¸º ppp çš„ äºŒæ¬¡å‰©ä½™ï¼Œåˆ™ x2â‰¡ nx^2 \\equiv \\ nx2â‰¡ n æ‰€ä»¥ xpâˆ’1â‰¡1x^{p-1} \\equiv1xpâˆ’1â‰¡1 è´¹é©¬å°å®šç†æ˜¾ç„¶ åä¹‹åˆ™ xpâˆ’1â‰¡âˆ’1x^{p-1} \\equiv -1xpâˆ’1â‰¡âˆ’1 , xxxæ˜¾ç„¶ä¸å­˜åœ¨ å¼•ç†äºŒï¼š å¯¹äº aaa ä¸ aaa äº’è´¨çš„å¥‡ç´ æ•° ppp æœ‰ apâˆ’12 â‰¡Â±1 (mod p)a^{\\frac{p-1}{2}} \\; \\equiv \\pm1 \\;(mod \\; p) a2pâˆ’1â€‹â‰¡Â±1(modp) è¯æ˜ï¼š ç”±è´¹é©¬å°å®šç†çŸ¥ï¼š apâˆ’1â‰¡1 (mod p)a^{p-1} \\equiv 1\\;(mod\\;p) apâˆ’1â‰¡1(modp) ä»¤ 2q=pâˆ’12q = p-12q=pâˆ’1 åˆ™æœ‰ \\begin{align} a^{2q} &amp;\\equiv 1 \\ (mod \\; p)\\nonumber\\\\ a^{2q}-1 &amp;\\equiv 0 \\;\\nonumber\\\\ (a^q+1)(a^q-1) &amp;\\equiv 0\\;\\nonumber\\\\ a^q &amp;\\equiv \\pm1\\nonumber\\\\ a^{p-1} &amp;\\equiv 1\\nonumber\\\\ a^{\\frac{p-1}{2}} &amp;\\equiv \\pm 1 (mod \\ p)\\nonumber \\end{align} å¼€æ‘† ä»¤ w=a2âˆ’nw = a^2 - nw=a2âˆ’n ä¸º mod pmod\\;pmodp çš„äºŒæ¬¡éç”Ÿè‚² ï¼Œ åˆ™ x=(a+w)p+12x = (a + \\sqrt{w})^{\\frac{p+1}{2}}x=(a+wâ€‹)2p+1â€‹ ä¸ºæ–¹ç¨‹çš„è§£ è¯æ˜ï¼š x2â‰¡nâ‰¡a2âˆ’wâ‰¡(a+w)(aâˆ’w)x^2 \\equiv n \\equiv a^2 - w \\\\ \\equiv (a + \\sqrt{w})(a - \\sqrt{w}) x2â‰¡nâ‰¡a2âˆ’wâ‰¡(a+wâ€‹)(aâˆ’wâ€‹) è´¹é©¬å°å®šç† apâ‰¡aa^p \\equiv aapâ‰¡a âˆ´a2â‰¡ap+1\\therefore a^2 \\equiv a^{p+1}âˆ´a2â‰¡ap+1 å¼•ç†ä¸€çŸ¥ wpâˆ’1â‰¡âˆ’1\\sqrt {w}^{p-1} \\equiv -1wâ€‹pâˆ’1â‰¡âˆ’1 åœ¨æ¨¡ ppp æ„ä¹‰ä¸€ä¸‹äºŒé¡¹å¼å®šç† (a+b)pâ‰¡ap+bp(a + b)^p \\equiv a^p + b^p (a+b)pâ‰¡ap+bp æ‰€ä»¥ \\begin{align} x^2 &amp;\\equiv (a + \\sqrt{w})(a - \\sqrt{w}) \\nonumber \\\\ \\nonumber &amp;\\equiv (a + \\sqrt{w})(a^p + \\sqrt {w}^{p-1}\\times \\sqrt{w}) \\\\\\nonumber &amp;\\equiv (a + \\sqrt{w})(a^p + \\sqrt {w}^{p}) \\nonumber \\\\ \\nonumber &amp;\\equiv (a + \\sqrt{w})^{p+1}\\\\ \\nonumber x&amp;\\equiv (a+\\sqrt{w})^{\\frac{p+1}{2}} \\end{align} æ‰€ä»¥æˆ‘ä»¬éšæœºåŒ–æ•´ www æ±‚è§£å³å¯ cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int t;ll n,p,w;struct dot&#123; ll x,y; dot operator * (dot b) &#123; dot ans; ans.x = ((x*b.x%p + y*b.y%p*w%p) + p)%p; ans.y = ((x*b.y%p + y*b.x%p) + p)%p; return ans; &#125; &#125;;ll ksm(ll a,ll b)&#123; ll ans = 1; while(b) &#123; if(b&amp;1) ans =a*ans%p; a = a*a%p; b &gt;&gt;= 1; &#125; return ans;&#125;ll ksm_w(dot a,ll b)&#123; dot ans = &#123;1,0&#125;; while(b) &#123; if(b&amp;1) ans = a*ans; a = a*a; b &gt;&gt;= 1; &#125; return ans.x%p;&#125;ll solve(ll n)&#123; n %= p; if(p == 2) return n; if(ksm(n,(p-1)/2) == p-1) return -1; ll a; while(1) &#123; a = rand()%p; w = (ksm(a,2)-n +p)%p; if(ksm(w,(p-1)/2) == p-1) break; &#125; dot x = &#123;a,1&#125;; return ksm_w(x,(p+1)/2);&#125;int main()&#123; srand(time(0)); scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;p); if(!n) &#123; printf(&quot;0\\n&quot;); continue; &#125; ll ans1 = solve(n),ans2; if(ans1 == -1) printf(&quot;Hola!\\n&quot;); else &#123; ans2 = p-ans1; if(ans2 &lt; ans1) swap(ans1,ans2); if(ans1 == ans2) printf(&quot;%lld\\n&quot;,ans1); else printf(&quot;%lld %lld\\n&quot;,ans1,ans2); &#125; &#125; return 0;&#125; æ³¨æ„ www ç±»ä¼¼äºå¤æ•° è¦é‡è½½ âˆ—*âˆ— è¿ç®— wssb","categories":[],"tags":[{"name":"æ•°å­¦ï¼Œæ•°è®º","slug":"æ•°å­¦ï¼Œæ•°è®º","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-06-28T07:05:20.000Z","updated":"2022-11-08T10:41:14.547Z","comments":true,"path":"2022/06/28/hello-world/","link":"","permalink":"https://ve1bae.github.io/2022/06/28/hello-world/","excerpt":"ğŸ˜ƒ ğŸ˜…","text":"ğŸ˜ƒ ğŸ˜… Ï†\\varphiÏ† ğŸ˜† test Test AwA qwq &gt;w&lt; âˆ‘qwqawaÃ—Kon\\sum\\limits{qwq}^{awa} \\times Kon âˆ‘qwqawaÃ—Kon","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"æ€»ç»“","slug":"æ€»ç»“","permalink":"https://ve1bae.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"https://ve1bae.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"è´ªå¿ƒ","slug":"è´ªå¿ƒ","permalink":"https://ve1bae.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ•°å­¦ï¼Œæ•°è®º","slug":"æ•°å­¦ï¼Œæ•°è®º","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"https://ve1bae.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"https://ve1bae.github.io/tags/dsu-on-tree/"},{"name":"è™šæ ‘","slug":"è™šæ ‘","permalink":"https://ve1bae.github.io/tags/%E8%99%9A%E6%A0%91/"},{"name":"ç‚¹åˆ†æ²»","slug":"ç‚¹åˆ†æ²»","permalink":"https://ve1bae.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"æ ‘åŒæ„","slug":"æ ‘åŒæ„","permalink":"https://ve1bae.github.io/tags/%E6%A0%91%E5%90%8C%E6%9E%84/"}]}