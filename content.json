{"meta":{"title":"Veibae CN","subtitle":"","description":"Veibae CN","author":"Veibae","url":"https://ve1bae.github.io","root":"/"},"pages":[{"title":"My friends","date":"2022-11-13T08:07:28.389Z","updated":"2022-11-13T08:07:28.389Z","comments":true,"path":"friends/index.html","permalink":"https://ve1bae.github.io/friends/index.html","excerpt":"机房兄贵！","text":"机房兄贵！"},{"title":"log","date":"2022-09-14T08:50:58.000Z","updated":"2022-11-09T08:35:47.883Z","comments":true,"path":"log/index.html","permalink":"https://ve1bae.github.io/log/index.html","excerpt":"","text":"2022-10-30 新文章 csp2022又寄 2022-10-9 新文章 fan_si_gui_hua 2022-10-1 莫队学习笔记 更新 树上莫队 2022-9-24 修改了 二次剩余 中的一些错误每日总结 更新 9.14~9.23 2022-9-21 新文章 emoji莫队学习笔记 更新 回滚莫队 2022-9-14 每日总结 更新 9.11~9.13 2022-9.14 每日总结 更新 9.6~9.9 2022-9.07 评论系统更换为 giscus 2022-9.04 每日总结 更新 9.1~9.3 2022-8.22 添加了 Waline 评论系统"},{"title":"about","date":"2022-08-07T12:55:41.000Z","updated":"2022-09-21T13:42:36.000Z","comments":true,"path":"about/index.html","permalink":"https://ve1bae.github.io/about/index.html","excerpt":"","text":"Veibae 是一个很可爱的英文 Vtuber ，但我和她一点关系都没有，哦不对，她是我的主人😍😍嘿嘿😋我的Veibae😍😋😋 qq: 1161668282"},{"title":"tags","date":"2022-08-01T08:30:45.000Z","updated":"2022-08-23T08:48:02.000Z","comments":true,"path":"tags/index.html","permalink":"https://ve1bae.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"11月每日总结","slug":"11月每日总结","date":"2022-11-04T13:28:42.000Z","updated":"2022-11-14T12:56:17.553Z","comments":true,"path":"2022/11/04/11月每日总结/","link":"","permalink":"https://ve1bae.github.io/2022/11/04/11%E6%9C%88%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/","excerpt":"日复一日，必有精进？？？？","text":"日复一日，必有精进？？？？ 11.1 T1 有 nnn 个选民，编号为 1∼n1 \\sim n1∼n ，它们中有的人支持Alice，有的人支持Bob，还有的人保持中立。 现在你需要把选民分成若干个区间，每个区间的长度在 [l,r][l,r][l,r] 中。如果一个区间中支持Alice的人比支持Bob的人多，那么Alice得一票， Bob多则Bob得一票。 请你合理地分区间，使得Alice获胜。 可以想到一个比较暴力的 DP 令 fif_ifi​ 为到 iii 这个位置的最大收益 fi=max⁡j=lrfj−1+get(j,i)f_i = \\max\\limits_{j = l}^r f_{j-1} + get(j, i)fi​=j=lmaxr​fj−1​+get(j,i) 其中 l,rl, rl,r 指的是在 iii 左侧，能和 iii 划成一个区间的最远和最近的位置。 get(i,j)get(i, j)get(i,j) 指 [i,j][i, j][i,j] 的区间内，选票的增减情况，也就是区间和的符号 那么考虑怎么优化，使用线段树科技, 对于 sumsumsum 为下标维护 fff 优化 T2 小象有 nnn 张卡片，第 iii 张卡片上有一个数字 aia_iai​ 。Alice和Bob轮流选择卡片 (不能重复)，如果某次选择后已选择卡片上的数字的最大公约数为 111 或者没有卡片可以选择，那么当前角色失败。 你需要求出：1、如果双方都选择最优策略，谁会获胜；2、如果双方都随机选取，Alice获胜的概率。 直接状压卡片选不选，TLE + MLE 只记录当前 gcd 和 已选卡片数量 TLE 。 有发现可以把 aia_iai​ 中相同的因数去掉。状态数减少 11.2 我爹 AK 了 11.3 T1 给定一个 n∗mn * mn∗m 的棋盘。 qqq 次询问， 询问一个宽度为 www 的东西能不能从一个坐标到达另一个坐标。 可以二分预处理出每个点能放得下的最大宽度。 对询问离线，按宽度递减排序，并查集维护连通性。宽度减小扩展并查集就行。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;#define MAXN 2005#define MXXN 1000005using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; &#125; template &lt;typename T&gt; inline void print(T x) &#123; if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x; if (x &gt; 9) print(x / 10); putchar(x%10 + &#x27;0&#x27;); &#125; template &lt;typename T, typename ...TT&gt; inline void read(T &amp;x, TT &amp;...y) &#123; read(x); read(y...); &#125; #define p_ putchar(&#x27; &#x27;); #define pn putchar(&#x27;\\n&#x27;); #define print_(x) print(x), putchar(&#x27; &#x27;); #define printn(x) print(x), putchar(&#x27;\\n&#x27;);&#125;using namespace OCTANE;int n, m, q;#define pos(x, y) (((x) - 1) * n + (y))namespace Union_set&#123; int fa[MXXN], siz[MXXN]; void init(int n) &#123; for (int i = 1; i &lt;= n; i++) fa[i] = i, siz[i] = 1; &#125; int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]); &#125; bool merge(int x, int y) &#123; int fx = find(x), fy = find(y); if (fx == fy) return false; if (siz[x] &gt; siz[y]) swap(x, y); fa[fx] = fy; siz[fy] += siz[fx]; return true; &#125;&#125;struct query &#123; int sx, sy, tx, ty, w, id; &#125;que[100005];bool cmp(query a, query b)&#123; return a.w &gt; b.w;&#125;char mp[MAXN][MAXN];int sum[MAXN][MAXN];int mxz[MAXN][MAXN];int get(int lx, int rx, int ly, int ry)&#123; return sum[rx][ry] - sum[lx-1][ry] - sum[rx][ly-1] + sum[lx-1][ly-1];&#125;vector &lt;pair&lt;int, int&gt;&gt; vr[MAXN];int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;void Linkstart(int now)&#123; for (auto v : vr[now]) &#123; int p = pos(v.first, v.second); for (int i = 0; i &lt; 4; i++) &#123; int X = v.first + dx[i], Y = v.second + dy[i]; if (X &gt; 0 &amp;&amp; Y &gt; 0 &amp;&amp; X &lt;= n &amp;&amp; Y &lt;= m) if (mxz[X][Y] &gt;= now) Union_set::merge(p, pos(X, Y)); &#125; &#125;&#125;int ans[100005];int main()&#123; // freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;vei.out&quot;, &quot;w&quot;, stdout); read(n, m, q); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, mp[i] + 1); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + (mp[i][j]^48); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) if (mp[i][j] == &#x27;0&#x27;) &#123; int l = 1, r = min(i, j) + 1; int res = 1; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (!get(i - mid + 1, i, j - mid + 1, j)) res = mid, l = mid + 1; else r = mid; &#125; mxz[i][j] = res; vr[res].emplace_back(i, j); &#125; &#125; int now = 0; for (int i = 1; i &lt;= q; i++) &#123; int sx, sy, tx, ty, w; read(sx, sy, tx, ty, w); now = max(now, w); que[i] = &#123;sx, sy, tx, ty, w, i&#125;; &#125; sort(que + 1, que + 1 + q, cmp); Union_set :: init(n * m); for (int i = 1; i &lt;= q; i++) &#123; while (now &gt;= que[i].w) Linkstart(now--); if (mxz[que[i].sx][que[i].sy] &lt; que[i].w || mxz[que[i].tx][que[i].ty] &lt; que[i].w) ans[que[i].id] = false; else ans[que[i].id] = (Union_set::find(pos(que[i].sx, que[i].sy)) == Union_set::find(pos(que[i].tx, que[i].ty))); &#125; for (int i = 1; i &lt;= q; i++) puts(ans[i] ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; 11.4 T1 两组玩家，第一组玩家的能力值为 ai,…ana_i, \\dots a_nai​,…an​ 。第二组玩家的能力值为 b1,…b2b_1, \\dots b_2b1​,…b2​ 。玩家之间两两进行游戏。AAA 组玩家在一场游戏中获胜的概率是 ai/(ai+bi)a_i / (a_i + b_i)ai​/(ai​+bi​) 。 询问 AAA 组每个玩＋获胜的期望。ai,bi∈[1,2]a_i, b_i \\in [1, 2]ai​,bi​∈[1,2] 对于每个 aaa 求 ∑i=1maa+bi\\sum\\limits_{i=1}^{m} \\dfrac{a}{a + b_i}i=1∑m​a+bi​a​ 转化一下 ∑i=1maa+bi=m−∑i=1mbia+bi\\sum_{i=1}^{m} \\dfrac{a}{a+b_i}\\\\ =m-\\sum_{i=1}^{m}\\frac{b_i}{a+b_i} i=1∑m​a+bi​a​=m−i=1∑m​a+bi​bi​​ 对后面的分式进行一个泰勒的展开。 f(x)=∑i=0∞f(i)x0i!(x−x0)if(x) = \\sum_{i=0}^{\\infty } \\frac{f^{(i)}{x_0}}{i!} (x - x_0)^i f(x)=i=0∑∞​i!f(i)x0​​(x−x0​)i 后在 x=1.5x = 1.5x=1.5 处展开后面的 x−x0x - x_0x−x0​ 就已经可以忽略了 T2 一棵带权树，每次给两个人两条路径，速度为 111 ， 判断是否存在一个时刻，两个人在一条边上（不算顶点） 分情况讨论，判断路径交不交先，有交分为两种情况： 同向时，如果他们到达路径交的时间差 小于 交上最长的一条边就行。维护区间max 相向时，判断是不是在点上相遇。二分或者倍增跳 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270// 我向你走🚶‍♂️了 99 步, 但看到你💃后退 1 步后，我就无法在向前了😭🏃‍♂️🏃‍♂️#include &lt;bits/stdc++.h&gt;#define MAXN 10005using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; &#125; template &lt;typename T&gt; inline void print(T x) &#123; if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x; if (x &gt; 9) print(x / 10); putchar(x%10 + &#x27;0&#x27;); &#125; template &lt;typename T, typename ...TT&gt; inline void read(T &amp;x, TT &amp;...y) &#123; read(x); read(y...); &#125; #define p_ putchar(&#x27; &#x27;); #define pn putchar(&#x27;\\n&#x27;); #define print_(x) print(x), putchar(&#x27; &#x27;); #define printn(x) print(x), putchar(&#x27;\\n&#x27;);&#125;using namespace OCTANE;int n, m;int cnte = 1, head[MAXN];struct edge&#123; int to, nxt, dis;&#125;e[MAXN&lt;&lt;1];void adde(int u, int v, int w)&#123; e[++cnte].to = v; e[cnte].dis = w; e[cnte].nxt = head[u]; head[u] = cnte;&#125;int fa[MAXN], siz[MAXN], dep[MAXN], son[MAXN];int top[MAXN], dis[MAXN];#define v (e[i].to)void dfs1(int u, int dad)&#123; fa[u] = dad; siz[u] = 1; dep[u] = dep[dad] + 1; for (int i = head[u]; i; i = e[i].nxt) if (v != dad) &#123; dis[v] = dis[u] + e[i].dis; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if (son[u]) dfs2(son[u], tup); for (int i = head[u]; i; i = e[i].nxt) if (v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v); &#125;#undef vint LCA(int u, int v)&#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;int dwd[MAXN], cnt1, qwq[MAXN], cnt2;bool vis[MAXN];int pos[MAXN];void get_path(int u, int &amp;t, int to, int op)&#123; dwd[++cnt1] = u; qwq[cnt1] = t; vis[u] = 1; pos[u] = cnt1; if (u == to) return; if (op) t = t - dis[u] + dis[fa[u]]; else t = t + dis[u] - dis[fa[u]]; get_path(fa[u], t, to, op);&#125;void got_path(int u, int t, int to, int op)&#123; if (u == to) return; if (op == 1) got_path(fa[u], t + (dis[u] - dis[fa[u]]), to, op); else got_path(fa[u], t + (dis[u] - dis[fa[u]]), to, op); dwd[++cnt1] = u; qwq[cnt1] = t; vis[u] = 1; pos[u] = cnt1;&#125;void walk(int u, int v, int t)&#123; for (int i = 1; i &lt;= cnt1; i++) vis[dwd[i]] = 0; int lca = LCA(u, v), op = 0; if (dep[u] &lt; dep[v]) &#123; t += dis[u] + dis[v] - 2 * dis[lca]; swap(u, v); op = 1; &#125; cnt1 = 0; get_path(u, t, lca, op); if (op == 1) t = t - dis[v] + dis[lca]; else t = t + dis[v] - dis[lca]; got_path(v, t, lca, op);&#125;bool flag = 0;void get_poth(int u, int &amp;t, int to, int op)&#123; // cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; t &lt;&lt; &#x27;\\n&#x27;; if (flag || u == to) return; int v = fa[u], fat; if (op) fat = t - dis[u] + dis[fa[u]]; else fat = t + dis[u] - dis[fa[u]]; if (vis[u] &amp;&amp; vis[v]) &#123; int id = pos[u], fid = pos[v]; if ((qwq[id] - qwq[fid]) * (t - fat) &gt; 0) &#123; if (qwq[id] &gt; qwq[fid]) &#123; if (!(t &lt; qwq[fid] || fat &gt; qwq[id])) return flag = 1, void(); &#125; else &#123; if (!(t &gt; qwq[fid] || fat &lt; qwq[id])) return flag = 1, void(); &#125; &#125; else &#123; if (qwq[id] &gt; t &amp;&amp; qwq[fid] &lt; fat || t &gt; qwq[id] &amp;&amp; fat &lt; qwq[fid]) return flag = 1, void(); &#125; &#125; t = fat; get_poth(fa[u], t, to, op);&#125;void got_poth(int u, int t, int to, int op)&#123; // cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; t &lt;&lt; &#x27;\\n&#x27;; if (flag || u == to) return; int v = fa[u], fat; if (op == 1) fat = t + dis[u] - dis[fa[u]]; else fat = t - dis[u] + dis[fa[u]]; if (vis[v] &amp;&amp; vis[u]) &#123; int id = pos[u], fid = pos[v]; if ((qwq[id] - qwq[fid]) * (t - fat) &gt; 0) &#123; if (qwq[id] &gt; qwq[fid]) &#123; if (!(t &lt; qwq[fid] || fat &gt; qwq[id])) return flag = 1, void(); &#125; else &#123; if (!(t &gt; qwq[fid] || fat &lt; qwq[id])) return flag = 1, void(); &#125; &#125; else &#123; if (qwq[id] &gt; t &amp;&amp; qwq[fid] &lt; fat || t &gt; qwq[id] &amp;&amp; fat &lt; qwq[fid]) return flag = 1, void(); &#125; &#125; got_poth(fa[u], fat, to, op);&#125;bool check(int u, int v, int t)&#123; int lca = LCA(u, v); int op = 0; if (dep[u] &lt; dep[v]) &#123; t += dis[u] + dis[v] - 2 * dis[lca]; swap(u, v); op = 1; &#125; get_poth(u, t, lca, op); if (flag) return 1; if (op) t = t - dis[v] + dis[lca]; else t = t - dis[v] + dis[lca]; got_poth(v, t, lca, op); if (flag) return 1; return 0;&#125;int main()&#123; read(n, m); for (int i = 1; i &lt; n; i++) &#123; int u, v, w; read(u, v, w); adde(u, v, w); adde(v, u, w); &#125; dis[1] = 0; dfs1(1, 0); dfs2(1, 1); for (int i = 1; i &lt;= m; i++) &#123; flag = 0; int u, v, t; read(u, v, t); walk(u, v, t); // for (int j = 1; j &lt;= cnt1; j++) // cout &lt;&lt; dwd[j] &lt;&lt; &#x27; &#x27; &lt;&lt; qwq[j] &lt;&lt; &#x27;\\n&#x27;; read(u, v, t); puts(check(u, v, t) ? &quot;YES&quot; : &quot;NO&quot;); &#125; return 0;&#125;/*8 61 2 31 3 11 4 22 5 52 6 15 7 25 8 45 3 2 7 4 28 6 1 1 7 64 5 1 4 5 107 8 3 3 4 56 7 6 5 1 22 1 10 8 3 3*/ T3 kkk 维空间随机游走，每维两个方向，走 nnn 步到达的不同位置的期望。 fff 表示 nnn 步之后回到这个位置的方案数（可以经过多次） hhh 表示 nnn 步之后回到这个位置的方案数（不重复） Code 1234567891011121314151617181920212223242526272829303132333435363738int main()&#123; freopen(&quot;qaq.in&quot;, &quot;r&quot;, stdin); freopen(&quot;qaq.out&quot;, &quot;w&quot;, stdout); read(n, k, mod); m = n / 2; C[0][0] = ppw[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; ppw[i] = ppw[i-1] * 2 * k%mod; C[i][0] = 1; for (int j = 1; j &lt;= i; j++) C[i][j] = (C[i-1][j] + C[i-1][j-1])%mod; &#125; f[0] = 1; for (int i = 1; i &lt;= k; i++) &#123; memcpy(g, f, sizeof(f)); memset(f, 0, sizeof(f)); for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; j + k &lt;= m; k++) f[j + k] = (f[j + k] + g[j] * C[(j + k)*2][k * 2]%mod * C[k * 2][k])%mod; &#125; &#125; for (int i = 0; i &lt;= m; i++) &#123; h[i] = f[i]; for (int j = 1; j &lt; i; j++) h[i] = (h[i] - h[j] * f[i-j]%mod +mod)%mod; &#125; ans = (n + 1) * ppw[n] %mod; for (int i = 1; i &lt;= m; i++) ans = (ans - h[i] * ppw[n-i*2]%mod * (n - i * 2 + 1)%mod +mod)%mod; print(ans); return 0;&#125; 11.5 T1 给定一个坐标 (x,y)(x, y)(x,y) ，询问从原点跳 到这个点的最短步数和方案，每次只能移动到曼哈顿距离为 kkk 的点 构造，当 x,yx, yx,y 有一个大于 kkk 就直接走，否则我建议你看代码 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int, int&gt; pir; int k; pir f(int x, int y)&#123; if (x &gt; y) &#123; pir tmp = f(y, x); return &#123;tmp.second, tmp.first&#125;; &#125; if (x &lt; 0) &#123; pir tmp = f(-x, y); return &#123;-tmp.first, tmp.second&#125;; &#125; if (x + y &gt;= 2 * k) &#123; return &#123;x, y - k&#125;; &#125; if (x + y == k) return &#123;0, 0&#125;; int t = k - (x + y) / 2; return &#123;-t, y - k + x + t&#125;;&#125; stack &lt;pir, vector&lt;pir&gt; &gt; st; int x, y; int main()&#123; scanf(&quot;%d %d %d&quot;, &amp;k, &amp;x, &amp;y); if (!(k &amp; 1)) if ((x &amp; 1) != (y &amp; 1)) return puts(&quot;-1&quot;), 0; st.emplace(x, y); for (; x || y; x = st.top().first, y = st.top().second) st.emplace(f(x, y)); st.pop(); printf(&quot;%d\\n&quot;, st.size()); while (st.size()) &#123; printf(&quot;%d %d\\n&quot;, st.top().first, st.top().second); st.pop(); &#125; return 0;&#125; T2 nnn 个物品。 mmm 个商店。 在第 jjj 个商店买第 iii 个物品的费用是 ai,ja_{i,j}ai,j​ 。在 iii 个商店买东西需要 bib_ibi​ 的花费。 可以状压商店买不买，然后手玩发现答案是子集。高维前缀和整子集 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f3f3f3f3f#define ll long long#define MAXN 100005#define MXLG 26using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; &#125; template &lt;typename T&gt; inline void print(T x) &#123; if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x; if (x &gt; 9) print(x / 10); putchar(x%10 + &#x27;0&#x27;); &#125; template &lt;typename T, typename ...TT&gt; inline void read(T &amp;x, TT &amp;...y) &#123; read(x); read(y...); &#125; #define p_ putchar(&#x27; &#x27;); #define pn putchar(&#x27;\\n&#x27;); #define print_(x) print(x), putchar(&#x27; &#x27;); #define printn(x) print(x), putchar(&#x27;\\n&#x27;);&#125;using namespace OCTANE;#define lowbit(x) (x &amp; (-x))struct node &#123; int val, id; &#125;a[MAXN][MXLG];ll b[1&lt;&lt;25], f[1&lt;&lt;25];int main()&#123; int n, m; read(n, m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; m; j++) read(a[i][j].val), a[i][j].id = j; sort(a[i], a[i] + m, [&amp;](node x, node y) &#123; return x.val &lt; y.val; &#125;); int s = 0; for (int j = 0; j &lt; m; j++) &#123; f[s] += a[i][j].val - a[i][j - 1].val; s |= 1 &lt;&lt; a[i][j].id; &#125; &#125; int S = (1 &lt;&lt; m) - 1; for (int i = 0; i &lt; m; i++) for (int s = 1; s &lt;= S; s++) if ((s &gt;&gt; i) &amp; 1) f[s] += f[s ^ (1 &lt;&lt; i)]; for (int i = 0; i &lt; m; i++) read(b[1 &lt;&lt; i]); ll ans = INF; for (int s = 1; s &lt;= S; s++) &#123; if (s == lowbit(s)) continue; b[s] = b[lowbit(s)] + b[s ^ lowbit(s)]; &#125; for (int s = 0; s &lt; S; s++) ans = min(ans, f[s] + b[s ^ S]); print(ans); return 0;&#125; 11.7 我爹 Ak 了 11.8 T1 一个长度为 nnn 的01串，下标 0∼n−10 \\sim n-10∼n−1 。有两种操作： A: 选择一个 xxx ，将序列循环左移 xxx 位。也就是新序列的第 (i+x) mod n(i+x) \\bmod n(i+x)modn 位对应原序列的第 iii 位。 B: 选择一个 xxx , 满足序列的第 xxx 个位置为 111 , 且第 (x+1) mod n(x+1) \\bmod n(x+1)modn 位置不为 111 , 交换序列的第 $x $ 个位置和第 (x+1) mod n(x+1) \\bmod n(x+1)modn 个位置的字符。 构造一个由 lll 个长度为 nnn 的01串构成的序列 sss ，使得序列中每个串恰好有 kkk 个 111 。且对于 0≤i&lt;l−10 \\leq i&lt;l-10≤i&lt;l−1 , s[i] 既可以通过一种 A 类型的操作, 也可以通过一种 B 类型的操作, 变为 s[i+1] 。 设 sss 中所有 111 下标之和为 www 对于第一个操作，那么整体左移一位也就是说有一个 xxx 使得 wi+x×k≡wi+1 mod nw_i + x\\times k \\equiv w_{i+1} \\bmod nwi​+x×k≡wi+1​modn 对于第二个操作，那么就是说 wi+1≡wi+1 mod nw_i + 1\\equiv w_{i+1} \\bmod nwi​+1≡wi+1​modn 那么 n×k≡1 mod nn \\times k \\equiv 1 \\bmod nn×k≡1modn ，也就是说 kkk 在 mod n\\bmod \\; nmodn 有逆元 xxx ，所以 n,kn, kn,k 互质 然后构造方案的话，使 s[i]的 ik,i+1k,⋯ ,k+i−1k\\frac{i}{k}, \\frac{i+1}{k}, \\cdots, \\frac{k+i-1}{k}ki​,ki+1​,⋯,kk+i−1​ 为 111 就行 T2 nnn 个字符串，从每个字符串里选出一个任意一个非空前缀按任意顺序组成一个新字符串。使得这个字符串最小 正解听难想的，因为 nnn 很小 , 长度也很小。使用机房 :: 的随机化算法，随机选取 nnn 个串的顺序开搜 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 55;int n;string s[MAXN];string dfs(int x)&#123; if (x == n) return s[x].substr(1, 1); string ans = dfs(x + 1); vector &lt;string&gt; tmp; for (int i = 1; i &lt; s[x].size(); i++) tmp.push_back(s[x].substr(1, i) + ans); sort(tmp.begin(), tmp.end()); return tmp[0];&#125;string ans;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i], s[i] = &quot; &quot; + s[i]; ans = dfs(1); sort(s + 1, s + 1 + n); int tim = 4500; while (tim--) &#123; int l = rand()% n + 1; int r = rand()% n + 1; swap(s[l], s[r]); string tmp = dfs(1); if (tmp &lt; ans) ans = tmp; else swap(s[l], s[r]); &#125; cout &lt;&lt; ans; return 0;&#125; T3 一棵 111 为根的树，从 111 出发, 每条边需要一定的价值才能开通，到达除 111 外的每个节点都可以获得一定的价值，询问要到达某个叶子节点开始需要准备的最小价值。 挺经典的打怪问题。 先考虑如果是一个序列的话。能赚的放在前边，能赚的里要钱少的放在前边，会亏的放在后边，会亏的里回血多的放在前面。 既然在树上，我们就找到这样排在最前边的节点，从他回到 111 ，直到能够到达询问的节点。 具体可以对每个结点维护一个 set 然后合并到根节点。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline bool read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); if (ch == EOF) return false; while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; return true; &#125; template &lt;typename T&gt; inline void print(T x) &#123; if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x; if (x &gt; 9) print(x / 10); putchar(x%10 + &#x27;0&#x27;); &#125; template &lt;typename T, typename ...TT&gt; inline void print(T x, char c) &#123; print(x); putchar(c); &#125; template &lt;typename T, typename ...TT&gt; inline int read(T &amp;x, TT &amp;...y) &#123; return read(x) + read(y...); &#125;&#125;using namespace OCTANE;#define ll long long#define pir pair&lt;ll, ll&gt;const int MAXN = 2e5 + 10;const ll INF = 0x3f3f3f3f3f3f3f3f;int n;multiset &lt;pir&gt; s[MAXN];vector &lt;int&gt; e[MAXN];ll val[MAXN], cost[MAXN];void dfs(int u)&#123; for (int v : e[u]) &#123; dfs(v); if (s[u].size() &lt; s[v].size()) s[u].swap(s[v]); s[u].insert(s[v].begin(), s[v].end()); s[v].clear(); &#125; ll cst = cost[u], w = val[u] - cost[u]; while (!s[u].empty() &amp;&amp; (w &lt;= 0 || cst &gt;= s[u].begin()-&gt;first)) &#123; auto tmp = *s[u].begin(); cst += max(0ll, tmp.first - cst - w); w += tmp.second; s[u].erase(s[u].begin()); &#125; if (w &gt; 0) s[u].emplace(cst, w);&#125;int main()&#123; read(n); cost[1] = INF; for (int i = 2; i &lt;= n; i++) &#123; int f; read(f, val[i], cost[i]); f++; e[f].push_back(i); if (val[i] == -1) val[i] = INF &lt;&lt; 1; &#125; dfs(1); cout &lt;&lt; s[1].begin()-&gt;first - INF; return 0;&#125; 11.9 T1 nnn 个点的树，有点权，您有血量，到达一个点就会获得这个点的点权，如果血量小于 000 就寄。每次给出初始血量，询问能否从 sss 走到 ttt 点。可以经过别的的点，也可以多次经过一个点，没经过一次都会获得相应的点权 能行是这两种情况。 直接走，或者去到路径外的地方加血。 如果相邻两个点的值加起来是正的，那么就可以在这两个点加很多血量。 第一种情况维护前缀和最小值，第二种情况 DP 求每个点到达特殊点需要的最少血量。 T2 对于一个 1,…,n1,…,n1,\\dots,n1,…,n1,…,n1,…,n 的排列 a1,…,ana_1,\\dots,a_na1​,…,an​ ，定义 iii 处的顺序对数 f(i)f(i)f(i) 为满足 $ 1\\leq j$ 且 aj&lt;aia_j &lt; a_iaj​&lt;ai​ 的 jjj 的数量，给定 nnn ，对于每个 k=0,1,…,n−1k=0,1,\\dots,n-1k=0,1,…,n−1 求出满足 max⁡i=1n∣f(i)−g(i)∣=k\\max_{i=1}^n |f(i) - g(i)| = kmaxi=1n​∣f(i)−g(i)∣=k 的数量模 109+710^9+7109+7 一个一个算不好整，我们把等号变成小于号，然后差分得到答案。 11.10 T1 ∑in∑jm[gcd(i,j)≤a]lcm(i,j)\\sum_{i}^{n} \\sum_{j}^{m} \\left [ gcd(i,j) \\le a \\right ] lcm(i, j) i∑n​j∑m​[gcd(i,j)≤a]lcm(i,j) n≤105n \\le 10^5n≤105 并且 10410^4104 次询问。 \\begin{align} &amp;\\sum_{i}^{n} \\sum_{j}^{m} \\left [ gcd(i,j) \\le a \\right ] lcm(i, j) \\nonumber\\\\ =&amp;\\sum_{i}^{n} \\sum_{j}^{m} \\left [ gcd(i,j) \\le a \\right ] \\frac{ij}{gcd(i,j)} \\nonumber\\\\ \\end{align} 枚举 gcdgcdgcd , i/ki / ki/k 替换 iii , j/kj / kj/k 替换 jjj ∑kak∑i⌊nk⌋∑j⌊mk⌋[gcd(i,j)=1]ij\\sum_{k}^{a} k\\sum_{i}^{\\left \\lfloor \\frac{n}{k}\\right \\rfloor} \\sum_{j}^{\\left \\lfloor \\frac{m}{k}\\right \\rfloor} \\left [ gcd(i,j) = 1 \\right ]ij k∑a​ki∑⌊kn​⌋​j∑⌊km​⌋​[gcd(i,j)=1]ij 开始经典莫反 \\begin{align} &amp;\\sum_{k}^{a} k \\sum_{i}^{\\frac{n}{k}} \\sum_{j}^{\\frac{m}{k}} \\left [ gcd(i,j) = 1 \\right ]ij \\nonumber\\\\ =&amp;\\sum_{k}^{a} k \\sum_{d}^{\\left \\lfloor \\frac{lim}{k}\\right \\rfloor} \\mu(d) d^2\\sum_{i}^{\\left \\lfloor \\frac{n}{kd}\\right \\rfloor} \\sum_{j}^{\\left \\lfloor \\frac{m}{kd}\\right \\rfloor} ij \\nonumber\\\\ =&amp;\\sum_{k}^{a} k \\sum_{d}^{\\left \\lfloor \\frac{lim}{k}\\right \\rfloor} \\mu(d) d^2\\sum_{i}^{\\left \\lfloor \\frac{n}{kd}\\right \\rfloor} \\times \\sum_{j}^{\\left \\lfloor \\frac{m}{kd}\\right \\rfloor} \\nonumber\\\\ \\end{align} 现在后面两个 O(1)O(1)O(1) 等差数列整 前面调和级数 单次询问 O(nlogn)O(nlogn)O(nlogn) 现在可以整除分块 kkk 和 ddd 。单次询问是接近 O(n)O(n)O(n) 。 都只能50pts 所以还需优化 注意到答案随 aaa 单调增 可以先把询问离线下来，按从小到大排序。新加入一个 aaa 就加入后面那一坨对应了答案。可以用树状数组维护 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;#define ll long longconst ll mod = 1e9 + 7;const ll inv2 = 500000004;const int MAXN = 1e5 + 5;const int maxn = 1e5;using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline bool read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); if (ch == EOF) return false; while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; return true; &#125; template &lt;typename T&gt; inline void print(T x) &#123; if (x &lt; 0) putchar(&#x27;-&#x27;), x = -x; if (x &gt; 9) print(x / 10); putchar(x%10 + &#x27;0&#x27;); &#125; template &lt;typename T, typename ...TT&gt; inline void print(T x, char c) &#123; print(x); putchar(c); &#125; template &lt;typename T, typename ...TT&gt; inline int read(T &amp;x, TT &amp;...y) &#123; return read(x) + read(y...); &#125;&#125;using namespace OCTANE;#define cntp prime[0]bool pis[MAXN];int prime[MAXN];ll mu[MAXN];struct Bit&#123; #define lowbit(i) (i &amp; -i) ll t[MAXN], lim; void add(int i, ll val) &#123; if (!i) return; for (; i &lt;= lim; i += lowbit(i)) t[i] = (t[i] + val)%mod; &#125; ll query(int i) &#123; ll res = 0; for (; i; i -= lowbit(i)) res = (res + t[i])%mod; return res; &#125; ll query(int l, int r) &#123; return (query(r) - query(l-1) +mod)%mod; &#125;&#125;t;void get_prime(int n)&#123; pis[1] = mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!pis[i]) &#123; prime[++cntp] = i; mu[i] = -1; &#125; for (int j = 1; j &lt;= cntp &amp;&amp; i * prime[j] &lt;= n; j++) &#123; pis[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125;&#125;struct que &#123; int n, m, a, id; &#125;q[MAXN];ll S(ll x, ll y) &#123; return (x + y) * (y - x + 1)%mod * inv2%mod; &#125;void add(int x)&#123; for (int i = x; i &lt;= maxn; i += x) &#123; t.add(i, 1LL*i * 1LL*i / x%mod * mu[i / x]%mod); &#125;&#125;ll work(int n, int m)&#123; ll res = 0; int N = min(n, m); for (int l = 1, r; l &lt;= N; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); res = (res + S(1LL, (ll)(n / l)) * S(1LL, (ll)(m / l))%mod * t.query(l, r)%mod) %mod; &#125; return res;&#125;ll ans[MAXN];int main()&#123; t.lim = maxn; get_prime(maxn); int T; read(T); for (int i = 1; i &lt;= T; i++) &#123; int n, m, a; read(n, m, a) ; q[i] = &#123; n, m, a, i &#125;; &#125; sort(q + 1, q + 1 + T, [&amp;](que a, que b) &#123; return a.a &lt; b.a; &#125;); int now = 1; for (int i = 1; i &lt;= T; i++) &#123; while (now &lt;= q[i].a) add(now++); ans[q[i].id] = work(q[i].n, q[i].m); &#125; for (int i = 1; i &lt;= T; i++) print(ans[i], &#x27;\\n&#x27;); return 0;&#125; T2 一张联通的平面图，两种操作： 删去边 (x,y)(x, y)(x,y) ，并且询问几个连通块 询问点 x,yx, yx,y 是否在同一连通块内 这是一张平面图。就建出它的对偶图来 我们每删去一条边，就把它在对偶图对应的边连起来。当对偶图的边把一个部分围起来时，这个部分就形成了一个新的连通块。 对于第二种询问，我们在形成一个新连通块中，可以对新的连通块重新编号。但是尽量遍历少的点保证时间复杂度，我们就选择大小小的联通块来标号。 11.11 T1 给定一个序列，每个数都是由两个不相同的质数的乘积。若 a=p1∗q1(p1&lt;q1),b=p2∗q2(p2&lt;q2)a=p_{1} * q_{1}\\left(p_{1}&lt;q_{1}\\right), b=p_{2} * q_{2}\\left(p_{2}&lt;q_{2}\\right)a=p1​∗q1​(p1​&lt;q1​),b=p2​∗q2​(p2​&lt;q2​) ， q1=p2q_1 = p_2q1​=p2​ 时， bbb 能接在 aaa 后。最长能接多长？。 对于每个数，向 ppp 的值和它的 qqq 相等的连边，表示它俩能接起来。 最后建出来是一张 DAG 。在上面找最长链即可。 T2 nnn 个点 mmm 条边，给一个生成树，可以把一条边权减一，询问要多少操作才能使他成为最小生成树。 两个点在如果有路径的话，那么生成树的路径上的每一条边的边权都不能大于它才能成为最小生成树。 所以枚举每条非树边，对树上路径进行最小值覆盖。最后边权减少了多少就是答案。 T3 给定两个数 AAA , BBB 。问有多少序列满足： 序列递增 值域 ∈[A,B]\\in [A, B]∈[A,B] 所有数字两两互质。 虽然 A,BA, BA,B 是 101810^{18}1018 级别，但是 B−A≤100B - A \\le 100B−A≤100 ，那么可以状压 100100100 以内的质数来 DPDPDP 。 只出现一次也没影响，那么状压只出现多次的质因子就行了。 DP 就是枚举补集的子集更新。 T4 给定一个序列，询问序列的最长子串。能够最多加 kkk 个数构成公差为 ddd 的等差数列。 考虑能构成等差数列的话，那么字串里的每个数 mod d\\bmod dmodd 都相等。所以判断条件就是 mod 的\\bmod 的mod的 相等并且除的极差 −-− 区间长度不超过 kkk 。 右端点确定，左端点具有单调性。所以枚举右端点，线段树维护每个左端点的极差。 枚举整俩单调栈，然后在线段树上二分找答案。 11.12 T1 一颗带权树，树上有黑点和白点，求割掉一些边，把黑点和白点分开需要的最小代价。 fu,0/1f_{u, 0/1}fu,0/1​ 表示在 uuu 强制为 黑点/白点 时的答案。 和儿子不一样就要割掉这条边。不合法情况赋极小值 T2 nnn 道题目，每道题您需要 aia_iai​ 的时间来 A 掉。做 mmm 道题您就能 AuAuAu ，但是您不知道每个题的难度，只知道找人写题目的难度构成 aaa 这个序列。求使用最优策略最坏要多长时间才能 AuAuAu 。 因为是最坏，所以做的题的难度一定是下降的。也就是说题目难度和时间是一个下降的直线。 那么要 A 一道题一定是每次都用这道题的时间做，然后发现没A ，就换下一道题，知道 A 掉这道题。 设 fi,jf_{i, j}fi,j​ 表示做到第 iii 道题，已经 A 了 jjj 到需要的时间。 fi,j=fk,j−1+(i−k)∗aif_{i,j} = f_{k, j-1} + (i-k) * a_ifi,j​=fk,j−1​+(i−k)∗ai​ 发现可以斜率优化。 11.14 T1 平面直角坐标系上，从 (a,b)(a, b)(a,b)，每次可以上下左右走一个单位(保证坐标非负)。走到 (c,d)(c,d)(c,d)。疲劳值初始值为 000。如果当前位置 (x,y)(x,y)(x,y) 满足 x and⁡ y&gt;0x \\, \\operatorname{and} \\, y &gt; 0xandy&gt;0，疲劳值就要加 111，否则疲劳值不增加。求最小疲劳值。 打个表可以发现，xand⁡y=0x \\operatorname{and} y = 0xandy=0 的位置组成了一个谢尔宾斯基三角形。 而且是四联通的，所以我们从 (a,b)(a,b)(a,b) 走到 (c,d)(c,d)(c,d) 就有两种可能是最优的方案： 都走到费用为 000 的点。 直接走 那个三角形看上去挺递归的，我们也递归求。 找到覆盖 (x, y) 的三角形。由于 dis(x,y)=dis(y,x)dis(x, y) = dis(y, x)dis(x,y)=dis(y,x) ，设 x≤yx \\le yx≤y。 设三角形的边长为 LLL 。 如果 x+y≥Lx + y \\ge Lx+y≥L ，说明 (x,y)(x, y)(x,y) 位于该正方形右下部分的等腰直角三角形，走到三角形三边的疲劳值分别是 x+y−L,L−x−1,L−y−1x + y - L, L - x - 1, L - y - 1x+y−L,L−x−1,L−y−1，取最小值 否则 (x,y)(x, y)(x,y) 在该正方形右上部分。把 向左平移 L/2L / 2L/2 长度不改变答案，所以直接平移递归下去。 T2 给你一个只包含字符 a 和 b 的字符串 sss，你需要求出最多有多少不相交的子序列 abab。 不相交的定义为：对于 sss 种的每个字符，其最多处于一个子序列中。 Solution 发现 abab 可以拆成两个 ab，问题就变成了去除尽可能多的不相交的 ab 。 不能同时选的 ab 存在一个分界点 p∈[1,n]p \\in [1,n]p∈[1,n]，使得所有 a 的位置小于等于 ppp，所有 bbb 的位置大于等于 ppp。 设不能同时选的 ab 的最大值为 mxmxmx，共有 cntcntcnt 对 ab，那么答案就是 min⁡(⌊cnt2⌋,cnt−mx)\\min(\\lfloor \\frac{cnt}{2} \\rfloor, cnt-mx)min(⌊2cnt​⌋,cnt−mx)。 现在就需要使 mxmxmx 最小化，这个可以使每个 bbb 去匹配它前面最近的未被匹配的 aaa，这样可以使这一对 ab 包含的其他 ab 最少，所以用一个栈做一下括号匹配就行了。 T3 用 000 代表空树，如果一个节点没有左子树，那么认为它的左子树是空树(右子树同理)。对任意二叉树 AAA，0≤A0 \\le A0≤A 成立；对任意非空二叉树 AAA，A≤0A \\le 0A≤0 不成立，则对于非空二叉树 A,BA,BA,B，A≤BA \\le BA≤B 当且仅当 ls⁡(A)≤ls⁡(B)\\operatorname{ls}(A) \\le \\operatorname{ls}(B)ls(A)≤ls(B) 且 rs⁡(B)≤rs⁡(A)\\operatorname{rs}(B) \\le \\operatorname{rs}(A)rs(B)≤rs(A)。 问有多少不同在 AAA 上加 mmm 个点的 BBB ，满足 A≤BA \\le BA≤B。 我们只能在特定的节点放，可以一次 dfsdfsdfs 求出。 有 ccc 个互相独立的位置，放上 mmm 个节点，问最终形成的二叉树森林有几种。 设 f(c,m)f(c,m)f(c,m) 表示上述问题的答案。 f(c,m)=f(c+1,m−1)+f(c−1,m)f(c,m) = f(c+1,m-1) + f(c-1, m)f(c,m)=f(c+1,m−1)+f(c−1,m) ，因为 如果有一个节点挂在第 ccc 个位置，节点数减少 111，互相独立的位置数反而增加了 111，状态转移为 f(c+1,m−1)f(c+1,m-1)f(c+1,m−1)。 如果没有节点挂在第 ccc 个位置，也就是再也不用位置 ccc，状态转移为 f(c−1,m)f(c-1,m)f(c−1,m)。 这个式子可以转化为路径计数： 如果位置在 (x,y)(x,y)(x,y)，下一步可以走到 (x−1,y+1)(x-1,y+1)(x−1,y+1) 或 (x+1,y)(x+1,y)(x+1,y)，但始终保证 x&gt;0x &gt; 0x&gt;0，求从 (1,0)(1,0)(1,0) 走到 (c,m)(c,m)(c,m) 的路径条数。 把坐标变换为 (x+y,y)(x+y, y)(x+y,y)，得到更熟悉的形式： 如果位置在 (x,y)(x,y)(x,y)，下一步可以走到 (x,y+1)(x,y+1)(x,y+1) 或 (x+1,y)(x+1,y)(x+1,y)，但始终保证 x&gt;yx &gt; yx&gt;y，求从 (1,0)(1,0)(1,0) 走到 (c+m,m)(c+m,m)(c+m,m) 的路径条数。 答案为 Cc+2m−1m−Cc+2m−1cC_{c+2m-1}^{m} - C_{c+2m-1}^{c}Cc+2m−1m​−Cc+2m−1c​","categories":[],"tags":[]},{"title":"csp 2022游记","slug":"csp-2022游记","date":"2022-10-30T06:13:06.000Z","updated":"2022-11-08T10:40:12.419Z","comments":true,"path":"2022/10/30/csp-2022游记/","link":"","permalink":"https://ve1bae.github.io/2022/10/30/csp-2022%E6%B8%B8%E8%AE%B0/","excerpt":"我是 fwfwfwfw 已经做好退役准备了嗷 🏃🏃🏃","text":"我是 fwfwfwfw 已经做好退役准备了嗷 🏃🏃🏃 day -8 来到石家庄隔离，爽看 day 0 晚上爽看 day 1 上午爽看 下午寄 进场开考 wc奔腾电脑 dev 把我 👀 整瞎了嗷 T1 开考先看了将近一个半小时 还是一点儿思路都没，连 n4n^4n4 都不会，爽寄 可能是个 DP ? 但是太离谱了没法写吧 最后还是觉得爆搜最对味辣 😅 润润润 🏃 T2 一眼顶针鉴定为大力分类讨论 线段树维护乱七八糟最值开码 代码能力还是拉，de了一段时间bug 40min 润。 🏃 写完上个厕所寻找思路 T3 看上去应该是要判个环什么的，没什么思路 最后暴力没时间写了，爽寄 🏃🏃🏃 T4 先写了个 k = 1 ，不会树上差分所以 树剖 + 线段树开码 然后觉得肯定是在选在链上的点，把链拉出来 写了个 nqnqnq DP 调到结束刚过小样例。润了 🏃 最后都没时间没整压缩文件急死我了 🏃🏃🏃 赛后 出考场佬告诉我 nm虚拟机有 nm Vscode 还有nm cpptools 逆大天。 说不定这是唯一一次能在场上开挂的机会力 估分 40 + 100 + 0 + 52 = 192 机房佬全都 300+。还是我太菜了 晚上爽看 寄寄寄寄。 day2 回学笑了 民间数据 45 + 90 + 0 + 16 = 151 T2 挂了 10分 T4 DP 寄了。赛后发现连大样例都没过 原来更菜啊 滚回机房爽睿 …哈哈没写过对拍，不知道怎么 fc ，用 👀 测大样例了 逆天卧槽， T2 90分 原来是一种情况输出每换行卧槽！！ 要挂成 0 🥚 了 😭😭😭😭😭 原来民间数据是真民间啊 原来官方数据时更民间啊 55 + 65 + 0 + 20 = 140 😆😆😆😆😭😭😭😭 希望 noip 我不会输出 NO 也能拿45分 赞美","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"https://ve1bae.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"fan_si_gui_hua","slug":"fan-si-gui-hua","date":"2022-10-09T13:46:28.000Z","updated":"2022-11-08T10:40:24.451Z","comments":true,"path":"2022/10/09/fan-si-gui-hua/","link":"","permalink":"https://ve1bae.github.io/2022/10/09/fan-si-gui-hua/","excerpt":"","text":"反思的话没什么好说毕竟已经达到极限了的今后也要更加努力的奖励自己 目前的人生规划是AK国际初中生信息学竞赛然后顺势去八幡市竞选市长迎娶前任市长的女儿让她回到已经被我用摩拉收购的京阿尼担任监督在动用妻子的关系要到山田尚子的签名最终的目的是跪在她的脚边求她能够强势回归或者让我把京阿尼送给她也没事毕竟是神反正只要做出京吹三只给我一个人看就行了","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ve1bae.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://ve1bae.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"10月每日总结","slug":"10月每日总结","date":"2022-10-08T00:55:25.000Z","updated":"2022-11-11T10:47:47.776Z","comments":true,"path":"2022/10/08/10月每日总结/","link":"","permalink":"https://ve1bae.github.io/2022/10/08/10%E6%9C%88%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/","excerpt":"日々私たちが過ごしている日常は、実は、奇跡の連続なのかもしれない。 我们所经历的每个平凡的日常，也许就是连续发生的奇迹。 ——《日常》","text":"日々私たちが過ごしている日常は、実は、奇跡の連続なのかもしれない。 我们所经历的每个平凡的日常，也许就是连续发生的奇迹。 ——《日常》 10.1 T1 有一款游戏，它有 nnn 个关卡，第 nnn 个关卡的难度是 pip_ipi​，已知 nnn 是 1,…,n1,\\dots,n1,…,n 的一个排列。玩家不必按照 111 到 nnn 的顺序通过这 nnn 个关卡，他们可以自己选择闯关的顺序。对于每一个关卡，游戏定义了一个重要度 did_idi​ ，为 ppp 的前缀最小值，小k每次惠选择 ddd 最低的关卡闯关，特殊地，如果这样的关卡有很多个，那么他会选择编号最小的那一个。给出小k 通关的顺序，求出所有可能的难度中字典序最小的 简单构造。先构造 ddd ，必要的时候加一，也就是说 aaa 的下标比 bbb 的下标更靠前，却先打了 bbb ，那么 aaa 的重要度一定是更高的 然后根据 ddd 构造 ppp 即可 T2洛谷 P3616 小P的家门前有一条河，它每天要观察这条河，并且统计河中岛屿的个数。河床的地形可以抽象为一个长度为 nnn 的数列 ai{a_i}ai​，第 iii 位的数字代表河床对应位置的高度。当水位为 hhh 时，所有高度低于 hhh 的位置都会被水覆盖，高度大于等于 hhh 的地形就露出水面，连成了岛屿。请你协助小 P 统计每一天的岛屿的个数。河床每个位置的高度可能会发生变化，而且水位也会发生变化。 如果形成了岛屿一定是 hi≥h,hi+1&lt;hh_i \\ge h, h_{i+1} &lt; hhi​≥h,hi+1​&lt;h 那么以 hih_ihi​ 为横坐标，hi+1h_{i+1}hi+1​ 为纵坐标构建一个二维平面那么答案应该是这部分 使用树状数组维护 T3 给定一个只由非负整数和加减号组成的算式。它想给这个算式添加合法的括号，使得算式的结果最大，括号可以嵌套。 线性 dp fi,jf_{i, j}fi,j​ 表示前 iii 个数，缺了 jjj 个右括号需要配对的最大答案，根据当前位置加什么括号转移 Code 1234567891011121314f[0][0] = 0;f[0][1] = f[0][2]=-1e18;for (int i = 1; i &lt;= n; i++) if (a[i] &lt; 0)&#123; f[i][0] = f[i-1][0] + a[i]; f[i][2] = max(f[i-1][1], f[i-1][2]) - a[i]; f[i][1] = max(max(f[i-1][0], f[i-1][1]), f[i-1][2]) + a[i];&#125;else&#123; f[i][0] = max(max(f[i-1][0], f[i-1][1]), f[i-1][2]) + a[i]; f[i][1] = max(f[i-1][1], f[i-1][2]) - a[i]; f[i][2] = f[i-1][2] + a[i];&#125; 10.2 T1 有两类奇特的生物 A 和 B，其基因序列只由 l 和 t 两种字母组成。一开始，两类生物体内的基因序列都是一个 l，A 类生物体内的 l 基因可能突变为 lt 和 ltl，B 类生物体的 l 基因则可能突变为 ltl,lt 和 tl。给定一些生物的基因序列，判断是否可能属于 A 类 和 B 类 首先不可能出现连续的两个 l 对于 A 类来说，实际上是在 l 后插入 t 或 tl，那么绝对不可能有 t 前面没有 l T2 给定一棵 nnn 个结点构成的树。你需要给树上的 nnn 个结点进行编号，其中有 aaa 个结点需要编号为 1,2,…,a1,2,\\dots,a1,2,…,a 中的不重复的编号作为白点；剩下的 bbb 个结点需要编号为 −1,−2,…,−b-1,-2,\\dots,-b−1,−2,…,−b 中的不重复的编号，作为黑点现在有一个程序，它会对这棵树运行 次如下步骤：从黑色和白色中随机一个颜色，且需要保证目前图上仍然存在这种颜色的点。如果随机到的是白色，程序将会删除编号绝对值最小的白点，并删除与之相连的所有边；如果随机到的是黑色，程序将会删除编号绝对值最小的黑点，并删除与之相连的所有边。请给这些点合适的编号，使得任何情况下，程序运行过程中都不会出现剩余未被删除的点不连通的情况 我们把整棵树分为大小分别为 aaa 和 bbb 的两部分，从叶子节点分别向上标号即可 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int siz[MAXN], fa[MAXN];void dfs1(int u, int dad)&#123; siz[u] = 1; fa[u] = dad; for (int v : e[u]) if (v != dad) &#123; dfs1(v, u); siz[u] += siz[v]; &#125;&#125;void worka(int u, int dad)&#123; for (int v : e[u]) if (v != dad) &#123; worka(v, u); &#125; num[u] = ++cnta;&#125;void workb(int u, int dad)&#123; for (int v : e[u]) if (v != dad) &#123; workb(v, u); &#125; num[u] = --cntb;&#125;int main()&#123; dfs1(1, 0); for (int i = 1; i &lt;= n; i++) &#123; if (siz[i] == a) &#123; flag = 1; worka(i, fa[i]); workb(fa[i], i); break; &#125; if (siz[i] == b) &#123; flag = 1; workb(i, fa[i]); worka(fa[i], i); break; &#125; &#125;&#125; T3 有一棵 nnn 个结点的树，编号为 111 到 nnn ，每个点有一个颜色，颜色编号的范围是 111 到 mmm，保证每种颜色至少出现一次。 你需要选择一个结点作为根，同时找一个树上节点的非空子集 TTT ，满足每种颜色都至少在 TTT 中出现一次，并且 TTT 中所有点的 LCALCALCA 的深度最大。定义你选的根深度为 111 ，儿子的深度是父亲深度 +1+1+1 。 枚举 LCALCALCA ，问题实际上变为了选取 LCALCALCA 的某些子树作为点集，在剩下的子树中找以 LCALCALCA 为一端的最长链，以另一端作为根 使用 dsu on tree 维护点集颜色即可 10.3 T1 小 C 生活的城市可以用一个长度为 nnn 的线段来表示。线段上（包含端点）平均分布着 n+1n+1n+1 个点，从左到右编号为 1,…,n+11,\\dots,n+11,…,n+1 。 他将第 iii 个点称为 AiA_iAi​ ，线段 AiAi+1(i≤i≤n)A_iA_{i+1} (i \\leq i \\leq n)Ai​Ai+1​(i≤i≤n) 称为第 iii 个区。第 iii 个区的人对晴天的渴望度形式化成 sis_isi​。 晴天的范围不能覆盖整个城市，形式化地说，若 ApA_pAp​ 为覆盖范围的中心，那么当且仅当第 iii 个区和 ApA_pAp​ 之间隔着的区域少于 ddd 个（不包括第 iii 个区本身），第 iii 个区会被晴天覆盖。 如果第 iii 个区在晴天的覆盖范围内，并且和晴天中心还隔着 xxx 个区，那么这个区的人的开心值为 (d−x)2×si(d-x)^2 \\times s_i(d−x)2×si​ 。这个城市的开心值为每一个区的开心值之和。 小 C 想知道如果晴天的地点可以任选，那么最后城市的开心值最大是多少。 我们分别处理中心左右两侧的贡献 假如 d=3d = 3d=3 ，那么周围这些区的贡献的系数为 9,4,1，09, 4, 1，09,4,1，0 ，中心向后移动一个点，系数变为 0,9,4,10, 9, 4, 10,9,4,1 ，变化了 5,3,15, 3, 15,3,1 ，维护中心移动的变化 O(n)O(n)O(n) 扫一遍 需要 O(1)O(1)O(1) 维护变化，动态维护 ddd 项的和。 Code 12345678910111213141516171819202122232425262728293031for (int i = 1; i &lt;= d; i++) &#123; ans1[1] += (d - i + 1) * (d - i + 1) * a[i]; if (i &gt; 1) tmp += (d - i + 1) * a[i];&#125;for (int i = 1; i &lt;= n; i++) &#123; int l = max(1, i), r = min(n, i + d); ans1[i + 1] = (ans1[i] - d * d * a[i] + tmp * 2 + sum[r] - sum[l]); tmp += sum[r] - sum[l]; tmp -= a[i + 1] * d;&#125;reverse(a + 1, a + 1 + n);for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a[i];tmp = 0;for (int i = 1; i &lt;= d; i++) &#123; ans2[1] += (d - i + 1) * (d - i + 1) * a[i]; if (i &gt; 1) tmp += (d - i + 1) * a[i];&#125;for (int i = 1; i &lt;= n; i++) &#123; int l = max(1, i), r = min(n, i + d); ans2[i + 1] = (ans2[i] - d * d * a[i] + tmp * 2 + sum[r] - sum[l]); tmp += sum[r] - sum[l]; tmp -= a[i + 1] * d;&#125;reverse(ans2 + 1, ans2 + 2 + n);for (int i = 1; i &lt;= n + 1; i++) &#123; ans = max(ans, ans1[i] + ans2[i]);&#125; T2 给一个长度为 nnn 的序列 AAA ，你可以删去原序列的一些数，或者一个数都不删除，将剩下的数按照原来的顺序组成新的长度为 m(1≥m≥n)m(1 \\ge m \\ge n)m(1≥m≥n) 的序列 。 现在你想知道，对于所有合法的序列 BBB ，∑i=1m[Bi=i]\\sum_{i=1}^{m}\\left[B_{i}=i\\right]∑i=1m​[Bi​=i] 的最大值是多少。 先考虑暴力DP fif_{i}fi​ 表示 前 iii 个数 ，以 iii 结尾的答案 f(i)=max⁡{f(j)+1∣j&lt;i,aj&lt;ai,ai−aj&lt;i−j}f(i)=\\max \\left\\{f(j)+1 \\mid j&lt;i, a_{j}&lt;a_{i}, a_{i}-a_{j}&lt;i-j\\right\\} f(i)=max{f(j)+1∣j&lt;i,aj​&lt;ai​,ai​−aj​&lt;i−j} 那么转移的条件就是 : j&lt;ij &lt; ij&lt;i aj&lt;aia_j &lt; a_iaj​&lt;ai​ ai−aj&lt;i−ja_i - a_j &lt; i - jai​−aj​&lt;i−j 将序列按照 aia_iai​ 排序，然后求⼀个最⻓的 i−aii - a_ii−ai​ 不下降的⼦序列⻓度即可 10.4 div.1 T1 小 A 和小 B 竞选班长流程如下： 在 [1,n][1, n][1,n] 中随机选取一个区间 [l,r][l, r][l,r] ，统计区间内同学的投票情况，如果二人票数之差的绝对值不超过 kkk ，那么平局，都是班长；否则票数高的同学当选。小 A 担心落选，准备收买一些同学，使得在任何情况下自己都能成为班长。已知收买编号为 iii 的同学的花费为 2i2^i2i，请问小 A 的最少花费是多少 进行一个贪心，每次在不满足的情况下选取下标最小的人收买，所以倒序枚举，不行就收买一下 T2 有 nnn 个被抽象成矩形的同学在拍照。其中第 iii 个同学宽为 wiw_iwi​ ，高为 hih_ihi​ 。 需要宽为所有 www 之和，高为所有 hhh 最大值的相框才能容下所有的同学。 为了缩小相框的面积，你可以让一部分同学躺下。第 iii 个同学躺下之后，他的宽变成 hih_ihi​ ，高变成 wiw_iwi​。 同时，太多人躺着不好看，所以最多只能有 ⌊n2⌋\\left \\lfloor \\frac{n}{2} \\right \\rfloor⌊2n​⌋ 个同学躺下。 我们枚举最后相框的高度 hhh，对于第 iii 个人，有以下几种情况： hi≤h,wi≤hh_i \\leq h, w_i \\leq hhi​≤h,wi​≤h ，躺不躺都可 hi≥h,wi≤hh_i \\ge h, w_i \\leq hhi​≥h,wi​≤h ，一定要躺 hi≤h,wi≥hh_i \\leq h, w_i \\ge hhi​≤h,wi​≥h ，一定不能躺 hi≥h,wi≥hh_i \\ge h, w_i \\ge hhi​≥h,wi​≥h ，说明 hhh 不合法 那么只有第一种情况的人有操作空间，如果躺下的话，宽度会减小 wi−hiw_i - h_iwi​−hi​ ，按这个值排序取最优的即可 T3 求出满足以下条件的 n×mn \\times mn×m 矩阵个数: 对于每一行有 li,ril_i, r_ili​,ri​ ，表示 1∼li1 \\sim l_i1∼li​ 有且仅有一个 111 ，ri∼mr_i \\sim mri​∼m 有且仅有一个 111 , 其余全为 000 每一列最多有一个 111 因为每列最多都只能有一个 111，所以我们一每一列划分状态来 DP 。 把每一行的限制为前缀和后缀两个，一共有 2n2n2n 个限制，每一列只能满足这 2n2n2n 个限制中的一个 preliprel_ipreli​ 表示 l∈[1,i]l \\in[1, i]l∈[1,i] 的行有多少个，preriprer_ipreri​ 表示 r∈[1,i]r \\in[1, i]r∈[1,i] 的行有多少个。 f(i,j)f(i,j)f(i,j) 表示前 iii 列，有 jjj 列用来满足 r∈[i,i]r \\in [i, i]r∈[i,i] 的后缀限制的方案数，那么 f(i,j)=f(i−1,j)+f(i−1,j−1)×(preri−j+1)f(i, j) = f(i-1,j) + f(i-1,j-1) \\times (prer_i - j + 1) f(i,j)=f(i−1,j)+f(i−1,j−1)×(preri​−j+1) 以及 l=il = il=i 的前缀限制 f(i,j)=f(i,j)×(i−preli−1−j)!(i−preli−j)!f(i,j) = f(i,j) \\times \\frac{\\left(i-prel_{i-1}-j\\right) !}{\\left(i- prel_i-j\\right)!} f(i,j)=f(i,j)×(i−preli​−j)!(i−preli−1​−j)!​ div.2 T1 期望不会 T2 给定一些长度的边，求用这些边的其中一些组成 kkk 个三角形的最大边长和 贪心，尽量选边长大的。 具体来说就是先预处理出一组最大的边长，然后按长度递减枚举，a,b,ca, b, ca,b,c 为当前枚举的一组， x,y,zx, y, zx,y,z 为上一组 如果 x,y,zx, y, zx,y,z ，满足构成三角形的条件，直接更新，接着枚举 否则考虑拆开 a,b,ca, b, ca,b,c ， 使得 x,y,zx, y, zx,y,z 也可以被选，枚举一下几种情况： (a,x,y)(a, x, y)(a,x,y) 和 (b,c,z)(b, c, z)(b,c,z) (a,b,x)(a, b, x)(a,b,x) 和 (c,y,z)(c, y, z)(c,y,z) (a,c,x)(a, c, x)(a,c,x) 和 (j,y,z)(j, y, z)(j,y,z) 都不行接着枚举 (x,y,z)(x, y, z)(x,y,z) 10.5 T1 有一个长度为 nnn 的序列 AAA 和模数 ppp，AiA_iAi​ 表示 ai−1a^{i-1}ai−1 , 但是不知道 aaa 是多少的，求出 aaa 好像正解挺复杂的，但是人类智慧整出来了和T1相匹配的难度。 mulmulmul 表示整个序列的乘积， sumsumsum 表示整个序列的和 mul=an−12mul = a^{\\frac{n-1}{2}}mul=a2n−1​ ，sumsumsum 使用等比数列求和公式， 枚举 aaa 来 check 即可 T2 小S被老师安排去排一个新班级的座位。新班级有 nnn 位同学，他们的成绩按顺序分别为 a1,a2,…,an,(ai≤ai+1)a_1,a_2,\\dots,a_n ,(a_i\\leq a_{i+1})a1​,a2​,…,an​,(ai​≤ai+1​) 。为促进互帮互助，一对同桌的成绩之差的绝对值必须大于等于给定的 KKK，但这样会导致一些同学没有同桌，所以请你求出他最多能排出几对同桌 对于每个数，贪心配对即可，没什么好说的 T3 小k在下飞行棋，棋盘是一行共 nnn 个格子，编号依次为 1∼n1 \\sim n1∼n 。小K有外挂，所以他会通过外挂来前进，他共有 mmm 个外挂，第 iii 个外挂能让他从第 lil_ili​ 格瞬移到第 rir_iri​ ​格，并花费 111 的时间，并且小K很D，所以他不需要外挂就能往回走，且往回走不需要时间。 但是小K的 rp 不太好，现在发生了 qqq 次事件，每次事件中，小K的某一个挂会坏（这次事件结束后又会恢复），而你需要帮他求出此时他从 sss 走到 ttt 要花费的最小时间 倍增跳，维护第 iii 个位置出发的最大值和次大值。挂失效了就重新跳 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define MXBT 19using namespace std;namespace OCTANE&#123; template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; bool f = 0; char ch = getchar(); while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = 1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch^48); ch = getchar(); &#125; if (f) x = -x; &#125; template &lt;typename T, typename ... TT&gt; void read(T &amp;x, TT &amp;... xx) &#123; read(x); read(xx...); &#125;&#125;using namespace OCTANE;struct node&#123; int to, id;&#125;;struct nood&#123; node mxz, mxxz; void change(node a) &#123; if(a.to &gt; mxz.to) mxxz = mxz, mxz = a; else if(a.id != mxz.id and a.to &gt; mxxz.to) &#123; mxxz = a; &#125; &#125;&#125;a[MAXN];int n, m, q;int l[MAXN], r[MAXN];int f[MAXN][20];int g[MAXN][20];int main()&#123; read(n, m); for (int i = 1; i &lt;= m; i++) &#123; read(l[i], r[i]); a[l[i]].change(&#123;r[i], i&#125;); &#125; for (int i = 1; i &lt;= n; i++) &#123; a[i].change(a[i-1].mxz); a[i].change(a[i-1].mxxz); f[i][0] = a[i].mxz.to; g[i][0] = a[i].mxxz.to; &#125; for (int j = 1; j &lt;= MXBT; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; f[i][j] = f[f[i][j-1]][j-1]; if (a[g[i][j-1]].mxz.id == a[i].mxz.id) g[i][j] = g[g[i][j-1]][j-1]; else g[i][j] = f[g[i][j-1]][j-1]; &#125; &#125; read(q); while(q--) &#123; int id, s, t, ans = 0; if (t &lt; l[id]) id = 0; if (s &lt; l[id]) &#123; for (int i = MXBT; ~i; i--) &#123; if (f[s][i] &lt; l[id]) ans += (1 &lt;&lt; i), s = f[s][i]; &#125; ans++; s = f[s][0]; &#125; if (s &gt;= t) &#123; printf(&quot;%d\\n&quot;, ans); continue; &#125; for(int i = MXBT; i &gt;= 0; i--) &#123; if (a[s].mxz.id == id) &#123; if (g[s][i] &lt; t) ans += (1 &lt;&lt; i), s = g[s][i]; &#125; else &#123; if (f[s][t] &lt; t) ans += (1 &lt;&lt; i), s = f[s][i]; &#125; &#125; ans++; if (a[s].mxz.id == id) s = g[s][0]; else s = f[s][0]; if (s &lt; t) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; T4 教练给小Z布置了一个作业，教练给出了 nnn 个命题，让他证明 nnn 个命题全部为真。但是小Z非常的懒，一旦需要证明的命题数量大于 kkk，小Z就会摆烂不完成作业。因此小Z向他的好朋友黑恶卷怪小L求助。小L帮小Z证明了 mmm 个等价关系，即对于 1≤i≤m1\\leq i \\leq m1≤i≤m ，小L证明了 uiu_iui​ ​和 viv_ivi​ 是等价的。小L把他的成果发给了小Z，但是网络质量不佳，小Z只收到了一个区间的等价关系证明。​ 现在有 qqq 条时间线，你需要对于每条时间线，求出假如小Z收到了第 l∼rl \\sim rl∼r 个等价关系的证明，小Z是否能够完成作业 维护一个 fif_ifi​ 表示以 iii 为 左端点，能够完成需要的最近的 rrr 使用并查集维护联通性。用线段树分治处理时间段，因为 fff 从 mmm 开始枚举，所以先处理右儿子 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;int n, m, k, Type, q;namespace union_set&#123; struct node &#123; int x, y, add; &#125;; int fa[MAXN], siz[MAXN], cnt; node sta[MAXN &lt;&lt; 2]; int top; void init() &#123; for (int i = 1; i &lt;= n; i++) &#123; fa[i] = i; siz[i] = 1; cnt = n; &#125; &#125; int find(int x) &#123; return x == fa[x] ? x : find(fa[x]); &#125; void merge(int x, int y) &#123; int fx = find(x), fy = find(y); if (fx == fy) return; if (siz[fx] &gt; siz[fy]) swap(fx, fy); siz[fy] += siz[fx]; fa[fx] = fy; cnt--; sta[++top] = &#123;fx, fy, 1&#125;; &#125; void eko(int x, int y, int z) &#123; fa[x] = x; siz[y] -= siz[x]; cnt += z; &#125;&#125;using namespace union_set;#define ls(i) (i &lt;&lt; 1)#define rs(i) (i &lt;&lt; 1 | 1)struct nood&#123; int x, y;&#125;e[MAXN];vector &lt;int&gt; v[MAXN &lt;&lt; 2];int f[MAXN], now;void add(int i, int l, int r, int L, int R, int u)&#123; if (l &gt;= L &amp;&amp; r &lt;= R) &#123; v[i].push_back(u); return; &#125; int mid = (l + r) &gt;&gt; 1; if (mid &gt;= L) add(ls(i), l, mid, L, R, u); if (mid+1 &lt;= R) add(rs(i), mid+1, r, L, R, u);&#125;void solve(int u, int l, int r)&#123; int last = top; for (auto k : v[u]) merge(e[k].x, e[k].y); if (l == r) &#123; while (now &amp;&amp; cnt &gt; k) &#123; if (now &lt; l) add(1, 1, n, now, l-1, now); merge(e[now].x, e[now].y); now--; &#125; if (cnt &lt;= k) f[l] = now + 1; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; solve(rs(u), mid+1, r); solve(ls(u), l, mid); &#125; while (top &gt; last) eko(sta[top].x, sta[top].y, sta[top].add), top--;&#125;int main()&#123; read(n, m, k, Type); for (int i = 1; i &lt;= m; i++) &#123; int u, v; read(u, v); e[i] = &#123;u, v&#125;; &#125; now = m; init(); solve(1, 1, m); read(q); unsigned int lastans = 0; while (q--) &#123; int l, r; read(l, r); if (Type) &#123; l = ((unsigned int)l + lastans) % m + 1; r = ((unsigned int)r + lastans) % m + 1; if (l &gt; r) swap(l ,r); &#125; lastans &lt;&lt;= 1; if (f[r] &gt;= l) lastans++; puts(f[r] &gt;= l ? &quot;Yes&quot; : &quot;No&quot;); &#125; return 0;&#125; 10.6 T1 我们定义一个序列是单峰的，当且仅当它满足以下一个条件： 存在一个下标 k(1≤k≤n)k(1\\le k\\le n)k(1≤k≤n) 满足 a1&lt;a2&lt;a3&lt;⋯&lt;ak&gt;ak+1&gt;⋯&gt;ana_1 &lt; a_2 &lt; a_3 &lt; \\dots &lt; a_k &gt; a_{k+1} &gt; \\dots &gt; a_na1​&lt;a2​&lt;a3​&lt;⋯&lt;ak​&gt;ak+1​&gt;⋯&gt;an​ 存在一个下标 k(1≤k≤n)k(1\\le k\\le n)k(1≤k≤n) 满足 a1&gt;a2&gt;a3&gt;⋯&gt;ak&lt;ak+1&lt;⋯&lt;ana_1 &gt; a_2 &gt; a_3 &gt; \\dots &gt; a_k &lt; a_{k+1} &lt; \\dots &lt; a_na1​&gt;a2​&gt;a3​&gt;⋯&gt;ak​&lt;ak+1​&lt;⋯&lt;an​ 一个非单峰序列可以进行若干次Swap操作使得序列变成单峰的。小C每次会在序列的末尾添加一个新的元素 xxx ，小C想知道每次添加新的元素后，序列最少进行几次Swap操作可以变成单峰的 考虑到单峰的定义，我们保证每次添加的元素在之前没有出现过 对于每一个新插进来的数，可以插到前面，也可以插到后面 它的贡献是中间是没放的数中 下标比它大的 比 下标比它小的 更多就放前面，否则放后面 考虑逆序对，二分即可 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define ll long long#define MAXN 300005using namespace std;int n;namespace doubleForkIndexTree&#123; #define lowbit(i) (i &amp; -i) int t[MAXN]; void add(int pos, int val) &#123; while (pos &lt;= n) &#123; t[pos] += val; pos += lowbit(pos); &#125; &#125; int query(int pos, int res = 0) &#123; while (pos) &#123; res += t[pos]; pos -= lowbit(pos); &#125; return res; &#125;&#125;using namespace doubleForkIndexTree;int a[MAXN], h[MAXN];vector &lt;int&gt; q[MAXN];int iOrderPair[MAXN];ll ans[MAXN];void solve()&#123; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= n; i++) q[i].clear(); for (int i = 1; i &lt;= n; i++) &#123; h[a[i]] = i; iOrderPair[i] = query(a[i]); add(a[i], 1); &#125; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= n; i++) &#123; int l = h[i], r = n, mid; while (l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if (query(mid) &gt;= 2 * iOrderPair[h[i]]) r = mid; else l = mid + 1; &#125; q[l].push_back(i); add(h[i], 1); &#125; memset(t, 0, sizeof(t)); ll v = 0; for (int i = 1; i &lt;= n; i++) &#123; v += query(n) - query(a[i]); for (int j : q[i]) add(j, -1); add(a[i], 1); ans[i] = min(ans[i], v); &#125;&#125;int main()&#123; read(n); memset(ans, 0x3f, sizeof(ans)); for (int i = 1; i &lt;= n; i++) read(a[i]), h[i] = a[i]; sort(h+1, h+1+n); for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(h+1, h+1+n, a[i]) - h; solve(); for (int i = 1; i &lt;= n; i++) a[i] = n - a[i] + 1; solve(); for (int i = 1; i &lt;= n; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;&#125; T2 小 Q 要进行 nnn 组体能训练。需要 mmm 种配重圆盘。在第 iii 组训练中，需要 wi,jw_{i,j}wi,j​ 个配重为 jjj 的圆盘。小 Q 的训练器械是一个类似栈的结构，每次只能取出最上方的圆盘或把一个圆盘放在最上方，每次操作都要消耗一点体力。淸帮助小 Q 安排放圓盤的順序，使得消耗的體力最少 与处理出每次最多可以保留的圆盘，也就是 min(wi−1,j,wi,j)min(w_{i-1, j}, w_{i,j})min(wi−1,j​,wi,j​) ，然后区间Dp Code 123456789101112131415memset(f, 0x3f, sizeof(f));for (int i = 1; i &lt;= n;i++)&#123; for (int j = 1; j &lt;= m; j++) read(w[i][j]), g[j] = w[i][j]; for (int j = i; j &gt;= 1; j--) for (int k = 1; k &lt;= m; k++) &#123; g[k] = min(g[k], w[j][k]); cost[j][i] += g[k] * 2; &#125; f[i][i] = cost[i][i];&#125;for (int len = 2; len &lt;= n; len++) for (int l = 1; l &lt;= n - len + 1; l++)&#123; int r = l + len - 1; for (int k = l; k &lt; r; k++) f[l][r] = min(f[l][r], f[l][k] + f[k+1][r] - cost[l][r]);&#125; T3 有 nnn 个小朋友，第 iii 个小朋友站在 xi,yix_i, y_ixi​,yi​ ，小 Q 在地上放置了 nnn 个普通 🍬 ，小 Q 每次回选择一个小朋友，小朋友回每次选择距离他最近的糖果拿下，但是小 Q 还不小心把它喜欢的艾尔登法环掉到地上了，请问是否存在使唤小朋友的顺序，使得最后选剩下的是艾尔登法环 考虑一个贪心，处理出每个小孩不拿法环的情况下可以拿到的糖果，还有对应糖果可以被拿的小孩。 每次选择可以拿糖果的最少的小孩去拿可以被最少的小孩拿的糖果。这个贪心是对的 选择可以选点最少的小孩可以避免在这个小孩身上出锅，然后选择小孩最少的糖果可以给别的小孩操作空间 然后就是可行性，题目里的要求就是让小孩拿离他最近的糖果，根本没有选糖果的权利，那我们为什么可以选择呢？ 经过手玩一下，可以发现可以构造方案使得想法成立。 反正考场上又不会让证明贪心，想到就冲就完了 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define MAXN 1005#define ll long longusing namespace std;int n;struct node &#123; ll x, y; &#125;;node a[MAXN], b[MAXN], c;vector &lt;int&gt; kid[MAXN];vector &lt;int&gt; bel[MAXN];int vis[MAXN];ll dis(node a, node b)&#123; return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);&#125;int main()&#123; read(n); for (int i = 1; i &lt;= n; i++) read(a[i].x, a[i].y); read(c.x, c.y); for (int i = 1; i &lt;= n; i++) read(b[i].x, b[i].y); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; if (dis(a[i], c) &gt;= dis(a[i], b[j])) &#123; kid[i].push_back(j); bel[j].push_back(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; int who = 0, which = 0; for (int j = 1; j &lt;= n; j++) &#123; if (!vis[j] &amp;&amp; (!who || kid[j].size() &lt; kid[who].size())) who = j; &#125; for (int j : kid[who]) &#123; if (!which || bel[j].size() &lt; bel[which].size()) which = j; &#125; if (!kid[who].size()) &#123; printf(&quot;IMPOSSIBLE&quot;); return 0; &#125; vis[who] = 1; for (int j : kid[who]) bel[j].erase(lower_bound(bel[j].begin(), bel[j].end(), who)); for (int j : bel[which]) kid[j].erase(lower_bound(kid[j].begin(), kid[j].end(), which)); &#125; printf(&quot;POSSIBLE&quot;); return 0;&#125; 10.7 T1 给定一个序列 a1,a2,…,an{a_1, a_2, \\dots, a_n}a1​,a2​,…,an​ 和一个整数 sss ，求有多少正整数序列 {k1,k2,⋯ ,kn}\\{k_{1}, k_{2}, \\cdots, k_{n}\\}{k1​,k2​,⋯,kn​} ，满足 ∑i=1naiki≤s\\sum_{i=1}^{n} a_{i}^{k_{i}} \\leq s∑i=1n​aiki​​≤s ，其中 n≤8n \\le 8n≤8 。 n≤8n \\le 8n≤8 耶！ 难得考试整签到题，直接上爆搜哇，但是就算是签到题直接搜也会寄的辣， 折半搜就行了 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define ll long long#define the_great_will 10#define Marika 10000005using namespace std;int great_will, ye_dead;ll Dung_eater, deathbed[the_great_will], ye_live, Tarnished_elden_lord;ll elden_ring[Marika]; int Tarnished;ll elden_lord[Marika]; int demigods;void dfs(int black_knives, int bless, ll goldmask)&#123; if (goldmask &gt; Dung_eater) return; if (black_knives &gt; bless) &#123; if (bless == ye_dead) elden_ring[++Tarnished] = goldmask; else elden_lord[++demigods ] = goldmask; return; &#125; ll lands_between = deathbed[black_knives]; for (int grace = 1; grace; grace++) &#123; if (lands_between + goldmask &gt; Dung_eater) break; if (lands_between + ye_live - deathbed[black_knives] &gt; Dung_eater) break; dfs(black_knives + 1, bless, goldmask + lands_between); lands_between *= deathbed[black_knives]; &#125;&#125;int main()&#123; read(great_will, Dung_eater); ye_dead = (great_will &gt;&gt; 1); for (int grace = 1; grace &lt;= great_will; grace++) read(deathbed[grace]), ye_live += deathbed[grace]; dfs(1, ye_dead, 0); dfs(ye_dead+1, great_will, 0); sort(elden_ring+1, elden_ring+1+Tarnished); sort(elden_lord+1, elden_lord+1+demigods ); for (ll grace = 1; grace &lt;= Tarnished; grace++) &#123; ll j = upper_bound(elden_lord+1, elden_lord+1+demigods , Dung_eater - elden_ring[grace]) - elden_lord - 1; Tarnished_elden_lord += j; &#125; printf(&quot;%lld&quot;, Tarnished_elden_lord); return 0;&#125; T2 梅琳娜想种树，但是木头没脑子，决定让第 iii 个点的父亲在 [1,i−1][1, i-1][1,i−1] 之间随机。但是木头又觉得太矮了，就决定给每个点加两个权值 ai,bia_i, b_iai​,bi​ , 表示第 jjj 个点作为第 iii 个点的父亲的概率是 aja1+a2+⋯+ai−1\\frac{a_{j}}{a_{1}+a_{2}+\\cdots+a_{i-1}}a1​+a2​+⋯+ai−1​aj​​ , 且边 (j,i)(j, i)(j,i) 的长度为 bi+bjb_i + b_jbi​+bj​ 。 要求贼拉多的燃料梅琳娜小姐很好奇这颗树的结构，每次询问 u,vu, vu,v 的期望距离 根据期望的线性，答案是 E(dep(u))+E(dep(v))−2×E(dep(lca(u,v)))E(dep(u))+E(dep(v))-2 \\times E(dep(lca(u, v)))E(dep(u))+E(dep(v))−2×E(dep(lca(u,v))) E(dep(u))E(dep(u))E(dep(u)) 枚举父亲来求 ∑i=1u−1ai(E(dep(i))+bi+bu)∑i=1u−1ai\\frac{\\sum_{i=1}^{u-1} a_{i}\\left(E(dep(i))+b_{i}+b_{u}\\right)}{\\sum_{i=1}^{u-1} a_{i}} ∑i=1u−1​ai​∑i=1u−1​ai​(E(dep(i))+bi​+bu​)​ 还有就是 u,vu, vu,v 的 lcalcalca 到到根的期望距离 E(lca(u,v))=aufu+∑i=1u−1E(lca(i,u))∑i=1uaiE(lca(u, v))=\\frac{a_{u} f_{u}+\\sum_{i=1}^{u-1} E(lca(i, u))}{\\sum_{i=1}^{u} a_{i}} E(lca(u,v))=∑i=1u​ai​au​fu​+∑i=1u−1​E(lca(i,u))​ 10.8 T1 给两个序列 aaa, bbb，⻓度分别为 nnn, mmm，求相邻元素属于给定点对的 a,ba,ba,b 公共⼦序列个数 先离散化。 然后DP。 f(i)f(i)f(i) 表示 前 jjj 个能配成几对，新找到一对，就加上以前找到的，所以前缀和优化就完了奥 Code 123456789for (int i = 1;i&lt;=n;i++)&#123; int s = 1; for (int j=1;j&lt;=m;j++)&#123; int t=f[j]; if (a[i]==b[j]) add(f[j],s),add(ans,s); if (mp[b[j]][a[i]]) add(s,t); &#125;&#125; T2 nnn 个点，初始时没有边项链，链接第 iii 和第 jjj 个点的代价是 di,jd_{i,j}di,j​ 每个结点上住着一个魔法居民，若两个节点间有边直接相连，则他们成为邻居。居民一共有三种类型： 村民：他们只能拜访自己的邻居； 巫师：他们可以拜访自己的邻居以及邻居的邻居； 大魔法师：可以拜访所有与自己连通的人。 每种类型的居民要么不出现，要么至少出现两个。每个居民都希望可以拜访其他所有的居民。求在道路数目最少的前提下的最小代价。 进行一个情况的分与贪心 如果有村民的话，直接把每一个村民都和其他人连上边就行辣。这样巫师三：狂猎和大魔法师也满足了。 如果只有大魔法师的话，直接最小生成树就行了。 对于剩下的情况主要是这样的，可以以一个点为根向其余的点全连上边，所以最少的边数是 n−1n-1n−1。 巫师之间必须要连边或者连向同一个人，那么也就是说可以枚举上面说的 nnn 。 还有就是只有两个巫师的情况，也可以直接他们之间连边，然后剩下的点哪个代价少连那个。特判取 minminmin 即可 T3 给定两个序列，安排顺序，使得对应位置异或出来的新序列字典序最少 建两颗 Trie 树贪心，真是没什么好说的，怎么考试就没想出来呢麻麻地 Code 12345678910void query(int u, int v, int d, int now)&#123; a.siz[u]--; b.siz[v]--; if (cnt &gt;= n) return; if (d &lt; 0) &#123; ans[++cnt] = now; return; &#125; while (a.siz[lsa(u)] &amp;&amp; b.siz[lsb(v)]) query(lsa(u), lsb(v), d-1, now); while (a.siz[rsa(u)] &amp;&amp; b.siz[rsb(v)]) query(rsa(u), rsb(v), d-1, now); while (a.siz[lsa(u)] &amp;&amp; b.siz[rsb(v)]) query(lsa(u), rsb(v), d-1, now + (1 &lt;&lt; d)); while (a.siz[rsa(u)] &amp;&amp; b.siz[lsb(v)]) query(rsa(u), lsb(v), d-1, now + (1 &lt;&lt; d));&#125; 10.10 T1 有n座山，m只猫和p个工作人员。山从左往右编号为 1∼n1 \\sim n1∼n，山 iii 和 i−1i-1i−1 之间的距离是 ddd 米。有一天，猫都到山上去玩了∶第 iii 只猫会到山 hih_ihi​ 去，并一直玩到时间 ttt，之后就在那座山等待工作人员来接它。每个工作人员的线路都是从1走到n，并带走沿途任意只在等待的猫。工作人员速度为每单位时间1米，不能在山上停留。安排每个工作人员出发的时间，使所有猫的等待时间总和最小 斜率优化DP 首先可以发现的是每个人一定是选择恰好可以接到一只猫的时候出发 timitim_itimi​ 表示想要恰好接到第 iii 只猫要从什么时刻出发。先对 timitim_itimi​ 排个序，那么在 iii 前面的都能被 iii 接到 那么 fi,jf_{i, j}fi,j​ 表示第 iii 个人选第 jjj 只猫的最小花费。 转移的话，比如说第 i−1i-1i−1 个人选择了第 kkk 只猫，第 iii 个人选择了第 jjj 只猫，那么这个人可以把 [k+1,j][k+1, j][k+1,j] 的猫全拿下，这些猫一共等待 ∑i=k+1jtj−ti\\sum\\limits_{i = k+1}^{j} t_j - t_ii=k+1∑j​tj​−ti​ 的时间，记录 sss 为 ttt 的前缀和，转移就是 fi,j=fi−1,k+∑p=k+1j(tj−tp)f_{i,j} = f_{i-1, k} + \\sum\\limits_{p = k+1}^j (t_j - t_p) fi,j​=fi−1,k​+p=k+1∑j​(tj​−tp​) 稍微变一变 \\begin{align} f_{i,j} &amp;= f_{i-1, k} + \\sum\\limits_{p = k+1}^j (t_j - t_p) \\\\ &amp;= f_{i-1, k} + (j-k) \\times t_j - s_j + s_k \\\\ &amp;= f_{i-1, k} + jt_j - kt_j - s_j + s_k \\\\ \\end{align} 发现对于 kkk 是一个一次函数，斜率优化 T2 给定一个长为 nnn 的序列 aaa ，对 k∈[1,n]k \\in [1, n]k∈[1,n] 求 ∑i=1k∑j=1kaimodaj\\sum\\limits_{i = 1}^{k} \\sum\\limits_{j = 1}^{k} a_imod a_j i=1∑k​j=1∑k​ai​modaj​ 每次 kkk 加一会向外扩展一行和一列，也就是 ∑i=1kak%aj+aj%ak\\sum\\limits_{i = 1}^{k} a_k \\% a_j + a_j \\% a_ki=1∑k​ak​%aj​+aj​%ak​ 考虑优化，对于 aj%aka_j \\% a_kaj​%ak​ 我们把 模运算变为除，分块，枚举 aka_kak​ 的倍数 对于 ak%aja_k \\% a_jak​%aj​ 我们在每个 aja_jaj​ 的位置上加上 aja_jaj​ , 然后查询 aka_kak​ 位置上的前缀和就行辣 维护两个树状数组 Code 1234567891011121314151617for (int k = 1; k &lt;= n; k++)&#123; ll bs = a[k], t = 0; sum += bs; t1.add(bs, 1); ll tmp = 0; for (ll i = 0; i &lt;= mx; i += bs, t++) &#123; tmp += t1.query(i, i + bs - 1) * t; t2.add(i, a[k]); &#125; ans += k * bs - t2.query(1, a[k]); tmp = sum - bs * tmp; ans += tmp; printf(&quot;%lld &quot;, ans);&#125; 10.11 寄 10.12 T1 有一个长度为 nnn 的环，sis_isi​ 表示 iii 位置上的颜色。每次从上面剪去一段长度为 kkk 的连续段。再把剩余部分首尾相接，询问每次操作后的花环是不是美丽的 美丽指的是环上任意两个相邻位置的颜色不同 从保留的部分下手，对于一个确定的左端点 l, 它能保留到的右端点 r 是单调不增的，我们固定一个长度为 kkk 的区间，如果区间有两个相邻相同的，那么这个区间就不能六，还有就是区间的做右端点不能相同 T2 给一个竞赛图，令 dist(u,v)dist(u,v)dist(u,v) 表示最短路，求 min⁡1≤u≤nmax⁡1≤v≤ndist(u,v)\\min\\limits_{1\\le u \\le n} \\max\\limits_{1 \\le v \\le n} dist(u, v)1≤u≤nmin​1≤v≤nmax​dist(u,v) 手玩一下发现，答案只有 0,1,20, 1, 20,1,2 三种可能 如果只有一个点，那么答案为 000 如果存在一个点和其他边都有连边，那么答案为 111 否则为 222 T3 最大权完美匹配，转化为费用流，点之间连流量为 111 ,费用为 $$ 给定一个数列 A1…nA_{1 \\dots n}A1…n​ , 10.14 15 T1 给定一个数列 A1…nA_{1 \\dots n}A1…n​ , 对于 1…n1 \\dots n1…n 的每一个 kkk ，要把它分成 kkk 的非空的连续段，对每段分别求和，得到 kkk 个数，最大化他们的最大公约数 记前缀和为 sumsumsum 那么也就是把和分为 kkk 个部分，然后找到一个 ddd 满足 d∣sumd \\mid sumd∣sum 并且 d∣sumkd \\mid sumkd∣sumk 枚举约数即可 T2 给定一个长度为 nnn 的非负整数序列 a1,⋯ ,ana_1,\\cdots,a_na1​,⋯,an​ 。统计二元组 (i,j)(i,j)(i,j) 的数量，满足 $1\\leq i\\leq j\\leq n $ 且 ai⊕ai+1⊕⋯⊕aj≤max⁡{ai,ai+1⋯ ,aj}a_i\\oplus a_{i+1}\\oplus \\cdots\\oplus a_j\\leq \\max\\{a_i,a_{i+1}\\cdots,a_j\\}ai​⊕ai+1​⊕⋯⊕aj​≤max{ai​,ai+1​⋯,aj​} 。 冷门数据结构，用笛卡尔树维护最大值，现在需要 n2n^2n2 枚举最大值和区间然后可持久化 01Trie，考虑如何优化 我们枚举最大值是一定的，那么区间左右端点的维护可以类似于启发式合并，改为 01Trie 合并即可 T3 给定一个 kkk 求 [L,R][L, R][L,R] 内满足下列条件的值的和 ∀i∈[2,min(x−1,k)],i∤x \\forall i \\in [2, min(x-1, k)], i \\nmid x ∀i∈[2,min(x−1,k)],i∤x 一眼筛，我们先确定所有可能成为 xxx 的约数的数。无非是比 kkk 小的质数。 然后再用这些质数筛就完了 T4 您在打音游，给定一个长为 nnn 的序列 ppp ，表示第 iii 个拍子您 pperfectpperfectpperfect 的概率，您的得分由基础分和连击分构成。您已经出神入化，如果没有 perfectperfectperfect ，就只会 missmissmiss SiS_iSi​ 表示第 iii 个音符是否 perfectperfectperfect 基础分 =A×∑i−1nSi= A \\times \\sum_{i-1}^{n} S_i=A×∑i−1n​Si​ 连击分需要一个计算的函数 fff f(i)={Sii=1f(i−1)+1i≠1∧Si=1f(i−1)×t otherwise f(i)=\\left\\{\\begin{array}{lr} S_{i} &amp; i=1 \\\\ f(i-1)+1 &amp; i \\neq 1 \\wedge S_{i}=1 \\\\ f(i-1) \\times t &amp; \\text { otherwise } \\end{array}\\right. f(i)=⎩⎪⎨⎪⎧​Si​f(i−1)+1f(i−1)×t​i=1i=1∧Si​=1 otherwise ​ 连击分 =B×(∑i−1nSi)= B \\times \\left(\\sum_{i-1}^{n} S_i\\right)=B×(∑i−1n​Si​) 因为您一边睡觉一边打，会有一些突发事件导致某个位置的 ppp 改变。每次询问 [l,r][l, r][l,r] 的期望得分 推推小柿子，维护 fff 和总得分 sumsumsum ，推式子发现可以矩阵优化，转移矩阵 f,sumf, sumf,sum 和常数 然后就是线段树维护矩阵，单点修改，区间乘 其实也可以直接 kx+bkx + bkx+b 维护总得分。矩阵的做法更好理解 10.16 T1 一个 nnn 个点的森林，每个点被涂成黑色或白色，需要删去一些边使得所有黑点的度数为奇数，所有白点的度数为偶数。求保留的边字典序最小的方案。 最能想到的方案就是直接把两个黑点连起来，实际上直接把两个黑点之间的路径连起来确实是对的。 除了在端点上的两个黑点，路径上的其他点都是一条边进，一条边出，度数不会改变，所以也就是说每次找两个黑点，打通之间的路径就行了，黑点个数不是偶数就无解 线段树维护边区间取反表示保留不保留就完了奥 T2 一张图，每个点有点权，小 kkk 和边之间有颜色，不能通过和自己一样颜色的边，但是小 kkk 可以中途在任意一个点改变颜色，每次询问从给定的点出发，最多的点权和。 疯狂 bfsbfsbfs 去处理出每个颜色的连通块和相交部分的连通块. 10.17 T1 开始有 nnn 个物品排成一行，每个物品有一个代价和一个价值 。你可以选择两个相邻的代价之和不超过 kkk 的物品，将它们从序列中删去，并获得两个物品价值之和的收益。求最大收益 区间 DP ， fl,rf_{l,r}fl,r​ 表示 l,rl, rl,r 个物品的贡献 123456789for (int len = 2; len &lt;= n; len++)for (int l = 1, r = l + len - 1; r &lt;= n; l++, r++)&#123; for (int _k = l+1; _k &lt; r; _k++) f[l][r] = max(f[l][r], f[l][_k] + f[_k+1][r]); if (f[l+1][r-1] == sum[r-1] - sum[l] &amp;&amp; a[l] + a[r] &lt;= k) // 可以合并 f[l][r] = max(f[l][r], f[l+1][r-1] + b[l] + b[r]);&#125; T2 一张 nnn 个点的图，每条边有边权 d,(d≤9)d , (d \\le 9)d,(d≤9) ， 每通过一条边后下一条边的花费都会乘 101010 。求从 111 到 nnn 的最短路。 因为边权小于 999 所以少走一条边肯定更优，所以要尽量走少的边。 bfsbfsbfs 预处理出只经过 000 边可以到达 nnn 的点， 然后每一条边的边权在答案中都贡献一位数，然后 bfsbfsbfs 分层，最后 bfsbfsbfs 找路径 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define INF 0x3f3f3f3fusing namespace std;int n, m, k;int cnte = 1, head[MAXN];struct edge&#123; int st, to, nxt, dis;&#125;e[MAXN &lt;&lt; 2];void adde(int u, int v, int w)&#123; e[++cnte].st = u; e[cnte].to = v; e[cnte].nxt = head[u]; e[cnte].dis = w; head[u] = cnte;&#125;int cnt0[MAXN], dep[MAXN];queue &lt;int&gt; q; void bfs()&#123; memset(cnt0, -1, sizeof(cnt0)); q.push(n-1); cnt0[n-1] = 0; while (q.size()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (e[i].dis == 0 &amp;&amp; cnt0[v] == -1) &#123; cnt0[v] = cnt0[u] + 1; q.push(v); &#125; &#125; &#125;&#125;void bfs1()&#123; memset(dep, 0x3f, sizeof(dep)); q.push(0); dep[0] = 0; while (q.size()) &#123; int u = q.front(); q.pop(); if (cnt0[u] != -1) continue; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (dep[v] == 0x3f3f3f3f) &#123; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; &#125;&#125;int minc[MAXN]; bool vis[MAXN];int pre[MAXN], st[MAXN];void work()&#123; memset(minc, 0x3f, sizeof(minc)); int dop = INF; vector &lt;int&gt; vq; for (int i = 1; i &lt;= n; i++) if (cnt0[i] != -1) &#123; if (dep[i] &lt; dop) &#123; dop = dep[i]; vq.clear(); &#125; if (dep[i] == dop) &#123; vq.push_back(i); st[i] = i; &#125; &#125; for(;dop!=0;dop--) &#123; vector &lt;int&gt; tmp; sort(vq.begin(), vq.end(), [&amp;](int x, int y) &#123; return cnt0[st[x]] &lt; cnt0[st[y]]; &#125;); while (vq.size()) &#123; int u = vq.front(); vq.pop_back(); if (vis[u]) continue; vis[u] = 1; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (dep[v] &gt;= dop) continue; if (e[i].dis &lt; minc[dop-1]) &#123; tmp.clear(); minc[dop-1] = e[i].dis; &#125; if (e[i].dis == minc[dop-1]) &#123; tmp.push_back(v); pre[v] = u; st[v] = st[u]; &#125; &#125; &#125; vq = tmp; &#125;&#125;void pr1nt(int x)&#123; if (cnt0[x] != -1) return; pr1nt(pre[x]); print(minc[dep[x]]);&#125;int main()&#123; #ifdef ONLINE_JUDGE freopen(&quot;great.in&quot;, &quot;r&quot;, stdin); freopen(&quot;great.out&quot;, &quot;w&quot;, stdout); #endif read(n, m); for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; read(u, v, w); adde(u, v, w); adde(v, u, w); &#125; bfs(); bfs1(); work(); if (cnt0[0] == -1) pr1nt(0), putchar(&#x27;\\n&#x27;); else puts(&quot;0&quot;); print(dep[st[0]] + cnt0[st[0]] + 1); return 0;&#125; T3 一棵 nnn 个点的树，每条边都有一个边权，每次可以选择两个点 u,vu, vu,v 让他们之间的路径都异或一个数 xxx。询问最少几次操作可以使所有边边权为 0 定义一个点的权值为它的所有出边异或起来。那么如果我们对 u,vu, vu,v 进行操作，权值会改变的只有 u,vu, vu,v 。 因为其他点一个进一个出，异或了白异或。 显然所有边权为 000 。当且仅当所有点权值为 000 于是问题转化为了把这些点分为几组，分别操作。首先两个权值一样的点可以异或上这个权值，其他的状压枚举子集即可。 10.18 T1 有 nnn 堆石子，第 iii 堆有 xix_ixi​ 个，每次可以取从一堆中 a∼ba \\sim ba∼b 个。询问先手必胜还是必败。 经典套路打 SG 表找规律。 发现 SG 值是有规律的，大概是 1,0,2,3 构成的循环段，每段长为 aaa ，每段一起看循环节为 a+b T2ARC104F 给一个长度为 NNN 的数列 H1..NH_{1..N}H1..N​ ，第 iii 项在 [1,Hi][1,H_i][1,Hi​] 中选一个数，得到数列 X1..NX_{1..N}X1..N​ 。再构造一个数列 P1..NP_{1..N}P1..N​ ，Pi=max⁡j(j&lt;i,Xj&gt;Xi)P_i=\\max j(j&lt;i, X_j &gt; X_i)Pi​=maxj(j&lt;i,Xj​&gt;Xi​) ，若不存在这样的 jjj ， Pi=−1P_i=-1Pi​=−1 。求能够早出多少种 PPP 我真服了。 转化一下，iii 向 pip_ipi​ 连边，发现是一棵树》》。 然后就开始区间 DP fl,r,vf_{l, r, v}fl,r,v​ 表示 lll 到 rrr ，xxx 的最小值的最大值为 vvv 的森林数量 gl,r,vg_{l, r, v}gl,r,v​ 表示 lll 到 rrr ，xxx 的最大值为 vvv 的森林数量 转移的话 gL,R,V=fL+1,R,V−1(HL≥V)fL,R,V=gL,R,V+∑K=LR−1∑W=1VfL,K,W×gK+1,R,V+∑K=LR−1[HK+1≥V]∑W=1V−1FL,K,V×gK+1,R,Wg_{L, R, V}=f_{L+1, R, V-1}\\left(H_{L} \\geq V\\right) \\\\ f_{L, R, V}=g_{L, R, V}+\\sum_{K=L}^{R-1} \\sum_{W=1}^{V} f_{L, K, W} \\times g_{K+1, R, V}+\\sum_{K=L}^{R-1}\\left[H_{K+1} \\geq V\\right] \\sum_{W=1}^{V-1} F_{L, K, V} \\times g_{K+1, R, W} gL,R,V​=fL+1,R,V−1​(HL​≥V)fL,R,V​=gL,R,V​+K=L∑R−1​W=1∑V​fL,K,W​×gK+1,R,V​+K=L∑R−1​[HK+1​≥V]W=1∑V−1​FL,K,V​×gK+1,R,W​ ggg 的转移的意思是：因为 Hl&gt;vH_{l} &gt; vHl​&gt;v , lll 这个位置的树可以当作 [l+1,r][l+1, r][l+1,r] 的根把他们都连起来 fff 的转移的意思是：首先是树的数量，然后枚举可能成为根的树，把他和和他差不多的连起来，然后枚举可能成为跟但没有的树，和其他树构成森林 T3CF1140F 定义一个点集合 S={(xi,yi)}(1≤i≤n)S=\\{(x_i,y_i)\\}(1\\leq i\\leq n)S={(xi​,yi​)}(1≤i≤n) 的拓展操作为将符合以下条件的 (x0,y0)(x_0,y_0)(x0​,y0​) 加入 SSS： 存在 a,ba,ba,b，使得 (a,b),(a,y0),(x0,b)∈S(a,b),(a,y_0),(x_0,b)\\in S(a,b),(a,y0​),(x0​,b)∈S。 不断执行以上操作直到不能操作，此时得到的集合即为拓展集合。现在给定 qqq 个操作，每次加入或删除一个点，重复点即为删除，你需要输出每个操作之后的拓展集合大小（ 看扩展的这个过程，其实就是二分图，左边左部点，右边右部点，并查集维护 siz 乘起来就是答案。 时间轴用线段树分治维护 Code s1z 表示左部点大小, s2z 表示右部点大小， res 表示答案123456789101112void merge(int x, int y)&#123; int fx = find(x), fy = find(y); if (fx == fy) return; if (rk[fx] &gt; rk[fy]) swap(fx, fy); sta[++top] = &#123;fx, fy, s1z[fy], s2z[fy], rk[fy], res&#125;; fa[fx] = fy; rk[fy] += rk[fy] == rk[fx]; res -= 1LL * s1z[fx] * s2z[fx] + 1LL * s1z[fy] * s2z[fy]; s1z[fy] += s1z[fx]; s2z[fy] += s2z[fx]; res += 1LL * s1z[fy] * s2z[fy];&#125; 10.19 T1CF1163F 一个无向图，每次把修改一条边的边权，询问 111 到 nnn 的最短路长度。询问间相互独立 分类讨论 令 dis1idis1_idis1i​ 表示 111 出发到 iii 的最短路， dis2idis2_idis2i​ 表示 nnn 出发到 iii 的最短路 ，修改的边的端点为 uuu 和 vvv , 修改的边原来的权值是 xxx ，现在的权值是 yyy ，原来最短路为 distdistdist 如果修改的边不在原来的最短路上，那么答案为 min(dist,dis1u+y−x+dis2v,dis2u+y−x+dis1v)min(dist, dis1_u + y - x + dis2_v, dis2_u + y - x + dis1_v)min(dist,dis1u​+y−x+dis2v​,dis2u​+y−x+dis1v​) 。 可以 O(1)O(1)O(1) 如果修改的边在原来的最短路上，那么答案为 min(dist−y+x,不经过 u, v 的最短路)min(dist - y + x, \\text{不经过 u, v 的最短路})min(dist−y+x,不经过 u, v 的最短路) 那么不好维护的就是不经过 u,vu, vu,v 的最短路。枚举不在 u,vu, vu,v 的边权，线段树维护，区间修改 T2CF1630B 给定一个长度为 nnn 的数组 aaa。你需要确定一个范围 [x,y][x,y][x,y]，并将 aaa 数组分成 kkk 段，使得对于每一段，在范围 [x,y][x,y][x,y] 以内的元素个数大于在范围 [x,y][x,y][x,y] 以外的元素个数。请求出任意一组使得 y−xy-xy−x 最小的 x,yx,yx,y 和划分的方案。 答案区间显然是越大越行，双指针枚举值域，对于每个 rrr ，求出最小的合法的 lll ，贪心构造方案即可 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344void ma1n()&#123; read(n, k); res = 561651561; cnt0 = 0; cnt1 = n; for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); cnt[a[i]]++; &#125; int l = 1; for (int r = 1; r &lt;= n; r++) &#123; cnt0 += cnt[r]; cnt1 -= cnt[r]; if (cnt0 - cnt1 &lt; k) continue; while (l &lt;= r &amp;&amp; cnt0 - cnt1 &gt;= k) &#123; int tmp = r - l + 1; if (tmp &lt; res) &#123; res = tmp; resl = l; resr = r; &#125; else if (tmp == res &amp;&amp; l &lt; resl) &#123; resl = l, resr = r; &#125; cnt0 -= cnt[l]; cnt1 += cnt[l++]; &#125; &#125; cout &lt;&lt; resl &lt;&lt; &#x27; &#x27; &lt;&lt; resr &lt;&lt; &#x27;\\n&#x27;; cnt0 = 0; cnt1 = 0; int last = 1, tot = 0; for (int i = 1; i &lt;= n; i++) &#123; cnt[a[i]]--; if (a[i] &gt;= resl &amp;&amp; a[i] &lt;= resr) cnt0++; else cnt1++; if (cnt0 - cnt1 == 1 &amp;&amp; tot &lt; k - 1) &#123; cout &lt;&lt; last &lt;&lt; &#x27; &#x27; &lt;&lt; i &lt;&lt; &#x27;\\n&#x27;; last = i + 1; tot++; cnt1 = cnt0 = 0; &#125; &#125; cout &lt;&lt; last &lt;&lt; &#x27; &#x27; &lt;&lt; n &lt;&lt; &#x27;\\n&#x27;;&#125; T3HNOI2011 有 nnn 个音阶，需要用这些音阶组成 mmm 个互不相同的片段，要求在所有这些片段中每个音阶的出现次数互不相同，询问有多少方案，片段之间的顺序无关答案。 转化一下问题，就是选出 mmm 个不相同的 1,…,n{1, \\dots, n}1,…,n 的子集，然后有一些限制。片段之间的顺序无关紧要，可以最后除以 m!m!m! 然后对于出现次数是偶数的问题，第 n−1n-1n−1 个片段确定了，第 nnn 个片段也就确定了","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"https://ve1bae.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://ve1bae.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://ve1bae.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"数学杂项","slug":"数学杂项","date":"2022-09-27T08:08:23.000Z","updated":"2022-11-08T10:40:08.032Z","comments":true,"path":"2022/09/27/数学杂项/","link":"","permalink":"https://ve1bae.github.io/2022/09/27/%E6%95%B0%E5%AD%A6%E6%9D%82%E9%A1%B9/","excerpt":"整理一些小知识点","text":"整理一些小知识点 数论小函数 积性函数 φ\\varphiφ μ\\muμ σk(n)=∑d∣ndk\\sigma_k(n) = \\sum\\limits_{d \\mid n} d^kσk​(n)=d∣n∑​dk ddd 因数个数函数 σ0\\sigma_0σ0​ ε(n)=[n=1]\\varepsilon(n) = [n = 1]ε(n)=[n=1] 单位函数 完全积性 I(n)=1I(n) = 1I(n)=1 完全积性 id(n)=nid(n) = nid(n)=n 完全积性 性质 φ\\varphiφ n=p1α1⋯psαsn=p_1^{\\alpha_1} \\cdots p_s^{\\alpha_s}n=p1α1​​⋯psαs​​ 对 nnn 唯一分解 φ(n)=n∏i=1s(1−1pi)n=∑d∣nφ(d)\\varphi(n) = n \\prod\\limits_{i=1}^s (1 - \\frac{1}{p_i}) \\\\ n = \\sum\\limits_{d \\mid n} \\varphi(d) φ(n)=ni=1∏s​(1−pi​1​)n=d∣n∑​φ(d) μ\\muμ μ\\muμ 与 φ\\varphiφ φ=n∑d∣nμ(d)d\\varphi = n\\sum\\limits_{d \\mid n} \\frac {\\mu(d)}{d} φ=nd∣n∑​dμ(d)​ μ\\muμ 与 ddd 的 d(ij)=∑x∣i∑y∣j[gcd⁡(x,y)=1]d(i j)=\\sum_{x \\mid i} \\sum_{y \\mid j}[\\operatorname{gcd}(x, y)=1] d(ij)=x∣i∑​y∣j∑​[gcd(x,y)=1] 卷积 φ∗1=Id\\varphi*1 = Idφ∗1=Id μ∗1=ε\\mu * 1 = \\varepsilonμ∗1=ε σk=Idk∗1\\sigma_k=Id_k*1σk​=Idk​∗1 常见反演 莫比乌斯反演 \\begin{align} &amp;\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} [gcd(i,j) == 1] \\nonumber \\\\ =&amp;\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} \\sum\\limits_{d \\mid gcd(i,j)} \\mu(d)\\nonumber \\\\ =&amp;\\sum\\limits_{d=1}^n \\mu(d) \\sum\\limits_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum\\limits_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor} 1 \\nonumber \\\\ =&amp;\\sum\\limits_{d=1}^n \\mu(d) \\left\\lfloor \\frac{n}{d} \\right\\rfloor \\left\\lfloor \\frac{m}{d} \\right\\rfloor \\nonumber \\end{align} 欧拉反演 \\begin{align} &amp;\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{n} gcd(i,j)\\nonumber \\\\ =&amp;\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{n} \\sum\\limits_{d \\mid gcd(i,j)} \\varphi(d)\\nonumber \\\\ =&amp;\\sum\\limits_{d=1}^n \\varphi(d) \\sum\\limits_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum\\limits_{j=1}^{\\lfloor \\frac{n}{d} \\rfloor} 1 \\nonumber \\\\ =&amp;\\sum\\limits_{d=1}^n \\varphi(d) \\left\\lfloor \\frac{n}{d} \\right\\rfloor ^2 \\nonumber \\end{align} 狄利克雷前缀和 f(i)=∑d∣ig(i)f(i) = \\sum\\limits_{d\\mid i} g(i) f(i)=d∣i∑​g(i) 类似 癌氏筛 可以在 O(nlog⁡log⁡n)O(n\\log\\log n)O(nloglogn) 内解决这样的问题 先筛个素数 然后用 g(i)g(i)g(i) 更新 f(i)f(i)f(i) code 12345for(int i = 1; i &lt;= cnt; i++)&#123; for(int j = 1; j * prime[i] &lt;= n; j++) g[p[i] * j] += g[j]; &#125; 类似的 还有后缀和 f(i)=∑i∣dg(i)f(i) = \\sum\\limits_{i\\mid d} g(i) f(i)=i∣d∑​g(i) 倒序枚举 12345for(int i = 1; i &lt;= cnt; i++)&#123; for(int j = n/prime[i]; j; j--) g[p[i] * j] += g[j]; &#125; 差不多的 可以用 f(i)f(i)f(i) 求 g(i)g(i)g(i) 两级反转 12345for(int i = cnt; i; i--)&#123; for(int j = n/prime[i]; j; j--) f[j * prime[i]] -= f[j];&#125; 筛子 欧拉筛 线性 O(n)O(n)O(n) 筛质数 Code 筛 mumumu 和 varphivarphivarphi 的版本12345678910111213141516171819void get_prime()&#123; isp[1] = mu[1] = phi[1] = 1; for (int i = 2; i &lt;= maxn; i++) &#123; if (!isp[i]) &#123; prime[++cnt] = i; mu[i] = -1; phi[i] = i - 1; &#125; for(int j = 1;j &lt;= cnt &amp;&amp; i*prime[j] &lt;= MAXN-5; j++) &#123; isp[i * prime[j]] = 1; if(i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; mu[i * prime[j]] = -mu[i]; &#125; &#125;&#125; 杜教筛 可以在较拉的亚线性复杂度内求出积性函数前缀和 现在我们要求 fff 的前缀和 S(n)S(n)S(n)，我们先构造另一个畸性函数 ggg，从他俩的卷积的前缀和入手。 \\begin{align} \\sum\\limits_{i = 1}^n f*g &amp;= \\sum\\limits_{i = 1}^n \\sum\\limits_{d \\mid i} f(d) * g (\\frac id) \\nonumber\\\\ &amp;= \\sum\\limits_{d = 1}^n g(d) \\cdot \\sum\\limits_{i = 1}^{\\frac nd} f(i) \\nonumber\\\\ &amp;= \\sum\\limits_{d = 1}^n g(d) \\cdot S(\\frac nd) \\nonumber \\end{align} 对卷积整前缀和，然后我们把 g(1)g(1)g(1) 提出来 \\begin{align} g(1)S(n) &amp;+ \\sum\\limits_{d = 2}^n g(d)S(\\frac nd) =\\sum\\limits_i^n f*g \\nonumber\\\\ S(n) &amp;=\\frac{\\sum\\limits_i^n f*g - \\sum\\limits_{d = 2}^n g(d)S(\\frac nd)}{g(1)} \\nonumber \\end{align} 我们把它整成了递归形式，后面可以用数论分块，只要能找到合适的 ggg 能快速求出 f∗gf*gf∗g 就行辣 小数据欧拉筛，记忆化一下 Code 筛 mumumu 和 varphivarphivarphi 的版本123456789101112131415161718192021222324252627ll Sum_mu(ll n)&#123; if (n &lt;= maxn) return mu[n]; if (S_mu.count(n)) return S_mu[n]; ll l = 2, r, res = 1; while(l &lt;= n) &#123; r = n / (n / l); res -= 1LL*(r - l + 1) * Sum_mu(n/l); l = r + 1; &#125; return S_mu[n] = res;&#125;ll Sum_phi(ll n)&#123; if (n &lt;= maxn) return phi[n]; if (S_phi.count(n)) return S_phi[n]; ll l = 2, r, res = n * (n+1) /2; while (l &lt;= n) &#123; r = n / (n / l); res -= 1LL*(r - l + 1) * Sum_phi(n/l); l = r + 1; &#125; return S_phi[n] = res;&#125; CRT 求解同余方程组，适用于模数两两互质的情况 {x≡a1 (mod p1)x≡a2 (mod p2)⋮x≡an (mod pn)\\left\\{\\begin{matrix} x \\equiv a_1 \\; (mod \\ p_1)\\\\ x \\equiv a_2 \\; (mod \\ p_2)\\\\ \\vdots \\\\ x \\equiv a_n \\; (mod \\ p_n)\\\\ \\end{matrix}\\right. ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​x≡a1​(mod p1​)x≡a2​(mod p2​)⋮x≡an​(mod pn​)​ ExCRT","categories":[],"tags":[{"name":"数学，数论","slug":"数学，数论","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"}]},{"title":"emoji","slug":"emoji","date":"2022-09-21T13:53:27.000Z","updated":"2022-11-08T10:40:17.179Z","comments":true,"path":"2022/09/21/emoji/","link":"","permalink":"https://ve1bae.github.io/2022/09/21/emoji/","excerpt":"markdown emoji 😃 建议缩放 90%","text":"markdown emoji 😃 建议缩放 90% 经典黄脸Human and humanities 经典黄脸 😃 :) :smiley: 😄 :smile: 😚 :kissing_closed_eyes: 😍 :heart_eyes: ☺️ :relaxed: 😏 :smirk: 😘 :kissing_heart: 😊 :blush: 😆 :laughing: 😳 :flushed: 😝 :stuck_out_tongue_closed_eyes: 😆 :satisfied: 😬 :grimacing: 😉 :wink: 😜 :stuck_out_tongue_winking_eye: 😌 :relieved: 😀 :grinning: 😗 :kissing: 😙 :kissing_smiling_eyes: 😦 :frowning: 😴 :sleeping: 😟 :worried: 😛 :stuck_out_tongue: 😧 :anguished: 😮 :open_mouth: 😁 :grin: 😑 :expressionless: 😯 :hushed: 😕 :confused: 😷 :mask: 😅 :sweat_smile: 😓 :sweat: 😔 :pensive: 😩 :weary: 😥 :disappointed_relieved: 😇 :innocent: 😖 :confounded: 😂 :joy: 😞 :disappointed: 😣 :persevere: 😨 :fearful: 😭 :sob: 😫 :tired_face: 😲 :astonished: 😱 :scream: 😢 :cry: 😐 :neutral_face: 😵 :dizzy_face: 😤 :triumph: 😪 :sleepy: 😎 :sunglasses: 😒 :unamused: 😡 :rage: 👿 :imp: 😈 :smiling_imp: 😶 :no_mouth: 😠 :angry: 😋 :yum: 🤒 :face_with_thermometer: 👽 :alien: 😰 :cold_sweat: 🤕 :face_with_head_bandage: Human 👍 :+1: 👐 :open_hands: 👫 :couple: 👎 :-1: 👇 :point_down: 💑:couple_with_heart: 🤘 :metal: ☝️ :point_up: 🖐️ :raised_hand_with_fingers_splayed: ✌️ :v: 👆 :point_up_2: 👩‍❤️‍👨:couple_with_heart_woman_man: 🖕 :fu: 👈 :point_left: 👩‍❤️‍👩:couple_with_heart_woman_woman: ✊ :fist: 👉 :point_right: 👨‍❤️‍💋‍👨:couplekiss_man_man: 👊 :punch: 👼 :angel: 👩‍❤️‍💋‍👨 :couplekiss_man_woman: ✋ :hand: 👨 :man: 👩‍❤️‍💋‍👩 :couplekiss_man_woman: 👋 :wave: 👦 :boy: 👬 :two_men_holding_hands: 👏:clap: 👭 :two_men_holding_hands: 🙏 :pray: 👲 :man_with_gua_pi_mao: 💪 :muscle: 💁 :information_desk_person: 👂 :ear: 👰‍♀️ :bride_with_veil: 👁️ :eye: 🙋 :raising_hand: 👀 :eyes: 👷 :construction_worker: 👃 :nose: 👳‍♂️ :man_with_turban: 👅 :tongue: 👄 :lips: 💋 :kiss:","categories":[],"tags":[]},{"title":"Kruskal重构树","slug":"kruskal重构树","date":"2022-09-04T02:11:19.000Z","updated":"2022-11-08T10:40:31.949Z","comments":true,"path":"2022/09/04/kruskal重构树/","link":"","permalink":"https://ve1bae.github.io/2022/09/04/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/","excerpt":"挺没用的😰，挺有用的😁，挺没用的😰，挺有用的 😁，挺没用的 😰，挺有😭😭","text":"挺没用的😰，挺有用的😁，挺没用的😰，挺有用的 😁，挺没用的 😰，挺有😭😭 概述 回顾最小生成树的 Kruskal 算法 把每条边按边权排序，用并查集维护连通性，然后把边加入生成树中，直到珈😭乐 n-1 条边 我们每加入一条边时，实际上是合并了两个并查集，每次合并新建一个节点，节点的点权设为这条边的边权，左右儿子设为两个并查集的祖宗，最后得到了一个恰有 n 个 叶节点的二叉树，就是 kruskal 重构树 这张图的 Kruskal重构树长这样 性质 kruskal 重构树有一些很方便的性质 如果是最小生成树，那么重构树上两个节点的 LCA 的点权就是原图上两个节点之间所有简单路径最大边权的最小值 如果是最大生成树，那么重构树上两个节点的 LCA 的点权就是原图上两个节之间点所有简单路径最小边权的最大值 例题 NOIP提高2013 火车运输 一张无向图 nnn 个点， mmm 条边，每条边都有一个最大载重，每次询问从一个节点出发到达另一个节点能最大承受的重量 纯纯滴板子，对原图建最大生成树时建重构树，每次询问输出 LCA 即可 Code LCA 我用的树剖，随便用，都可以用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;#include &lt;stdint.h&gt;#define MAXN 10005#define MAXM 50005#define ll long longusing namespace std;int n, m;struct edge&#123; int st, to, w;&#125;e[MAXM];bool cmp(edge a, edge b)&#123; return a.w &gt; b.w; &#125;int fa[MAXN &lt;&lt; 1];int find(int x)&#123; if(x == fa[x]) return x; else return fa[x] = find(fa[x]);&#125;vector &lt;int&gt; g[MAXN &lt;&lt; 1];int faz[MAXN &lt;&lt; 1];int dis[MAXN &lt;&lt; 1], vis[MAXN &lt;&lt; 1];int siz[MAXN &lt;&lt; 1], son[MAXN &lt;&lt; 1];int dep[MAXN &lt;&lt; 1], top[MAXN &lt;&lt; 1];void dfs1(int u, int dad)&#123; vis[u] = 1; siz[u] = 1; faz[u] = dad; dep[u] = dep[dad] + 1; for(int v : g[u]) &#123; if(v == dad) continue; dfs1(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if(son[u]) dfs2(son[u], tup); for(int v : g[u]) &#123; if(v == son[u] || v == faz[u]) continue; dfs2(v, v); &#125;&#125;int LCA(int u, int v)&#123; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) u = faz[top[u]]; else v = faz[top[v]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int cnt = n; for(int i = 1; i &lt;= n; i++) fa[i] = i; for(int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); e[i] = edge&#123;u, v, w&#125;; &#125; sort(e+1, e+1+m, cmp); for(int i = 1; i &lt;= m; i++) &#123; int fx = find(e[i].st), fy = find(e[i].to); if(fx == fy) continue; fa[fx] = fa[fy] = ++cnt; fa[cnt] = cnt; dis[cnt] = e[i].w; g[cnt].push_back(fx); g[cnt].push_back(fy); g[fx].push_back(cnt); g[fy].push_back(cnt); &#125; for(int i = 1; i &lt;= cnt; i++) &#123; if(!vis[i]) &#123; int u = find(i); dfs1(u, 0); dfs2(u, u); &#125; &#125; int q; scanf(&quot;%d&quot;, &amp;q); for(int i = 1; i &lt;= q; i++) &#123; int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); int fu = find(u), fv = find(v); if(fu != fv) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, dis[LCA(u, v)]); &#125; return 0;&#125; SCOI2013 摩托车交易 一张无向图 nnn 个城市，mmm 条道路， 现在你有一些黄金和 nnn 个订单 ，要依次前往这 nnn 个城市进行 买入/卖出 黄金的交易，但是每条道路对携带的黄金数量有一定限制，也存在一些城市能够互相抵达而且没有限制，询问每个卖出交易最大的交易额度 还是经典 两个节点之间所有简单路径最小边权的最大值 处理到达订单所在城市最多保留的黄金，对于那些特殊的节点，新建一个虚拟节点，把这些节点和虚拟节点都连一条限制特别大的便就行辣 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#define MAXN 500005#define MAXM 2000005#define ll long long#define cjb 1919810114514843using namespace std;int n, m, q, cnt;int a[MAXN];ll b[MAXN];struct edge&#123; int st, to; ll w;&#125;e[MAXM];bool cmp(edge a, edge b)&#123; return a.w &gt; b.w;&#125;int fa[MAXM];int find(int x)&#123; if(x == fa[x]) return x; return fa[x] = find(fa[x]);&#125;ll dis[MAXM];vector &lt;int&gt; g[MAXM];void klskr()&#123; sort(e + 1, e + 1 + m, cmp); for(int i = 1; i &lt;= m; i++) &#123; int u = e[i].st, v = e[i].to; int fu = find(u), fv = find(v); if(fu == fv) continue; cnt++; fa[cnt] = fa[fv] = fa[fu] = cnt; dis[cnt] = e[i].w; g[cnt].push_back(fv); g[cnt].push_back(fu); g[fv].push_back(cnt); g[fu].push_back(cnt); &#125; return;&#125;//树剖LCAint siz[MAXM], dep[MAXM], faz[MAXM];int top[MAXM], son[MAXM]; void dfs1(int u, int dad)&#123; siz[u] = 1; faz[u] = dad; dep[u] = dep[dad] + 1; for(int v : g[u]) &#123; if(v == dad) continue; dfs1(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if(son[u]) dfs2(son[u], tup); for(int v : g[u]) &#123; if(v == son[u] || v == faz[u]) continue; dfs2(v, v); &#125;&#125;int LCA(int u, int v)&#123; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) u = faz[top[u]]; else v = faz[top[v]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); cnt = n; for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); fa[i] = i; &#125; for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;b[i]); for(int i = 1; i &lt;= m; i++) &#123; int u, v; ll w; scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w); e[i] = edge&#123;u, v, w&#125;; &#125; //虚拟节点处理特殊点 for(int i = 1; i &lt;= q; i++) &#123; int u; scanf(&quot;%d&quot;, &amp;u); e[++m] = edge&#123;u, n+1, cjb&#125;; &#125; ++cnt; klskr(); dfs1(cnt, 0); dfs2(cnt, cnt); ll now = b[a[1]]; //当前身上携带的黄金 if(now &lt; 0) &#123; now = 0; printf(&quot;0\\n&quot;); &#125; for(int i = 2; i &lt;= n; i++) &#123; int u = a[i-1], v = a[i]; ll res = dis[LCA(u, v)]; if(b[v] &gt; 0)//买入交易直接全拿下买，如果后来发现买多了就 智慧核心 假装没买 &#123; now = min(now, res) + b[v]; &#125; else &#123; res = min(now, res); ll fk = min(res, abs(b[v])); printf(&quot;%lld\\n&quot;, fk); now = res - min(res, abs(b[v])); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"https://ve1bae.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"9月每日总结","slug":"9月每日总结","date":"2022-08-31T00:04:27.000Z","updated":"2022-11-14T14:23:23.176Z","comments":true,"path":"2022/08/31/9月每日总结/","link":"","permalink":"https://ve1bae.github.io/2022/08/31/9%E6%9C%88%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/","excerpt":"日々私たちが過ごしている日常は、実は、奇跡の連続なのかもしれない。 我们所经历的每个平凡的日常，也许就是连续发生的奇迹。 ——《日常》","text":"日々私たちが過ごしている日常は、実は、奇跡の連続なのかもしれない。 我们所经历的每个平凡的日常，也许就是连续发生的奇迹。 ——《日常》 8.31 T1 现有 nnn 个红珠子和 An+BAn+BAn+B 个蓝珠子，从左往右放珠子，保证任何时候假如有 xxx 个红珠子，蓝珠子数量不超过 Ax+BAx+BAx+B 个，问有多少种摆放方法能摆完所有的珠子 组合数学，难点主要在于一个问题的转换，把 🔴 看成横坐标，把 🔵 看成纵坐标，那么就是从 (0,0)(0,0)(0,0) 走到 (n,An+B)(n, An+B)(n,An+B) 且不越过 y=Ax+By = Ax+By=Ax+B 的方案数 令 m=An+Bm = An+Bm=An+B ，总方案数 Cn+mnC_{n+m}^nCn+mn​ 枚举能够发生越界的每个位置 即 (p,Ap+B)(p, Ap+B)(p,Ap+B) 走到 (p,Ap+B+1)(p, Ap+B+1)(p,Ap+B+1) Cm−Ap−B−1+n−pn−p=A×Cm−Ap−B−1+n−pn−p−1C_{m - Ap -B - 1 + n - p}^{n - p} = A \\times C_{m - Ap - B - 1 + n - p}^{n - p - 1} Cm−Ap−B−1+n−pn−p​=A×Cm−Ap−B−1+n−pn−p−1​ 中间推导过程就是把组合数拆开，提一个 m−Ap−Bn−p\\frac{m-Ap-B}{n-p}n−pm−Ap−B​ 出来 那么最终答案 Cn+mn−A×Cn+mn−1C_{n+m}^{n} - A \\times C_{n+m}^{n-1}Cn+mn​−A×Cn+mn−1​ T2 模拟，没什么好说的，可以用map实现，贪心找最长的关键字还有注意关键字的处理顺序就行 T3 gcd卷积 9.1 给定一些点，从中选取若干个点，使这些点的凸包上的点的个数尽量多 T1 虽然凸包，但是DP 预处理出每个可能成为凸包上的边，枚举端点用 atan2 算一个极角排序就行，然后 f[i][j]f[i][j]f[i][j] 表示最后一个点为 jjj 上一个点为 iii 的点数最大值，开一个辅助数组 mxmxmx 记录走到每个点的点数的最大值，让 f[i][j]f[i][j]f[i][j] 从 mx[i]mx[i]mx[i] 转移，再转移到 mx[j]mx[j]mx[j] 就行辣 123456789101112131415161718for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++) if(j != i) v[++cnt] = vec&#123;i, j, atan2(a[i].y - a[j].y, a[i].x - a[j].x)&#125;; &#125;sort(v + 1, v + 1 + cnt, cmp);for(int i = 1; i &lt;= n; i++)&#123; memset(mx, 0x8f, sizeof(mx)); mx[i] = 0; for(int j = 1; j &lt;= cnt; j++) &#123; int a = v[j].st, b = v[j].to; dp[a][b] = mx[a] + 1; mx[b] = max(mx[b], dp[a][b]); &#125; ans = max(ans, mx[i]);&#125; T2 有两个国家 A 国和 B 国。B 国对 A 国发起了侵略。A 国有 nnn 个城市，道路网络构成一棵树，道路可以双向通行。通过 iii 条道路需要 lil_ili​ 个单位时间。不妨把 A 国的城市编号为 1∼n1 ∼ n1∼n，并把 A 国的首都编号为 111 号。我们定义 “边界城市” 为，以首都为根时，为叶子节点的城市。B 国直接占领了 A 国的所有边界城市。我们记这个时刻为时刻 000。每个被占领的城市每个单位时间可以训练出一个士兵。所有士兵只会朝着首都的方向移动。在每个非边界城市 iii 中有 did_idi​ 个卫兵。当 B 国的一名士兵进入一个城市时，卫兵数量就会且仅会减少 1 。而当一个城市中没有卫兵了之后，这个城市就被 B 国占领了。士兵到达首都并虐了一名首都的卫兵就消失了。请计算出 A 国全部城市都被占领的时刻 对于一个节点 uuu ，disudis_udisu​ 表示其道根节点的距离，tut_utu​ 表示它的 ddd 变成 000 的时间 它在时刻 TTT 的 ddd 的减少数量是 ∑v∈subtree(u)maxT−tu−disv+disu,0 \\sum\\limits_{v \\in subtree(u)} max{T- t_u - dis_v + dis_u, 0} v∈subtree(u)∑​maxT−tu​−disv​+disu​,0 线段树维护 tv−disyt_v - dis_ytv​−disy​ 向上合并即可 9.2 T1 模拟，没什么好说的，唯一注意点就是处理输入和参数是否错误，建议 getline() 直接读入一整行，然后处理参数，不符合范围直接 ERROR ，还有就是地图下标从 0 开始，花了半天搞懂样例 😅 T2 虎哥 要去 ppp 个菜店买菜，同时地图上还有一些障碍，最小化路程的前提下，刀哥希望能迈更宏大的步子，iii 规模的步伐会占据 (2i+1)×(2i+1)(2i+1) \\times (2i+1)(2i+1)×(2i+1) 个格子 首先在每个位置的siz可以预处理出来，然后可以对于每一个🌿🏪跑dij来处理路程和路径siz 又注意到菜市场的数量很少，可以状压表示每一个超市去没去过，小DP即可 123456789101112131415161718192021222324252627282930313233void dij(int x, int y)&#123; priority_queue&lt;qnode&gt; q; memset(f[i][j][n][m], 0x3f, sizeof(f[i][j][n][m])); f[i][j][n][m][x][y] = node&#123;0, 0&#125;; q.emplace(qnode&#123;0, 0, x, y&#125;); while (q.size()) &#123; int dis = q.top().dis; int val = q.top().val; int x = q.top().x; int y = q.top().y; q.pop(); if(f[i][j][n][m][x][y].dis != dis || f[i][j][n][m][x][y].val != val) continue; for(int i = 0; i &lt; 4; i++) &#123; int qx = x + dx[i], qy = y + dy[i]; if(qx &lt; 1 || qx &gt; n || qy &lt; 1 || qy &gt; m || a[qx][qy]) continue; if(f[i][j][n][m][qx][qy].dis &gt; dis + 1 || (f[i][j][n][m][qx][qy].dis == dis + 1 &amp;&amp; f[i][j][n][m][qx][qy].val &lt; val + b[qx][qy])) &#123; f[i][j][n][m][qx][qy].dis = dis + 1; f[i][j][n][m][qx][qy].val = val + b[qx][qy]; q.emplace(qnode&#123;f[i][j][n][m][qx][qy].dis, f[i][j][n][m][qx][qy].val, qx, qy&#125;); &#125; &#125; &#125;&#125;for(i = 1; i &lt; 1 &lt;&lt; p; i++)for(j = 0; j &lt; p; j++) if((i &gt;&gt; j) &amp; 1) //i得去过for(k = 0; k &lt; p; k++) if(((i &gt;&gt; k) &amp; 1) &amp;&amp; k != j)//k得去过f[i][j] = min(f[i][j], f[i ^ (1 &lt;&lt; j)][k] + dis[k][j]); 9.3 有 nnn 个数，可以选择有 kkk 个数的组合，它的贡献是组合中最大的数，求所有组合贡献之和 T1 考虑每个数产生的贡献，那么就要求选了 kkk 个数，而且当前数为最大值，那么当前数一定要选，之后再从小于等 于当前数的数中选剩下的 k−1k-1k−1 个方案数 ansi=Ccnt[ai]k−1×aians_i = C_{cnt[a_i]}^{k-1} \\times a_i ansi​=Ccnt[ai​]k−1​×ai​ 但是有数值相同的数时会算重或者少算，有一种巧妙的方法就是直接排序，看代码体会 123sort(a + 1, a + 1 + n);for (int i = 1; i &lt;= n; i++)ans = ans + C(i-1, k-1) * a[i]; T2 小Q 在独木桥上彷徨了。他知道，他只剩下了 NNN 秒的时间，每一秒的时间里，他会向左或向右移动一步。NNN 秒之后，小Q 恰好到达出发处，且他每两次经过此位置的时间间隔不会超过 MMM 秒。那么问题来了，这 N 秒的时&gt; 间里，小Q 的路线总共会有多少种可能的形式 考试时连题都没看懂 😭 我们把第一次到达某个地点看作左括号，回到这个地点看作右括号，那么合法的移动形成的括号序列长度 ⩽m\\leqslant m⩽m，而且是偶数 于是我们可以把长度为 2,4,…m2, 4, \\dots m2,4,…m 和括号序列有多少种预处理出来 枚举括号长度 f[i]=f[i−len]+a[len]f[i] = f[i-len] + a[len]f[i]=f[i−len]+a[len] 发现是一个递推而且的过程 mmm 不大，于是考虑矩阵加速 T3 初始一个数 BBB，在 nnn 秒内每一秒都会增加 AAA 求各个时刻数的二进制表示 111 的个数和 不难发现累加 AAA 的贡献是有循环节的，也就是说 B+iAB + iAB+iA 和 B+2kaB + 2^kaB+2ka 的 第 kkk 位是相同滴。 所以可以计算出前 xxx 项的二的整数次幂位上一共有几个 111 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#define ll long longusing namespace std;ll A, B, N, ans;ll calc(ll x, ll bit) //前x项的第bit位上有几个1&#123; ll ans = 0, f[i][j][n][m] = 0; for(ll i = 1; i &lt;= x; i++) &#123; ll to = B + A*i; //bit 是一个2的整次幂,(bit &gt;&gt; 1) 的形式是100...000 与之比较就能确定当前最高位是1还是0 if(to % bit &lt; (bit &gt;&gt; 1)) //当前是 0,只能从上一位进位 &#123; i = min(x, i + ((bit &gt;&gt; 1)-1 - to%bit)/A); &#125; else //当前位是 1,可以从当前位进位 &#123; f[i][j][n][m] = min(x, i + (bit-1 - to%bit)/A); ans += f[i][j][n][m] - i + 1; i = f[i][j][n][m]; &#125; &#125; return ans;&#125;int main()&#123; int t; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;A, &amp;B, &amp;N); ll to = B + A*N; ans = 0; for(ll i = 2; i &lt; (to &lt;&lt; 1); i &lt;&lt;= 1) &#123; if(N / i) ans += 1LL*(N / i) * calc(i ,i); ans += calc(N % i, i); &#125; printf(&quot;%lld\\n&quot;, ans); &#125; return 0;&#125; 9.5 T1 AT4168 给定一个长为 2n2^n2n 的序列 AAA ，编号 0…2n−10 \\dots 2^n-10…2n−1 ，对于每一个 k(0≤k≤2n)k (0 \\leq k \\leq 2^n)k(0≤k≤2n) ，求 max(Ai+Aj)(i or j⩽k)max(A_i + A_j) (i \\; or \\; j \\leqslant k)max(Ai​+Aj​)(iorj⩽k) 肯定是在满足条件的数里选两个最大的，那么维护一个集合中的最大值和次大值，暴力枚举集合中的数肯定不行，考虑如何快速的求出符合条件的数的集合。对于一个数 kkk ，它的每一个 lowbitlowbitlowbit 和 它减去它的这个 lowbitlowbitlowbit 或起来一定小于等于它所以枚举 lowbitlowbitlowbit 然后再不断更新最大值 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 300005using namespace std;int n, N;struct node &#123; int id, mx, cmx; &#125; a[MAXN];int ans [MAXN];node Max (node a, node b)&#123; node c; if (a.mx &gt; b.mx) &#123; c.mx = a.mx; c.id = a.id; c.cmx = max(a.cmx, b.mx); &#125; else if(b.mx &gt; a.mx) &#123; c.mx = b.mx; c.id = b.id; c.cmx = max(a.mx, b.cmx); &#125; else &#123; c.mx = a.mx; c.id = a.id; if (a.id == b.id) c.cmx = max(a.cmx, b.cmx); else c.cmx = b.mx; &#125; return c; &#125;#define lowbit(i) (i &amp; -i)int main()&#123; scanf(&quot;%d&quot;, &amp;n); N = 1 &lt;&lt; n; for (int i = 0; i &lt; N; i++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); a[i] = node &#123; i, x &#125;; &#125; for (int k = 1; k &lt; N; k++) &#123; int now = k; while(now) &#123; int i = lowbit(now); a[k] = Max(a[k], a[k - i]); now -= i; &#125; &#125; for (int i = 1; i &lt; N; i++) &#123; ans[i] = max(ans[i-1], a[i].mx + a[i].cmx); printf(&quot;%d\\n&quot;, ans[i]); &#125; return 0;&#125; T2 给定一个整数数列 aaa，定义 f(a)=max1⩽i⩽j⩽n(aj−ai)f(a)=max_{1 \\leqslant i \\leqslant j \\leqslant n}(a_j−a_i)f(a)=max1⩽i⩽j⩽n​(aj​−ai​)，保证 f(a)&gt;0f(a)&gt;0f(a)&gt;0，你需要求出至少需要修改 aaa 的多少个位置才能使 f(a)f(a)f(a) 变小 首先按照最小值分成若干段，显然每段之间互不影响。对于每一段，我们只需要考虑最大值和最小值之差。如果两个极值之差等于 f(a)f(a)f(a)，那么必须从中间选定一个位置 iii ，将 iii 之前的最小值和之后的最大值删去 Code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 1000005#define cjb 1145141919using namespace std;int n;int a[MAXN];int mx, mi, ans;int main()&#123; scanf(&quot;%d&quot;, &amp;n); mi = cjb; mx = -cjb; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); mx = max(mx, a[i] - mi); mi = min(mi, a[i]); &#125; int i, j, cnt = 0, len = 0; for (i = 1; i &lt;= n; i = j) &#123; len = cnt = 0; for (j = i; j &lt;= n &amp;&amp; a[i] &lt;= a[j]; j++) &#123; if (a[j] == a[i]) cnt++; else if (a[j] - a[i] == mx) &#123; cnt--; len = min(len, cnt); ans++; &#125; &#125; ans += len; &#125; printf(&quot;%d&quot;, ans); return 0;&#125; 9.6 T1 有 nnn 个数。你需要找出它们的一个排列，满足 mmm 个条件，每个条件形如 xax_axa​ ​必须在 xbx_bxb​ 之前​，求满足条件的最大子段和 最小割。 对每一个数拆点 如果 aia_iai​ 为正数，那么 超🐔源点连向入点，出点连向超🐔汇点 流量为 aia_iai​ 的边， 如果这条边被割了，说明这个数被放到了选中的子序列的前边或后边 如果 aia_iai​ 为负数，那么在入点和出点间连一条流量为 ∣ai∣\\left\\vert a_i \\right\\vert∣ai​∣ 的边，如果这条边被割了，说明这个数被加到了子序列里 对于每个限制，就分别把两个点的入点和出点连起来，流量超🐔大，这样限制一定满足，因为不会被割 答案就是 正数和-最小割 T2 CF1616H 给定一个数列，和一个数 xxx ，求有多少个数列的子集，满足集合中的数两两异或都不大于 xxx 看到异或，考虑建01Trie，先把集合中的数插入Trie中，因为统计个数，记录每个节点被几个集合中的数用到 然后考虑如何满足限制，经典从高位向地位开始插，然后从高位向第位遍历，分情况讨论 如果当前遍历的两个节点是同一个节点： 如果 xxx 在这一位上是 111 ，那么同时递归左子树和右子树 如果 xxx 在这一位上是 000 ，那么分别递归左子树和右子树 如果当前遍历的两个节点是不同节点： 如果 xxx 在这一位上是 111 ，那么递归两个节点的不同子树，两种情况的答案乘起来 如果 xxx 在这一位上是 000 ，那么递归相同子树，再统计一下单独在一棵子树里的答案返回 还有就是注意一些小细节，比如空集重复计算减一的问题 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#define mbit 30#define MAXN 150005#define mod 998244353#define ll long longusing namespace std;int n, m;ll pow2[MAXN];namespace Trie&#123; int tot = 1; int siz[MAXN * mbit]; int ch[MAXN * mbit][2]; #define ls(i) (ch[i][0]) #define rs(i) (ch[i][1]) void insert(int x) &#123; int u = 1; siz[u]++; for (int i = mbit; i &gt;= 0; i--) &#123; int bit = (x &gt;&gt; i) &amp; 1; if(!ch[u][bit]) ch[u][bit] = ++tot; u = ch[u][bit]; siz[u]++; &#125; &#125;&#125;using namespace Trie;ll dfs(int u1, int u2, int d)&#123; int bit = (m &gt;&gt; d) &amp; 1; if(!u1 || !u2) return pow2[siz[u1 + u2]]; if(u1 == u2) &#123; if (d &lt; 0) return pow2[siz[u1]]; if (bit) return dfs(ls(u1), rs(u1), d-1) %mod; else return (dfs(ls(u1), ls(u1), d-1) + dfs(rs(u1), rs(u1), d-1) -1 + mod)%mod; &#125; else &#123; if (d &lt; 0) return pow2[siz[u1] + siz[u2]]; if (bit) return (dfs(ls(u1), rs(u2), d-1) * dfs(rs(u1), ls(u2) , d-1)) %mod; else &#123; ll ans = (dfs(ls(u1), ls(u2), d-1) + dfs(rs(u1), rs(u2), d-1) -1 + mod)%mod; ans = (ans + (pow2[siz[ls(u1)]]-1 +mod) * (pow2[siz[rs(u1)]] - 1 + mod)%mod)%mod; ans = (ans + (pow2[siz[ls(u2)]]-1 +mod) * (pow2[siz[rs(u2)]] - 1 + mod)%mod)%mod; return ans; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); pow2[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); insert(x); pow2[i] = pow2[i-1] * 2LL %mod; &#125; printf(&quot;%lld&quot;, (dfs(1, 1, mbit)-1 +mod) %mod); return 0;&#125; 9.7 T1 🐯哥从东百来到广州，要看广州塔，刀哥选择坐船去，可惜堵船了，而且🔪哥恰好在离塔最远的船上，每艘船的船头距离塔的距离为 xix_ixi​，船长为 lil_ili​ ，速度为 viv_ivi​ ，计算🐯哥来广州塔需要多长时间 一艘船的能够船头能够碰到广州塔，那么它前面的船的船尾已经经过了塔，所以每艘船一共要走的路程实际上是它的船头到塔的距离加上它前面所有船的船长（除了🐯所在的第一艘船），后面的船会挡到前面的船，所以取max 1234for (int i = 2; i &lt;= n; i++)sum[i] = sum[i-1] + a[i];for (int i = 1; i &lt;= n; i++)ans = max(ans, (x[i] + sum[i])/v[i]); T2 一张无向图 nnn 个点， mmm 条边，询问能不能把每条路都走一遍且只走一边，如果实在不能的话使用传送，可以传送到任意城市，询问最少传送几次，输出路径 一眼题目应该是欧拉路径，先对每个连通块处理出度数为奇数的点，使用传送把他们两两连边，在选出每个连通块的起点和终点，把连通块之间连边。最后dfs输出路径 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990void bfs(int st)&#123; queue &lt;int&gt; q; vector &lt;int&gt; p; q.push(st); vis[st] = 1; while(q.size()) &#123; int u = q.front(); q.pop(); if(d[u] &amp; 1) p.push_back(u); for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (!vis[v]) &#123; vis[v] = 1; q.push(v); &#125; &#125; &#125; for (int i = 2; i &lt; p.size(); i += 2) //奇度数点两两连边就能相互抵达 &#123; adde(p[i], p[i+1]); adde(p[i+1], p[i]); tot++; &#125; //连通块内起点终点 if(p.size()) s = p[0], t = p[1]; //没有奇度数点说明这个连通块是欧拉回路，任选一个点就行 else s = t = st;&#125;void print()&#123; printf(&quot;%d &quot;, sta.size()); while(sta.size()) &#123; printf(&quot;%d &quot;, sta.top()); sta.pop(); &#125; ENDL;&#125;void dfs(int u)&#123; for (int i = head[u]; i; i = e[i].nxt) if (!vis[i]) &#123; vis[i] = vis[i ^ 1] = 1; head[u] = i; int v = e[i].to; dfs(v); if(i/2 &gt; m) print(); //题目要求，使用传送换个行 else sta.push(i &amp; 1 ? -i/2 : i/2);//题目要求，正着走正，反着走负 &#125;&#125;void solve()&#123; for (int i = 1; i &lt;= n; i++) if(head[i]) &#123; if(!vis[i]) &#123; tot++; bfs(i); if(alls) &#123; adde(alls, s); adde(s, alls); allt = t; &#125; else alls = s, allt = t;//处理整张图的起点终点 &#125; &#125; printf(&quot;%d\\n&quot;, tot-1); memset(vis, 0, sizeof(vis)); dfs(alls); print();&#125;int main()&#123; freopen(&quot;travelling.in&quot;, &quot;r&quot;, stdin); freopen(&quot;travelling.out&quot;, &quot;w&quot;, stdout); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; clannad(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); adde(x, y); adde(y, x); d[x]++; d[y]++; &#125; solve(); &#125;&#125; T3 8×88 \\times 88×8 网格图，上面有一些点需要建立基站，每建好一个基站需要和已经建好的基站调试一次，若两个基站的坐标分别为 (x1,y1)(x1,y1)(x1,y1) 和 (x2,y2)(x2,y2)(x2,y2) 调试的时间是 max(∣x1−x2∣,∣y1−y2∣)max(\\left\\vert x_1 - x_2 \\right\\vert,\\left\\vert y_1 - y_2 \\right\\vert)max(∣x1​−x2​∣,∣y1​−y2​∣)，建立这个基站总的调试时间是和这些基站调试时间的最大值，确定一个顺序，使得总共的调试时间最小 如果是一个序列，那么先中间后两边，的调试时间是最小的。网格图也是这样，先中间，后四周。以这个为基础进行DP 123456789101112131415161718192021222324//计算区域内贡献int ask(int i, int j, int n, int m, int s1, int t1, int s2, int t2)&#123; int tmp = 0; for(int p = s1; p &lt;= s2; p++) for(int q = t1; q &lt;= t2; q++) &#123; if(id[p][q] == 1) tmp += max( max(Abs((p-i)), Abs((p-n))), max(Abs((q-j)), Abs((q-m)))); &#125; return tmp;&#125;int dp(int i, int j, int n, int m)&#123; if(i &gt; n || j &gt; m) return 0; if(f[i][j][n][m] &gt; -1) return f[i][j][n][m]; //记忆化 //四个方向，扩展一行/列 f[i][j][n][m] = min(f[i][j][n][m], ask(i, j, n, m, i, j, i, m) + dp(i+1, j, n, m)); f[i][j][n][m] = min(f[i][j][n][m], ask(i, j, n, m, i, j, n, j) + dp(i, j+1, n, m)); f[i][j][n][m] = min(f[i][j][n][m], ask(i, j, n, m, n, j, n, m) + dp(i, j, n-1, m)); f[i][j][n][m] = min(f[i][j][n][m], ask(i, j, n, m, i, m, n ,m) + dp(i, j, n, m-1)); return f[i][j][n][m];&#125; 9.8 T1 ARC101C 给定一个大小为 nnn 的树，保证 nnn 为偶数且小于 50005000。您需要给树上的点两两配对，对于一组对子 (u,v)(u,v)(u,v) ，在树上将 u→vu \\to vu→v 的路径染色，定义一个配对方案合当且仅当所有边都有颜色，求和法染色的方案 先预处理除 iii 个点任意配对的方案数 gig_igi​ ，gi=∏i−2k+1nig_i= \\prod\\limits_{i - 2k+1}^n igi​=i−2k+1∏n​i for (int i = 2; i &lt;= n; i++) g[i] = g[i-2] *(i-1) %mod; f(s)f(s)f(s) 表示边集 SSS 内的方案数，全集为 EEE ，容斥一下 ans=∑S⊆E(−1)∣S∣f(S)ans = \\sum\\limits_{S \\subseteq E} (-1)^{\\vert S \\vert} f(S) ans=S⊆E∑​(−1)∣S∣f(S) 然后考虑dp，dp(i,j)dp(i,j)dp(i,j) 表示以 iii 为根的子树内，iii 所在的连通块大小为 jjj 的答案，枚举子树乘法原理转移 12345678910111213141516171819void dfs(int u, int fa)&#123; siz[u] = 1; dp[u][1] = 1; for (int v : e[u]) &#123; if (v == fa) continue; dfs(v, u); for (int i = 1; i &lt;= siz[u] + siz[v]; i++) f[i] = 0; for (int i = 1; i &lt;= siz[u]; i++) for (int j = 1; j &lt;= siz[v]; j++) &#123; f[i] = (f[i] - dp[u][i]*dp[v][j]%mod * g[j]%mod + mod) %mod; f[i+j] = (f[i+j] + dp[u][i] * dp[v][j]%mod)%mod; &#125; siz[u] += siz[v]; for (int i = 1; i &lt;= siz[u]; i++) dp[u][i] = f[i]; &#125;&#125; T2 ARC088C 给定一个字符串，每次可以交换任意相邻的两个字符，询问最少交换几次可以变成一个回文串，无解输出 -1 如果长度为奇数，那么有一个字符出现次数是奇数，如果长度为偶数，那么没有字符出现次数为奇数，否则无解 依次扫描字符串，寻找最靠后的相同字符与它匹配，按这个策略处理出每个字符在回文串中的位置，求逆序对即可 可以预处理除每个字符所有的出现位置 12345678910111213141516171819202122232425262728293031323334for (int i = 1; i &lt;= n; i++)&#123; q[s[i] - &#x27;a&#x27;].push_back(i); cnt[s[i]- &#x27;a&#x27;]++; &#125;for (int i = 0; i &lt; 26; i++) if(cnt[i] &amp; 1)ji++;if(n % 2 == 0)&#123; if(ji) printf(&quot;-1&quot;); return 0;&#125;else if(ji &gt; 1) printf(&quot;-1&quot;); return 0;//我这里使用了双端队列维护for (int i = 1; i &lt;= n; i++) if(!pos[i])&#123; int x = q[s[i] - &#x27;a&#x27;].front(); int y = q[s[i] - &#x27;a&#x27;].back(); if(x == y) pos[x] = (n+1)/2; else &#123; q[s[i] - &#x27;a&#x27;].pop_back(); q[s[i] - &#x27;a&#x27;].pop_front(); pos[x] = ++tot; pos[y] = n-tot+1; &#125;&#125;//树状数组求逆序对for (int i = 1; i &lt;= n; i++)&#123; add(pos[i], 1); ans += i - query(pos[i]);&#125;printf(&quot;%lld&quot;, ans); 9.9 T1 CF1422F 给定一个序列，求区间 lcmlcmlcm 。n⩽100000n \\leqslant 100000n⩽100000 ，ai⩽2000000a_i \\leqslant 2000000ai​⩽2000000 先莽一个线段树上去发现不对，然后考虑对每一个数唯一分解，实际上把问题转化为了素数个数的最大值问题， 人类智慧根号分治 小于等于 a\\sqrt{a}a​ 的 质数只有 868686 个，ST表处理 大于 a\\sqrt{a}a​ 的问题转化为区间出现过的数的乘积，而且可以发现 aaa 只含有一个这样的质因数，维护 preipre_iprei​ 表示 iii 上一次出现的位置，用一个单点修改，区间求乘积的主席数维护 T2 CF741D 一个 111 为根节点的数，每条边上有一个字符 a va~va v 22种，询问所有子树中最长的简单路径使得路径上的字母重排后可以变成回文串 看到对于子树的询问，考虑 dsu on tree 。一个字符串能重排成回文串，那么出现奇数次的字符最多有一个。思考只有22个字符的深意，我们可以状压每一种字符出现的次数为奇数还是偶数，细节看代码 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//cnt[i] 表示子树内字符状态为 i 的最大深度void dfs(int u, int fa)&#123; siz[u] = 1; dep[u] = dep[fa] + 1; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; //预处理除每个节点到根节点的字符状态 num[v] = num[u] ^ (1 &lt;&lt; e[i].dis); dfs(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;int now;void add1(int u)&#123; // 看看有没有出现状态和当前一样节点的，可以合并成一个偶回文串 ans[now] = max(ans[now], dep[u] + cnt[num[u]]); // 枚举状态，合并奇回问串 for (int i = 0; i &lt; 22; i++) ans[now] = max(ans[now], dep[u] + cnt[(1 &lt;&lt; i) ^ num[u]]);&#125;// 不能自己和自己合并，所以不能写在一个函数里void add2(int u)&#123; // 用当前节点更新当前状态 cnt[num[u]] = max(cnt[num[u]], dep[u]);&#125;// 加子树贡献void adds1(int u)&#123; add1(u); for (int i = head[u]; i; i = e[i].nxt) adds1(e[i].to);&#125;void adds2(int u)&#123; add2(u); for (int i = head[u]; i; i = e[i].nxt) adds2(e[i].to);&#125;// 淸子树贡献void clannad(int u)&#123; cnt[num[u]] = -cjb; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; clannad(v); &#125;&#125;void dsu(int u)&#123; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v != son[u]) &#123; dsu(v); clannad(v); &#125; &#125; if(son[u]) dsu(son[u]); now = u; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v != son[u]) &#123; adds1(v); adds2(v); &#125; &#125; add1(u), add2(u); // 这里的ans是限定必须经过u的路径，类似与点分治 ans[u] -= dep[u] * 2; //减lca也就是u的深度 // 因为有必须经过u的限制，所以要和它的子树取max for (int i = head[u]; i; i = e[i].nxt) ans[u] = max(ans[u], ans[e[i].to]);&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; (1 &lt;&lt; 22); i++) cnt[i] = -cjb; for (int i = 2; i &lt;= n; i++) &#123; int x; char c; cin &gt;&gt; x &gt;&gt; c; adde(x, i, c - &#x27;a&#x27;); &#125; dfs(1, 0); dsu(1); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; max(ans[i], 0) &lt;&lt; &#x27; &#x27;; return 0;&#125; 9.11 T1 ARC117E 给定 nnn 和 kkk ，求有多少长度为 2n2n2n 的列 A(a1,a2,a3⋯a2n)A(a_1,a_2,a_3 \\cdots a_{2n})A(a1​,a2​,a3​⋯a2n​) 满足序列中恰好分别有 nnn 个 111 和 nnn 个 −1-1−1 并且有且仅有 kkk 对 (l,r)(l, r)(l,r) 满足 (1⩽l⩽r)(1 \\leqslant l \\leqslant r)(1⩽l⩽r) 且 (∑i=lrai)=0(\\sum\\limits_{i = l}^r a_i) = 0(i=l∑r​ai​)=0 因为序列中之有 000 和 111 ，所以序列中的前缀和应该是这样的 图片来自官方题解 DP，设状态为 f[i][j][k] 表示当前构造了长度为 iii 的序列，有 jjj 个和为 000 的区间，中间有 kkk 个没填上的数 于是有转移式 f[i+len][j+Clen2][x−(k+1)]+=f[i][j][k]f[i+len][j+C_{len}^2][x - (k + 1)] += f[i][j][k]f[i+len][j+Clen2​][x−(k+1)]+=f[i][j][k] T2 ARC117F 有一个长度为 2n2n2n 的环 A(a1,a2,⋯a2n)A(a_1, a_2, \\cdots a_{2n})A(a1​,a2​,⋯a2n​)，对应的每个位置上有一个限制 bib_ibi​ ，表示 bi⩽∑ii+n−1aib_i \\leqslant \\sum\\limits_{i}^{i+n-1} a_ibi​⩽i∑i+n−1​ai​ ，请你在满足所有限制的情况下，构造一种方案，使得 ∑ai\\sum a_i∑ai​ 最小 记前缀和 SiS_iSi​ ，可以发现 S2nS_{2n}S2n​ 对于这些限制是有单调性的 对于编号小于 nnn 的位置，它的限制转化为 bi⩽Si+n−1−Si−1b_i \\leqslant S_{i+n-1} - S_{i-1}bi​⩽Si+n−1​−Si−1​ 对于编号大于 nnn 的位置，它的要求可以转化为 S2n−bi⩾Si−1−Si−nS_{2n} - b_i \\geqslant S_{i-1} - S_{i-n}S2n​−bi​⩾Si−1​−Si−n​ 那么对每一个 aia_iai​ 都有 bi⩽Si+n−1−Si−1⩽S2n−bi+nb_i \\leqslant S_{i+n-1} - S_{i-1} \\leqslant S_{2n} - b_{i+n}bi​⩽Si+n−1​−Si−1​⩽S2n​−bi+n​ 我们可以二分 S2nS_{2n}S2n​ T3 CF19D 维护一个二维点集，支持添加一个点，删除一个点，查询点后后继 (x′&gt;x,y′&gt;y)(x&#x27; &gt; x, y&#x27; &gt; y)(x′&gt;x,y′&gt;y) 鉴定为数据结构，使用权值线段树维护 xxx 值， 套 setsetset 维护 yyy 值 首先 xxx 是挺大的，先进行一个离线和离散化，然后就干嘛干嘛就行辣 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#define MAXN 200005#define pir pair &lt;int, int&gt;#define mkp make_pairusing namespace std;int h[MAXN], maxx;struct OPOPOP&#123; int id; int x, y;&#125;q[MAXN];multiset &lt;int&gt; s[MAXN];namespace Leitree&#123; struct tree &#123; int l, r; int max; &#125;t[MAXN &lt;&lt; 2]; #define ls(i) (i &lt;&lt; 1) #define rs(i) (i &lt;&lt; 1 | 1) void push_up(int i) &#123; t[i].max = max(t[ls(i)].max, t[rs(i)].max); &#125; void build(int i, int l, int r) &#123; t[i].l = l; t[i].r = r; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(ls(i), l, mid); build(rs(i), mid+1, r); &#125; void change(int i, int pos, int val, int op) &#123; if (t[i].l == pos &amp;&amp; t[i].r == pos) &#123; if (op == 1) &#123; s[pos].insert(val); t[i].max = max(t[i].max, val); &#125; else &#123; s[pos].erase(val); if (s[pos].empty()) t[i].max = 0; else t[i].max = *s[pos].begin(); &#125; return; &#125; int mid = (t[i].l + t[i].r) &gt;&gt; 1; if (pos &lt;= mid) change(ls(i), pos, val, op); else change(rs(i), pos, val, op); push_up(i); &#125; pir query(int i, int l, int r, int val) &#123; if (t[i].max &lt;= val) return mkp(-1, -1); if (t[i].l == t[i].r) &#123; int x = t[i].l; return mkp(h[x], *s[x].upper_bound(val)); &#125; int mid = (t[i].l + t[i].r) &gt;&gt; 1; pir ans; if (t[ls(i)].r &gt;= l) &#123; ans = query(ls(i), l, r, val); if (ans.first != -1) return ans; &#125; if (t[rs(i)].l &lt;= r) &#123; ans = query(rs(i), l, r, val); if (ans.first != -1) return ans; &#125; return mkp(-1, -1); &#125;&#125;using namespace Leitree;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; char op[10]; int x, y; scanf(&quot;%s%d%d&quot;, op+1, &amp;x, &amp;y); if (op[1] == &#x27;a&#x27;) q[i].id = 1; if (op[1] == &#x27;r&#x27;) q[i].id = 2; if (op[1] == &#x27;f&#x27;) q[i].id = 3; q[i].x = x; q[i].y = y; h[++cnt] = x; h[++cnt] = x + 1; //这里加入 x+1 是因为查询的时候是查x+1 //防止离散化出锅，xdm可以试一试 &#125; sort(h + 1, h + 1 + cnt); maxx = unique(h + 1, h + 1 + cnt) - h-1; build(1, 1, maxx); for (int i = 1; i &lt;= n; i++) &#123; int x = lower_bound(h + 1, h + 1 + maxx, q[i].x) - h; if (q[i].id == 3) &#123; pir ans = query(1, x+1, maxx, q[i].y); if (ans.first != -1) printf(&quot;%d %d\\n&quot;, ans.first, ans.second); else printf(&quot;-1\\n&quot;); &#125; else change(1, x, q[i].y, q[i].id); &#125; return 0;&#125; 9.12 T3 CF1503E n×mn \\times mn×m 的棋盘，每个格子可以染成黄色或者蓝色，定义合格的染色方案是每行有且只有一段蓝色的格子，每列有且只有一段黄色的格子，求一共有多少种合格的染色方案 通过这个定义我们发现，差不多和格的染色方案都是长这样的 也就是说，存在一条分界线，使得所有黄色的连通块互相不越过这条分界线 ，而且都到达了分界线 所以枚举分界线和黄色连通块上 🍌 的两个离得近的点，计算黄色连通块可能的方案数，具体而言就是说计算边界四个点到这两个点的方案数 ，整点组合数算路径 还有一种情况，无非是把棋盘翻转， n,mn,mn,m 交换一下 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#define ll long long#define mod 998244353#define RTX 4080using namespace std;ll n, m, ans;ll jc[RTX], ijc[RTX];ll ksm (ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a %mod; a = a * a %mod; b &gt;&gt;= 1; &#125; return ans;&#125;void get_jc(int RTXON = 4060)&#123; jc[0] = jc[1] = 1; ijc[0] = 1; for (int i = 2; i &lt;= RTXON; i++) jc[i] = 1LL*i * jc[i-1] %mod; ijc[RTXON] = ksm(jc[RTXON], mod-2); for (int i = RTXON-1; i; i--) ijc[i] = ijc[i+1] * 1LL*(i+1) %mod;&#125;ll Ways(ll n, ll m)&#123; return jc[n + m] * ijc[n] %mod * ijc[m] %mod;&#125;int main()&#123; scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); get_jc(); for (int i = 1; i &lt;= m-1; i++) &#123; ll sum = 0; for (int j = 1; j &lt;= n-1; j++) &#123; sum = (sum + Ways(i, j-1) * Ways(i-1, n-j)%mod)%mod; ans = (ans + sum * Ways(m-i-1, j)%mod * Ways(m-i, n-j-1)%mod)%mod; &#125; &#125; swap(n, m); for (int i = 1; i &lt;= m-1; i++) &#123; ll sum = 0; for (int j = 1; j &lt;= n-1; j++) &#123; ans = (ans + sum * Ways(m-i-1, j)%mod * Ways(m-i, n-j-1)%mod)%mod; sum = (sum + Ways(i, j-1) * Ways(i-1, n-j)%mod)%mod; &#125; &#125; printf(&quot;%lld&quot;, ans*2%mod); return 0;&#125; 9.13 T1 给出两颗 nnn 点的有根树，TAT_ATA​ 和 TBT_BTB​，他们的根都是 111 mmm 次询问，每次询问两个点 uuu， vvv ，求一个编号最大的点 ccc ，使得 ccc 在 TAT_ATA​ 上是 uuu 的祖先，在 TBT_BTB​ 上是 vvv 的祖先 对于 AAA 树上的每一个点建立主席树，维护这个点在 BBB 树上的的祖先信息，具体而言就是说插入这个点在 BBB 树上DFS序，然后对它的子树，进行最大值覆盖 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAXN 100005using namespace std;int n, m;vector &lt;int&gt; e1[MAXN];vector &lt;int&gt; e2[MAXN];namespace Leitree&#123; int rt[MAXN &lt;&lt; 5]; int tot; struct tree &#123; int ls, rs; int max; &#125;t[MAXN &lt;&lt; 5]; #define ls(i) (t[i].ls) #define rs(i) (t[i].rs) int newnode() &#123; ++tot; return tot; &#125; void push_up(int i) &#123; t[i].max = max(t[ls(i)].max, t[rs(i)].max); &#125; void insert(int &amp;i, int last, int l, int r, int L, int R, int val) &#123; i = ++tot; t[i] = t[last]; if (l &gt;= L &amp;&amp; r &lt;= R) &#123; t[i].max = max(t[i].max, val); return; &#125; int mid = (l + r) &gt;&gt; 1; if (mid &gt;= L) insert(ls(i), ls(last), l, mid, L, R, val); if (mid &lt; R) insert(rs(i), rs(last), mid+1, r, L, R, val); &#125; int query(int i, int l, int r, int pos) &#123; if (!i) return 0; if (l == pos &amp;&amp; r == pos) return t[i].max; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) return max(t[i].max, query(ls(i), l, mid, pos)); else return max(t[i].max, query(rs(i), mid+1, r, pos)); &#125; #undef ls #undef rs&#125;using namespace Leitree;int T, siz[MAXN], dfn[MAXN], idfn[MAXN];void dfs1(int u)&#123; siz[u] = 1; dfn[u] = ++T; idfn[T] = u; for (int v : e2[u]) &#123; dfs1(v); siz[u] += siz[v]; &#125;&#125;void dfs2(int u, int dad)&#123; insert(rt[u], rt[dad], 1, n, dfn[u], dfn[u] + siz[u] - 1, u); for (int v : e1[u]) dfs2(v, u); &#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 2; i &lt;= n; i++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); e1[x].push_back(i); &#125; for (int i = 2; i &lt;= n; i++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); e2[x].push_back(i); &#125; dfs1(1); dfs2(1, 0); int last_ans = 0; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); x = (x + last_ans) %n + 1; y = (y + last_ans) %n + 1; printf(&quot;%d\\n&quot;, last_ans = query(rt[x], 1, n, dfn[y])); &#125; return 0;&#125; T2 A,B,C,DA, B, C, DA,B,C,D 求有多少个 iii 满足 [A+Bi,A+Ci][A+B_i, A+C_i][A+Bi​,A+Ci​] 中没有 DDD 的整数倍数 求这个 ∑i=1n[⌊A+BiD⌋=⌊A+CiD⌋]\\sum\\limits_{i = 1}^{n}\\left [ \\left \\lfloor \\frac{A + Bi}{D} \\right \\rfloor = \\left \\lfloor \\frac{A + Ci}{D} \\right \\rfloor \\right ] i=1∑n​[⌊DA+Bi​⌋=⌊DA+Ci​⌋] 显然，当 Ci−Bi≥DC_i - B_i \\geq DCi​−Bi​≥D ，时 iii 没有意义，那么上界 n=⌊D−2C−B⌋n = \\left\\lfloor \\frac{D-2}{C-B} \\right\\rfloorn=⌊C−BD−2​⌋ ，那么此时两项之差为 000 或 111 ，所以问题转化为 n−∑i=1n(⌊A+CiD⌋−⌊A+Bi−1D⌋)n - \\sum\\limits_{i=1}^{n} \\left( \\left \\lfloor \\frac{A + Ci}{D} \\right\\rfloor -\\left \\lfloor \\frac{A + Bi-1}{D} \\right \\rfloor \\right) n−i=1∑n​(⌊DA+Ci​⌋−⌊DA+Bi−1​⌋) 可以使用类欧几里德解决 12345678910111213141516171819ll f(ll a, ll b, ll c, ll n)&#123; if (!a) return 0; if (a &gt;= c || b &gt;= c) return f(a%c, b%c, c, n) + a/c * (n+1)*n/2 + b/c * (n+1); return (a*n + b)/c*n - f(c, c-b-1, a, (a*n+b)/c-1); &#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ll A, B, C, D; scanf(&quot;%lld%lld%lld%lld&quot;, &amp;A, &amp;B, &amp;C, &amp;D); ll n = (D-2)/(C-B); ll res = (f(C, A, D, n) - f(B, A-1, D, n)); printf(&quot;%lld\\n&quot;, n - res); &#125; return 0;&#125; 9.14 T1 维护一个长度为 nnn 的数列 aia_iai​ ，共有 mmm 个操作，这些操作共有两种。 1 l r k 将区间 [l,r][l,r][l,r] 内的元素全部修改为 kkk 2 l r c 查询区间内是否存在出现次数大于 ccc 的数 保证操作 222 中，满足 c≥⌊r−l+15⌋c \\geq \\lfloor \\frac{r-l+1}{5} \\rfloorc≥⌊5r−l+1​⌋。 区间推平操作，使用珂朵莉树魔法 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#define otto auto#define MAXN 100005using namespace std;int a[MAXN];namespace Chtholly&#123; class node &#123; public: int l, r; mutable int val; node(int l, int r, int val) &#123; this -&gt; l = l; this -&gt; r = r; this -&gt; val = val; &#125; friend bool operator &lt; (node a, node b) &#123; return a.l &lt; b.l; &#125; int length() const &#123; return (r - l + 1); &#125; &#125;; int length; set &lt;node&gt; odt; void build(int N) &#123; length = N; int l = 1; for (int i = 2; i &lt;= N + 1; i++) if (a[i-1] != a[i]) &#123; odt.insert(node(l, i-1, a[i-1])); l = i; &#125; &#125; otto split(int pos) &#123; if (pos &gt; length) return odt.end(); otto it = --odt.upper_bound(node(pos, 0, 0)); if (it -&gt; l == pos) return it; int l = it -&gt; l; int r = it -&gt; r; int val = it -&gt; val; odt.erase(it); odt.insert(node(l, pos-1, val)); return odt.insert(node(pos, r, val)).first; &#125; void assign(int l, int r, int val) &#123; otto itr = split(r + 1), itl = split(l); odt.erase(itl, itr); odt.insert(node(l, r, val)); &#125; int cnt[MAXN]; bool query(int l, int r, int c) &#123; int flag = 0; otto itr = split(r + 1), itl = split(l); for (otto it = itl; it != itr; it++) &#123; cnt[it -&gt; val] += it -&gt; length(); if (cnt[it -&gt; val] &gt; c) flag = 1; &#125; for (otto it = itl; it != itr; it++) &#123; cnt[it -&gt; val] -= it -&gt; length(); &#125; return flag; &#125;&#125;using namespace Chtholly;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); build(n); int m; scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int op, l, r, val; scanf(&quot;%d%d%d%d&quot;, &amp;op, &amp;l, &amp;r, &amp;val); if (op == 1) assign(l, r, val); else &#123; if (query(l, r, val)) printf(&quot;laffey\\n&quot;); else printf(&quot;ayanami\\n&quot;); &#125; &#125; return 0;&#125; T2 P8456 给定一个 nnn 个点， mmm 条边的无向连通图。每条边标有 D 或 d。 定义无序点对 (u,v)(u, v)(u,v) 是铁的，当且仅当 u，vu，vu，v 之间存在同时出现 D 和 d 的简单路径 求一共有几个这样的点对 我们考虑什么样的点对是不满足条件的: uuu 到 vvv 的任意路径只有 D 或 d uuu 到 vvv 的每一条路径中仅有 D 或 d 对于第一种情况，我们通过在原图中去掉含有 D 或 d 的边，实际上转化率一个联通性问题，考虑圆方树 检出圆方树后我们堵死所有对应点双内含有 D 的方点，这样以后能互相到达的点双之间经过的路径一定是只有一种字母的，所以我们可以用并查集维护连通块统计 siz ，对于 D 和 d 的两种情况分别统计就行 对于第二种情况，我们 9.15 T1 签到题 T2 给定一张有向图，每个点有点权。试找到一条路径，使得该路径上的点权最大值减去点权最小值最大，问这个差最大是多少 记忆化搜索 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MAXM 500005#define INF 1145141919using namespace std;int n, m;int f[MAXN];int dis[MAXN];int mi[MAXN], mx[MAXN];int cnte = 1, head[MAXN];struct edge&#123; int to, nxt;&#125;e[MAXM];void adde(int u, int v)&#123; e[++cnte].to = v; e[cnte].nxt = head[u]; head[u] = cnte;&#125;void dfs(int u, int MX, int MI, int fa)&#123; int flag = 1; MX = max(MX, dis[u]), MI = min(MI, dis[u]); if (mx[u] &lt; MX) mx[u] = MX, flag = 0; if (mi[u] &gt; MI) mi[u] = MI, flag = 0; if (f[u] &lt; MX - MI) f[u] = max(f[fa], MX - MI), flag = 0; if (flag) return; for (int i = head[u]; i; i = e[i].nxt) &#123; dfs(e[i].to, MX, MI, u); &#125;&#125;int main()&#123; freopen(&quot;b.in&quot;, &quot;r&quot;, stdin); freopen(&quot;b.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;dis[i]); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); adde(u, v); &#125; for (int i = 1; i &lt;= n; i++) &#123; mi[i] = INF; mx[i] = -INF; &#125; for (int i = 1; i &lt;= n; i++) dfs(i, dis[i], dis[i], 0); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ans = max(ans, f[i]); &#125; printf(&quot;%d&quot;, ans); return 0;&#125; T3 有 nnn 个人，每个人都有两把刷子，每个刷子都有一个属性值。如果说一个人拿着的两把刷子的属性值之差的绝对值超过了𝑐，则这个人无法使用他的两把刷子。现在你可以选择交换不同人的某把刷子，使得每个人都能够使用他们的刷子，问最小所需要的交换次数 状压表示每个人是否匹配成功，先把不合法的状态减去，把人分成两部分，各自交换，也就是枚举子集 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#define MAXN 17#define cjb 1145141919using namespace std;int n, c;int a[MAXN][2];#define ABS(i) (i &lt; 0 ? -i : i)#define Abs(i) ABS((i))int tmp[50], cnt; int f[1 &lt;&lt; MAXN];int main()&#123; // freopen(&quot;c.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;c.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%d&quot;, &amp;n, &amp;c); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;a[i][0], &amp;a[i][1]); int tot = 0; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) &#123; cnt = 0; int flag = 1; for (int j = 1; j &lt;= n; j++) if (i &amp; (1 &lt;&lt; (j - 1))) &#123; tmp[++cnt] = a[j][0]; tmp[++cnt] = a[j][1]; &#125; sort(tmp + 1, tmp + cnt + 1); for (int j = 1; j &lt;= cnt; j += 2) if (tmp[j + 1] - tmp[j] &gt; c) &#123; flag = 0; break; &#125; if (flag) &#123; f[i] = 1; &#125; else f[i] = -0x3f3f3f3f; &#125; f[0] = 0; for (int i = 1; i &lt; (1 &lt;&lt; n); i++) &#123; for (int j = i; j; j = (j-1) &amp; i) &#123; f[i] = max(f[i], f[j] + f[i^j]); &#125; &#125; if (f[(1 &lt;&lt; n)-1] &lt; 0) printf(&quot;-1&quot;); else &#123; printf(&quot;%d&quot;, n - f[(1 &lt;&lt; n) - 1]); &#125; return 0;&#125; T4 维护序列，区间加斐波那契，区间和 考虑如何实现区间加，多次加斐波那契的结果，一定是一个类斐波那契数列，有两个重要性质 ∑F(n)=F(n+2)−F(2)\\sum F(n) = F(n+2) - F(2)∑F(n)=F(n+2)−F(2) gn=g1(n−2)+g2(n−1)g_n = g_1(n-2) + g_2(n-1)gn​=g1​(n−2)+g2​(n−1) ，ggg 表示 g1,g2g_1,g_2g1​,g2​ 两个对应项相加 我们只需要维护首项和第二项就可以根据这两个式子合并 9.16 T1 给由一个正整数 NNN，构造一个长度为 kkk 的数列 A，为从 N 开始的连续 kkk 个数按顺序拼接生成，即 A={N,N+1,N+2,....,N+k−1}A=\\{N,N+1,N+2,....,N+k-1\\}A={N,N+1,N+2,....,N+k−1} ，把数列 AAA 中的每个数都只保留一个数字，得到数列 BBB。 现在给出 KKK 和数列 BBB，请求出最小的合法的 nnn。 枚举每一位数的起点，然后每十位数合并，在接着十位十位地枚举 T2CF1119H 你的生日礼物是nnn个整数三元组。第iii个三元组是{ai,bi,ci}\\{a_i,b_i,c_i\\}{ai​,bi​,ci​},所有数字jjj都满足0≤j&lt;2k0\\le j&lt;2^k0≤j&lt;2k,kkk是一个固定的数字，将由题目输入。 一天，你玩三元组玩腻了，所以你有了3个新的整数x,y,zx,y,zx,y,z,然后填充了nnn个数组。第iii个数组有xxx个aia_iai​,yyy个bib_ibi​,zzz个cic_ici​.这样，每个数组的大小都是x+y+zx+y+zx+y+z. 你希望从每个数组里选择1个整数，使得它们的xor(按位异或)值恰好为ttt. 对于区间[0,2k−1][0,2^k-1][0,2k−1]内的每个数字ttt,输出满足上面的条件的方案数 模 998244353998244353998244353 异或考虑 FWT 统计方案想到生成函数卷积，我们把这些三元组看作一个多项式，ccc 表示异或卷积的变换系数 最后的卷积就是 ∏k=1n((−1)i&amp;akx+(−1)i&amp;bky+(−1)i&amp;ckz) \\prod_{k=1}^{n}\\left((-1)^{i \\&amp; a_{k}} x+(-1)^{i \\&amp; b_{k}} y+(-1)^{i \\&amp; c_{k}} z\\right) k=1∏n​((−1)i&amp;ak​x+(−1)i&amp;bk​y+(−1)i&amp;ck​z) cntcntcnt 表示二进制下 111 的个数 按 x,y,zx,y,zx,y,z 的系数四种情况解方程 T3CF241B 给定n个整数a1,a2...ana1,a2...ana1,a2...an,求两两异或值前k大的和。 其中n&lt;=50000,ai&lt;=109n&lt;=50000,ai&lt;=10^9n&lt;=50000,ai&lt;=109。答案对1000000007(109+7)1000000007 (10^9+7)1000000007(109+7)取模。 二分 kkk 大值 ，枚举每个数，查询疑惑和大于 midmidmid 的数量 对原数建 01Trie，预处理出树上子树上的叶子节点上二进制下每一位是 111 的数的个数。 这样就可以方便地快速计算出整棵子树异或上一个数的和。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;#define MXBT 30#define MAXN 50005#define ll long long#define inv2 500000004#define mod 1000000007using namespace std;int n; ll k;int a[MAXN];ll ans;namespace Trie&#123; int tot; int siz[MAXN * MXBT]; int kid[MAXN * MXBT][2]; int cnt[MAXN * MXBT][MXBT+1]; void insert(int x) &#123; int now = 0; for (int i = MXBT; i &gt;= 0; i--) &#123; int bit = (x &gt;&gt; i) &amp; 1; if (!kid[now][bit]) kid[now][bit] = ++tot; now = kid[now][bit]; siz[now]++; &#125; &#125;&#125;using namespace Trie;ll check(int x)&#123; ll sum = 0; for (int i = 1; i &lt;= n; i++) &#123; int now = 0; for (int j = MXBT; j &gt;= 0; j--) &#123; int u = (a[i] &gt;&gt; j) &amp; 1; int v = (x &gt;&gt; j) &amp; 1; if (!v) &#123; sum += siz[kid[now][u^1]]; now = kid[now][u]; &#125; else now = kid[now][u^1]; if (!now) break; &#125; sum += siz[now]; &#125; return sum/2;&#125;void init(int u, int d, int z)&#123; if (u == 0) return; if (d == 0) &#123; for (int i = 0; i &lt;= MXBT; i++) &#123; if ((z &gt;&gt; i) &amp; 1) cnt[u][i] = siz[u]; &#125; return ; &#125; init(kid[u][0], d-1, z); init(kid[u][1], d-1, z | (1 &lt;&lt; (d - 1))); for (int i = 0; i &lt;= MXBT; i++) cnt[u][i] = cnt[kid[u][0]][i] + cnt[kid[u][1]][i];&#125;void solve(int x)&#123; for (int i = 1; i &lt;= n; i++) &#123; int now = 0; for (int j = MXBT; j &gt;= 0; j--) &#123; int u = (a[i] &gt;&gt; j) &amp; 1; int v = (x &gt;&gt; j) &amp; 1; if (!v) &#123; int t = kid[now][u^1]; for (int k = 0; k &lt;= MXBT; k++) &#123; int w = (a[i] &gt;&gt; k) &amp; 1; if (w) ans = (ans + 1LL*(siz[t] - cnt[t][k]) * (1LL &lt;&lt; k)) %mod; else ans = (ans + 1LL*cnt[t][k] * (1LL &lt;&lt; k)) %mod; &#125; now = kid[now][u]; &#125; else now = kid[now][u^1]; if (!now) break; &#125; ans = (ans + 1LL * siz[now] * x)%mod; &#125;&#125;int main()&#123; scanf(&quot;%d%lld&quot;, &amp;n, &amp;k); if (!k) &#123; putchar(&#x27;0&#x27;); return 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); insert(a[i]); &#125; // cout &lt;&lt; tot &lt;&lt; &quot; I&#x27;,m tot\\n&quot;; init(kid[0][0], MXBT, 0); init(kid[0][1], MXBT, 1 &lt;&lt; MXBT); // for (int i = 1; i &lt;= tot; i++) // &#123; // for (int j = 0; j &lt;= 30; j++) // &#123; // printf(&quot;%d &quot;, cnt[i][j]); // &#125; // cout &lt;&lt; &#x27;\\n&#x27;; // &#125; int l = 0, r = 1 &lt;&lt; MXBT, kth; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; // cout &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; mid &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27;\\n&#x27;; if (check(mid) &gt;= k) &#123; kth = mid; l = mid+1; &#125; else r = mid-1; &#125; // printf(&quot;%d KTH\\n&quot;, kth); solve(kth); // cout &lt;&lt; ans &lt;&lt; &quot;dada\\n&quot;; ans = ans * inv2 %mod; ans = ((ans - 1LL * (check(kth) - k) * kth%mod)%mod + mod)%mod; printf(&quot;%lld&quot;, ans); return 0;&#125; 9.17 原题赛，skip 9.19 T1JOISC2013 T4 这个游戏要用到一些写有J,O,IJ,O,IJ,O,I 中任一文字的圆盘。这些圆盘的直径互不相同。游戏开始时，这些圆盘按照直径大的 在下面的规则堆叠。你需要用这些圆盘做尽量多的迷你 JOIOI 塔。迷你 JOIOI 塔由 个圆盘构成，从直径较小的圆盘开始分别为J,O,IJ,O,IJ,O,I 或分别为I,O,II,O,II,O,I 。不过，每个圆盘最多只能使用一次 现在给出长为 nnn 的字符串 sss，表示直径从小到大的圆盘上的文字。请编写程序求出使用这些圆盘能够做出的迷你 JOIOI 塔个数的最大值 倒叙扫描维护 i ,oi ,ioi, joi 的个数 如果有 o 与 i 合成 oi 如果有 i 与 ioi 合成 ioi 如果有 j 把 ioi 拆成 joi 和 i Code 12345678910111213141516for (int I = n; I; I--)&#123; if (s[I] == &#x27;J&#x27;) if (i &amp;&amp; oi) &#123; if (oi == ioi || i == ioi * 2) ioi--; oi--; i--; joi++; &#125; if (s[I] == &#x27;O&#x27;) oi = min(i, oi+1); if (s[I] == &#x27;I&#x27;) &#123; if (oi &gt; ioi &amp;&amp; i &gt; ioi * 2) ioi++; i++; &#125;&#125;printf(&quot;%d&quot;, ioi + joi); T2 nnn 个数 a1,…,ana_1, \\dots, a_na1​,…,an​，定义 f(i,j)=ai opt ajf(i,j) = a_i \\; opt \\; a_jf(i,j)=ai​optaj​， g(i)=max⁡res=1i−1f(ai,ares),i∈[2,n]g(i)=\\max _{r e s=1}^{i-1} f\\left(a_{i}, a_{r e s}\\right), i \\in[2, n] g(i)=res=1maxi−1​f(ai​,ares​),i∈[2,n] 以及 g(i)g(i)g(i) 的个数 逆天 dp ，把结果的前四位和后四位分开看 Code ggg 表示对应情况的个数123456789101112131415161718192021222324252627282930313233343536373839404142int n, TYPE;int ans, cnt;int f[MAXN][MAXN];int g[MAXN][MAXN];char op[5];int F (int x, int y)&#123; return op[1] == &#x27;a&#x27;? x&amp;y : op[1] == &#x27;o&#x27; ? x|y : x^y;&#125;int main()&#123; freopen(&quot;meltdown.in&quot;, &quot;r&quot;, stdin); freopen(&quot;meltdown.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%s%d&quot;, &amp;n, op+1, &amp;TYPE); memset(f, 0xcf, sizeof(f)); int x, y, now, mx; for (int k = 1; k &lt;= n; k++) &#123; scanf(&quot;%d&quot;, &amp;x); y = x &amp; S; x &gt;&gt;= 8; ans = -cjb; cnt = 0; for (int i = 0; i &lt;= S; i++) &#123; now = f[x][i] + F(i, y); if (now &gt; ans) &#123; ans = now; cnt = 0; &#125; if (now == ans) cnt += g[x][i]; &#125; for (int i = 0; i &lt;= S; i++) &#123; now = F(i, x) &lt;&lt; 8; if (f[i][y] &lt; now) &#123; f[i][y] = now, g[i][y] = 0; &#125; if (f[i][y] == now) g[i][y]++; &#125; if (k &gt; 1) &#123; if (TYPE) printf(&quot;%d %d\\n&quot;, ans, cnt); else printf(&quot;%d\\n&quot;, ans); &#125; &#125; return 0;&#125; T4P6965 给定 n 个01串，每个字符串至多有一位是未知的，可以填 0 或 1 ，求是否存在一种方案，使得任意一个字符串不是其它任意一个字符串的前缀 01 考虑 2-SAT ，显然的是一个字符不能与它的前缀同时出现，那么他与他的前缀连边，n2n^2n2 T掉 考虑优化建图，全是 01 还可以方便的维护前缀，考虑 01Trie Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;#include &lt;type_traits&gt;#define MAXN 3000005using namespace std;int n;string s[MAXN];vector &lt;int&gt; e[MAXN];unordered_map &lt;string, int&gt; mp;vector &lt;int&gt; q[MAXN];void adde(int u, int v)&#123; e[u].push_back(v);&#125;namespace Trie&#123; int rt, tot; int N[MAXN]; int ch[MAXN][2]; void insert(string s, int id) &#123; int now = rt; for (int i = 0; s[i]; i++) &#123; int bit = s[i] - &#x27;0&#x27;; if (!ch[now][bit]) ch[now][bit] = ++tot; now = ch[now][bit]; &#125; q[now].push_back(id); &#125;&#125;using namespace Trie;#define inv(i) ((i &gt; n ? i - n : i + n))void build(int u, int fa)&#123; if (!u) return; N[u] = ++tot; if (fa) adde(u, fa), adde(N[fa], N[u]); for (int v : q[u]) &#123; adde(v, fa); adde(u, inv(v)); adde(N[u], inv(v)); &#125; for (int v : q[fa]) adde(v, N[u]); for (int v : q[u]) for (int z : q[u]) &#123; if (v != z) adde(v, inv(z)); &#125; build(ch[u][0], u); build(ch[u][1], u);&#125;int vis[MAXN];int dfn[MAXN], low[MAXN], T;int sta[MAXN], scc[MAXN], top;int cnt;void Tarjan(int u)&#123; // cout &lt;&lt; u &lt;&lt; &#x27;\\n&#x27;; dfn[u] = low[u] = ++T; sta[++top] = u; vis[u] = 1; for (auto v : e[u]) &#123; if (!dfn[v]) &#123; Tarjan(v); low[u] = min(low[u], low[v]); &#125;else if (vis[v]) low[u] = min(low[u], dfn[v]); &#125; if (low[u] == dfn[u]) &#123; ++cnt; while(sta[top] != u) &#123; int v = sta[top--]; scc[v] = cnt; vis[v] = 0; &#125; scc[sta[top]] = cnt; vis[sta[top--]] = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; rt = tot = n &lt;&lt; 1 | 1; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s[i]; if (++mp[s[i]] &gt;= 3) &#123; printf(&quot;NO&quot;); return 0; &#125; for (int j = 0; ; j++) &#123; if (s[i][j] == &#x27;?&#x27;) &#123; s[i][j] = &#x27;0&#x27;; insert(s[i], i); s[i][j] = &#x27;1&#x27;; insert(s[i], i+n); s[i][j] = &#x27;?&#x27;; break; &#125; if (j == s[i].size() - 1) &#123; insert(s[i], i); insert(s[i], i + n); break; &#125; &#125; &#125; build(rt, 0); for (int i = 1; i &lt;= tot; i++) if (!dfn[i]) Tarjan(i); for (int i = 1; i &lt;= n; i++) &#123; if (scc[i] == scc[i + n]) &#123; printf(&quot;NO&quot;); return 0; &#125; &#125; printf(&quot;YES\\n&quot;); for (int i = 1; i &lt;= n; i++) &#123; int len = s[i].size(); for (int j = 0; j &lt; len; j++) &#123; if (s[i][j] == &#x27;?&#x27;) &#123; s[i][j] = &#x27;0&#x27; + (scc[i] &gt; scc[i + n]); cout &lt;&lt; s[i] &lt;&lt; &#x27;\\n&#x27;; break; &#125; if (j == len-1) &#123; cout &lt;&lt; s[i] &lt;&lt; &#x27;\\n&#x27;; break; &#125; &#125; &#125; return 0;&#125; 9.20 T1 对于一个序列 AAA ，上升对表示 ai&lt;ai+1a_i &lt; a_{i+1}ai​&lt;ai+1​ ，定义 XiX_iXi​ 表示序列中前 iii 个元素内的上升对的数量，定义 nb 序列为满足以下条件的序列： a1=0a_1 = 0a1​=0 ai⩽Xi−1+1a_i \\leqslant X_{i-1}+1ai​⩽Xi−1​+1 不存在 1≤i&lt;j&lt;k≤n1 \\leq i &lt; j &lt; k \\leq n1≤i&lt;j&lt;k≤n，满足 ak&lt;ai&lt;aja_k &lt; a_i &lt; a_jak​&lt;ai​&lt;aj​ 求长度为 nnn 的 nb 序列的数量 打表题 T2ARC111F 给定一个初始为 000 的长度为 nnn 的序列和一个数 MMM，有 qqq 次操作： 1 l r v: 使 al∼ara_l \\sim a_ral​∼ar​ 对 vvv 取最小值 2 l r v: 使 al∼ara_l \\sim a_ral​∼ar​ 对 vvv 取最大值 3 l r: 将 al∼ara_l\\sim a_ral​∼ar​ 的和加到 ansansans 上 0≤v&lt;m0 \\leq v &lt; m0≤v&lt;m 求所有可能的 ansansans 的和 考虑一个位置在这些操作中被修改的可能，以及可能被修改成什么值在经过复杂的推式子 T3ARC120E 数轴上有一些点，每一时刻每个点都可以向左或向右移动一个单位距离，求出最小的需要的时间 kkk ，每一个 iii 和 i+1i+1i+1 这两个点都重合过一次 对于 iii 个点，让他向右，第 i+1i+1i+1 个点向左，这样强制匹配这两个点，DP f[i]f[i]f[i] 表示强制匹配 i−1i-1i−1 和 iii Code 1234a[0]=a[1],a[n+1]=a[n];f[2]=a[2]-a[1];for(int i=3;i&lt;=n+1;i++)f[i]=min(max(f[i-2],a[i]-a[i-3]),max(f[i-3],a[i]-a[i-4])); 9.22 T1ARC135F 一个长度为 nnn 的序列 AAA ，有 kkk 次操作，每次删除序列中下标为 3i+13i + 13i+1 的所有数 求 kkk 次操作后序列中所有数的和 不难想到 111 次操作以后 ⌊3i+12⌋\\left\\lfloor\\frac{3 i+1}{2}\\right\\rfloor⌊23i+1​⌋ 就是第 iii 个位置上的数是哪个，那么我们设 f(i)=⌊3i+12⌋f(i) = \\left\\lfloor\\frac{3 i+1}{2}\\right\\rfloorf(i)=⌊23i+1​⌋ 那么 fk(i)f^k(i)fk(i) 就是 kkk 此操作后第 iii 个位置的数 我们可以求出每次操作后剩下的数，那么答案就是 ∑icntfk(i)\\sum\\limits_i^{cnt} f^k(i)i∑cnt​fk(i) 暴力递推的复杂度是 ∑kcntk×k\\sum\\limits_{}^k cnt_k\\times k∑k​cntk​×k 显然的是每次操作只会剩下 23n\\frac{2}{3}n32​n 个数，那么总时间复杂度大约是 nk(23k)nk(\\frac{2}{3}^k)nk(32​k) 的，当 kkk 大一点的时候可以通过 fk(n+xk)=fk(n)+3kf^k(n + x^k) = f^k(n) + 3^kfk(n+xk)=fk(n)+3k ，把式子展开一层就证出来了 所以我们枚举每一个位置 iii，求 fk(i+2yj)=fx(fy(i+2yj))=fx(fy(i)+3yj)f^k(i + 2^yj) = f^x(f^y(i+2^yj)) = f^x(f^y(i) + 3^yj)fk(i+2yj)=fx(fy(i+2yj))=fx(fy(i)+3yj) T2ARC127E 给 A+BA + BA+B 的序列 (x1,x2,…,xA+N)(x_1, x_2, \\dots,x_{A+N})(x1​,x2​,…,xA+N​) ，包含 AAA 个 111 和 BBB 个 222。 维护一个集合，如果 xi=1x_i = 1xi​=1 ，那么选择一个 v，1≤v≤Av，1 \\leq v \\leq Av，1≤v≤A 如果 xi=2x_i = 2xi​=2 ，那么删除集合中最大的数 求集合最后有多少种可能的状态 我们有一个结论，字典序比可能的状态小的一定能满足，所以我们求出字典序最大的集合然后从字典序比他小的状态转移 fi,j=fi,j−1+fi−1,j−1f_{i,j} = f_{i, j-1} + f_{i-1, j-1} fi,j​=fi,j−1​+fi−1,j−1​ fi,jf_{i,j}fi,j​ 表示前 iii 个元素中最大值为 jjj 有几种可能 9.23 T1 给定一个序列 aaa ，两种操作 l m r 归并 al,al+1,…,am,am+1,am+2,…,ar{a_l, a_{l+1}, \\dots, a_m}, {a_{m+1},a_{m+2},\\dots,a_{r}}al​,al+1​,…,am​,am+1​,am+2​,…,ar​ i 询问 aia_iai​ 的值 归并指的是一轮归并排序 对序列建平衡树，每次归并分裂出 l∼ml \\sim ml∼m 和 m+1∼rm+1 \\sim rm+1∼r ，每次在一颗子树中查找小于另那个一棵子树的极长前缀，平衡树维护就行 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;#include &lt;time.h&gt;#define MAXN 100005using namespace std;int n, m;int a[MAXN];namespace FHQ_Treap&#123; int rt, tot; struct tree &#123; int siz, val, key, max, ch[2]; &#125;t[MAXN]; #define ls(i) (t[i].ch[0]) #define rs(i) (t[i].ch[1]) int new_node(int k) &#123; ++tot; t[tot].siz = 1; t[tot].val = k; t[tot].max = k; t[tot].key = rand(); return tot; &#125; void push_up(int i) &#123; t[i].siz = t[ls(i)].siz + t[rs(i)].siz + 1; t[i].max = max(max(t[ls(i)].max, t[rs(i)].max), t[i].max); &#125; int build(int l, int r) &#123; if (l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; int now = new_node(a[mid]); ls(now) = build(l, mid-1); rs(now) = build(mid+1, r); push_up(now); return now; &#125; int merge(int x, int y) &#123; if (!x || !y) return x | y; if (t[x].key &lt; t[y].key) &#123; rs(x) = merge(rs(x), y); push_up(x); return x; &#125; else &#123; ls(y) = merge(x, ls(y)); push_up(y); return y; &#125; &#125; void split_val(int i, int &amp;x, int &amp;y, int val) &#123; if (!i) &#123; x = y = 0; return; &#125; if (max(t[ls(i)].max, t[i].val) &lt;= val) &#123; x = i; split_val(rs(i), rs(x), y, val); &#125; else &#123; y = i; split_val(ls(i), x, ls(y), val); &#125; push_up(i); &#125; void split_siz(int i, int &amp;x, int &amp;y, int siz) &#123; if (!i) &#123; x = y = 0; return; &#125; if (t[ls(i)].siz &lt; siz) &#123; x = i; split_siz(rs(i), rs(x), y, siz-t[ls(i)].siz-1); &#125; else &#123; y = i; split_siz(ls(i), x, ls(y), siz); &#125; push_up(i); &#125; int find(int i) &#123; while(ls(i)) i = ls(i); return t[i].val; &#125; void solve(int l, int mid, int r) &#123; int a, b, c, d, e, f; split_siz(rt, a, b, l-1); split_siz(b, b, c, mid-l+1); split_siz(c, c, d, r-mid); rt = a; while(b &amp;&amp; c) &#123; int cur1 = find(b); int cur2 = find(c); if (cur1 &gt; cur2) &#123; swap(cur1, cur2); swap(b, c); &#125; split_val(b, e, b, cur2); rt = merge(rt, e); &#125; if (c) rt = merge(rt, c); rt = merge(rt, d); &#125; int print(int x) &#123; int a, b, c; split_siz(rt, a, b, x-1); split_siz(b, b, c, 1); int ans = t[b].val; rt = merge(merge(a, b), c); return ans; &#125;&#125;using namespace FHQ_Treap;void dfs(int u)&#123; if (ls(u)) dfs(ls(u)); cout &lt;&lt; t[u].val &lt;&lt; &#x27; &#x27;; if (rs(u)) dfs(rs(u));&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); srand(time(0)); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);rt = build(1, n); // dfs(rt); cout &lt;&lt; &#x27;\\n&#x27;; for (int i = 1; i &lt;= m; i++) &#123; int op; scanf(&quot;%d&quot;, &amp;op); if (op == 1) &#123; int l, mid, r; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;mid, &amp;r); solve(l, mid, r); // dfs(rt); cout &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; int x; scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\\n&quot;, print(x)); &#125; &#125; return 0;&#125; T2ARC112E 给定一个序列 , mmm 次操作，删除一个数，并把它加到开头或结尾求所有方案总数，两种方案相同，当且仅当每次操作都选择了相同元素，移动到了相同的方向 对每个数进行的最后一次操作，才是决定这个数的位置的操作，称之为关键操作 dpi+1,l,r=dpi,l,r∗2(l+r)+dpi−1,l+1,r+dpi−1,l,r+1dp_{i+1,l,r} = dp{i,l,r} * 2(l+r) + dp{i-1,l+1,r} + dp_{i-1,l,r+1}dpi+1,l,r​=dpi,l,r∗2(l+r)+dpi−1,l+1,r+dpi−1,l,r+1​ iii 次操作， lll 次向左， rrr 次向右 实际上 lll 和 rrr 的顺序没有必要 dpi,j=dpi+1,j∗2∗j+dpi+1,j−1dp_{i, j} = dp_{i+1, j} * 2 * j + dp_{i+1, j-1}dpi,j​=dpi+1,j​∗2∗j+dpi+1,j−1​ iii 次操作，jjj 次关键操作 T3ARC120F 给定一个序列 aaa ，定义一个子序列是 nb 的，满足两个条件 : 长度为 kkk 没有原序列中连续的两个元素在序列中 求所有 nb 序列的和 首先一个序列 不相邻选 kkk 个的方案 Cn−k+1kC_{n-k+1}^kCn−k+1k​, 记为 CCC 考虑求出每一个数会在多少种方案中出现，记为 cntcntcnt 如果是一个环，那么 cnt=C×kncnt = \\frac{C \\times k}{n}cnt=nC×k​ ，而是一个序列，只是多了 a1a_1a1​ 和 ana_nan​ 都选的情况 9.26 T1 猎魔人杰洛特来到了牛堡。牛堡可以被视为一个二维平面，而牛堡的街道可以被视为一条条直线。堡共有 nnn 条南北向街道，其中第 iii 条为直线 x=aix = a_ix=ai​ ，另外还有 mmm 条东西向街道，其中第 iii 条为直线 y=biy= biy=bi 。沿着第 iii 条南北向街道行进 111 单位距离需要 tit_iti​ 的时间，而沿着任意一条东西向街道行进 111 单位距离均需要 t0t_0t0​ 的时间。他希望你帮忙计算从城市入口 (0,0)(0,0)(0,0) 出发到达各个十字路口的最短时间。具体来说，令 f(ai,bj)f(ai,bj)f(ai,bj) 表示从 (0,0)(0,0)(0,0) 出发，沿着街道行进并到达十字路口 (ai,bj)(ai,bj)(ai,bj) 所需的最短时间，杰洛特请你对于所有 1≤i≤n1 \\leq i \\leq n1≤i≤n 分别计算下式的值 横向的道路费用是完全相同的。 第一种情况是可以 O(1)O(1)O(1) 求的，发现横着走一样，那么有区别的就是竖着走的路程和横着多走出来的 以横着走到路程为 xxx ，那么竖着的花费是一个常数，横着的花费是系数。可以构造出一个一次函数，斜率优化维护上凸壳 T2 给一个长为 nnn 的序列和模数，333 中操作，区间乘，单点除，查询区间和 区间乘很简单，难的是单点除，模数不一定是质数，所以不一定有逆元 把模数分解，维护每个数和模数的公共质因数，先把这些因数除了，剩下的就是和模数互质的，可以有逆元 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;bits/stdc++.h&gt;#include &lt;string&gt;#define ll long long#define MAXN 500005#define mul(x, y) ((x) = ((x) * (y))%mod)int n, m;ll mod, a[MAXN];ll prime[MAXN], mp[MAXN];int cntp;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if (b == 0) &#123; x = 1; y = 0; return; &#125; exgcd(b, a%b, y, x); y -= a / b * x;&#125;ll inv(ll val)&#123; ll a, b; exgcd(val, mod, a, b); return (a %mod + mod) %mod;&#125;ll ksm (ll a, ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a %mod; a = a * a %mod; b &gt;&gt;= 1; &#125; return ans;&#125;namespace Leitree&#123; int cnt[MAXN &lt;&lt; 2][20]; struct tree &#123; int l, r; ll d; ll sum, lz; &#125;t[MAXN &lt;&lt; 2]; #define ls(i) (i &lt;&lt; 1) #define rs(i) (i &lt;&lt; 1 | 1) void push_up(int i) &#123; t[i].sum = (t[ls(i)].sum + t[rs(i)].sum) %mod; &#125; void push_down(int i) &#123; mul(t[ls(i)].sum, t[i].lz); mul(t[ls(i)].lz, t[i].lz); mul(t[ls(i)].d, t[i].d); mul(t[rs(i)].sum, t[i].lz); mul(t[rs(i)].lz, t[i].lz); mul(t[rs(i)].d, t[i].d); t[i].d = t[i].lz = 1; for (int j = 1; j &lt;= cntp; j++) &#123; cnt[ls(i)][j] += cnt[i][j]; cnt[rs(i)][j] += cnt[i][j]; cnt[i][j] = 0; &#125; &#125; void build(int i, int l, int r) &#123; t[i].l = l; t[i].r = r; t[i].lz = 1; t[i].d = 1; if (l == r) &#123; t[i].sum = a[l]; ll x = a[l]; for (int j = 1; j &lt;= cntp; j++) &#123; while(x % prime[j] == 0) &#123; cnt[i][j]++; x /= prime[j]; &#125; &#125; t[i].d = x; return ; &#125; int mid = (l + r) &gt;&gt; 1; build(ls(i), l, mid); build(rs(i), mid+1, r); push_up(i); &#125; void add(int i, int l, int r, ll val) &#123; if (t[i].l &gt;= l &amp;&amp; t[i].r &lt;= r) &#123; mul(t[i].sum, val); mul(t[i].lz, val); for (int j = 1; j &lt;= cntp; j++) &#123; while (val % prime[j] == 0) &#123; cnt[i][j]++; val /= prime[j]; &#125; &#125; mul(t[i].d, val); return; &#125; push_down(i); if (t[ls(i)].r &gt;= l) add(ls(i), l, r, val); if (t[rs(i)].l &lt;= r) add(rs(i), l, r, val); push_up(i); &#125; void change(int i, int pos, ll val) &#123; if (t[i].l == pos &amp;&amp; t[i].r == pos) &#123; for (int j = 1; j &lt;= cntp; j++) while (val % prime[j] == 0) &#123; cnt[i][j]--; val /= prime[j]; &#125; mul(t[i].d, inv(val)); t[i].sum = t[i].d; for (int j = 1; j &lt;= cntp; j++) if (cnt[i][j]) &#123; mul(t[i].sum, ksm(prime[j], cnt[i][j])); &#125; return; &#125; push_down(i); int mid = (t[i].l + t[i].r) &gt;&gt; 1; if (pos &lt;= mid) change(ls(i), pos, val); else change(rs(i), pos, val); push_up(i); &#125; ll query(int i, int l, int r) &#123; if (t[i].l &gt;= l &amp;&amp; t[i].r &lt;= r) return t[i].sum %mod; push_down(i); ll ans = 0; if (t[ls(i)].r &gt;= l) ans = (ans + query(ls(i), l, r)) %mod; if (t[rs(i)].l &lt;= r) ans = (ans + query(rs(i), l ,r)) %mod; push_up(i); return ans; &#125; #undef ls #undef rs&#125;using namespace Leitree;void devide(ll x)&#123; for (ll p = 2; p * p&lt;= x; p++) &#123; if (x % p == 0) &#123; prime[++cntp] = p; &#125; while (x % p == 0) x /= p; &#125; if (x != 1) &#123; prime[++cntp] = x; &#125;&#125;int main()&#123; read(n, mod); for (int i = 1; i &lt;= n; i++) read(a[i]); devide(mod); build(1, 1, n); read(m); for (int i = 1; i &lt;= m; i++) &#123; int op; read(op); if (op == 1) &#123; int l, r; ll val; read(l, r, val); add(1, l, r, val); &#125; if (op == 2) &#123; int pos; ll val; read(pos, val); if (val == 1) continue; change(1, pos, val); &#125; if (op == 3) &#123; int l, r; read(l, r); printf(&quot;%d\\n&quot;, query(1, l, r) ); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"https://ve1bae.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"贪心","slug":"贪心","permalink":"https://ve1bae.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"https://ve1bae.github.io/tags/dsu-on-tree/"},{"name":"数学，数论","slug":"数学，数论","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"}]},{"title":"虚树","slug":"虚树","date":"2022-08-17T14:05:51.000Z","updated":"2022-11-08T10:40:10.226Z","comments":true,"path":"2022/08/17/虚树/","link":"","permalink":"https://ve1bae.github.io/2022/08/17/%E8%99%9A%E6%A0%91/","excerpt":"Virtual Tree","text":"Virtual Tree 虚 🌳 P2495 大概的意思时有一棵 nnn 个节点的树， mmm 次询问，断一条边需要花费相应的费用，每次询问 kkk 个点使一号节点和它们不连通最少的代价，断的边不会继承到下一次询问。 n⩽2.5×105, m⩽5×105,∑k⩽5×105n \\leqslant 2.5 \\times 10^5,\\ m \\leqslant 5 \\times 10^5, \\sum k \\leqslant 5 \\times 10^5n⩽2.5×105, m⩽5×105,∑k⩽5×105 首先我们可以树形dp，f[i]f[i]f[i] 表示切断以 iii 为根的子树中所有询问点的代价，c[i]c[i]c[i] 表示 uuu 到1号节点路径上边权的最小值。 当点 uuu 本身是询问点时， f[u]=c[u]f[u] = c[u]f[u]=c[u] ，否则f[u]=min(c[u],∑f[v]),v∈son(u)f[u] = min(c[u], \\sum f[v]),v \\in son(u)f[u]=min(c[u],∑f[v]),v∈son(u) 最后答案为 f[1]f[1]f[1] ，时间复杂度 O(nm)O(nm)O(nm) ，肯定过不去，但是我们发现有些点根本没必要跑 比如说子树内一个询问点都没有的节点，所以考虑优化这棵树。 建虚树 首先每次询问点时必须要保留的，而又要不改变节点的辈分关系，还要让节点数尽量少 所以我们把询问点和它们两两之间的 LCA 保留，但是我们也不能 k2k^2k2 枚举询问点的LCA 所以用单调栈的思想，维护树上的一条链，DFS 序单调递增 先预处理 dfsdfsdfs 序，然后将询问点按 dfsdfsdfs 序排序，开始先将第一个点加入栈中 uuu 表示当前要加入的点， lcalcalca 表示 uuu 与栈顶的 lcalcalca 分为两种情况 栈顶就是 lcalcalca ，说明栈顶与 uuu 在一条链上，直接把 uuu j加入栈 栈顶不是 lcalcalca ，弹出栈顶直到 uuu 与栈顶在一条链上，也就是说跳到 dfn 序大于栈顶 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;#define ll long long#define cjb 1145141919810#define MAXN 250005#define V Vshojousing namespace std;int n, m, k;int a[MAXN];int vis[MAXN];#define pir pair &lt;int, ll&gt;#define dis second#define to firstvector &lt;pir&gt; e[MAXN];vector &lt;int&gt; Vshojo[MAXN];ll c[MAXN];int T;int fa[MAXN], siz[MAXN], dep[MAXN];int son[MAXN], top[MAXN], dfn[MAXN];void dfs1(int u, int dad)&#123; dfn[u] = ++T; siz[u] = 1; fa[u] = dad; dep[u] = dep[dad] + 1; for(pir y : e[u]) &#123; int v = y.to; if(v == dad) continue; c[v] = min(c[u], y.dis); dfs1(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if(son[u]) dfs2(son[u], tup); for(pir y : e[u]) &#123; int v = y.to; if(v == fa[u] || v == son[u]) continue; dfs2(v, v); &#125;&#125;int LCA(int u, int v)&#123; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt;= dep[top[v]]) u = fa[top[u]]; else v = fa[top[v]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;bool cmp(int a, int b)&#123; return dfn[a] &lt; dfn[b];&#125;void build()&#123; int sta[MAXN], top = 0; sort(a + 1, a + 1 + k, cmp); sta[++top] = 1; for(int i = 1; i &lt;= k; i++) &#123; int lca = LCA(a[i], sta[top]); if(lca != sta[top]) &#123; while(dfn[lca] &lt; dfn[sta[top-1]]) &#123; V[sta[top]].push_back(sta[top-1]); V[sta[top-1]].push_back(sta[top]); top--; &#125; V[lca].push_back(sta[top]); V[sta[top]].push_back(lca); if(dfn[sta[top-1]] != dfn[lca]) sta[top] = lca; else top--; &#125; sta[++top] = a[i]; &#125; for(int i = 1; i &lt; top; i++) &#123; V[sta[i]].push_back(sta[i+1]); V[sta[i+1]].push_back(sta[i]); &#125;&#125;ll dp(int u, int fa)&#123; ll ans = 0; for(int v : V[u]) &#123; if(v == fa) continue; ll s = dp(v, u); if(vis[v]) ans += c[v], vis[v] = 0; else ans += min(c[v], s); &#125; V[u].clear(); return ans;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++) &#123; int u, v; ll w; scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w); e[u].push_back(make_pair(v, w)); e[v].push_back(make_pair(u, w)); &#125; c[1] = cjb; dfs1(1, 0); dfs2(1, 1); scanf(&quot;%d&quot;, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d&quot;, &amp;k); for(int j = 1; j &lt;= k; j++) scanf(&quot;%d&quot;, &amp;a[j]), vis[a[j]] = 1; build(); printf(&quot;%lld\\n&quot;,dp(1, 0)); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ve1bae.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"虚树","slug":"虚树","permalink":"https://ve1bae.github.io/tags/%E8%99%9A%E6%A0%91/"}]},{"title":"点分治","slug":"点分治","date":"2022-08-17T13:37:29.000Z","updated":"2022-11-08T07:42:45.290Z","comments":true,"path":"2022/08/17/点分治/","link":"","permalink":"https://ve1bae.github.io/2022/08/17/%E7%82%B9%E5%88%86%E6%B2%BB/","excerpt":"淀粉质","text":"淀粉质 点分治 可以处理一些有关树上路径的问题，先看题 8️⃣ P3806 首先对于一个点 uuu 和它的子树中任意一个点 vvv ， dis(v)dis(v)dis(v) 表示 vvv 到 uuu 的路径权值和 考虑开一个桶 u[k]u[k]u[k] 记录是否存在 dis(v)=kdis(v) = kdis(v)=k 那么不在同一个子树的两个点的贡献就好算了 对于一个存在的 u[w],w&lt;=ku[w],w &lt;= ku[w],w&lt;=k 如果存在 u[k−w]u[k-w]u[k−w] 那么就存在这样一个点对 对于在同一个子树内点的贡献，我们把 uuu 删去,把树拆开递归到这些子树中下去求解 肯定是拆成的子树大小越均衡越好，所以每次节点 uuu 的选取要讲究一点 每次选取当前树的重心作为 uuu ，总时间复杂度 O(nlogn)O(nlogn)O(nlogn) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;#define MAXN 10005#define MAXK 10000005#define ll long long#define cjb 1145141919using namespace std;namespace F_star&#123; int cnte = 0, head[MAXN]; struct edge &#123; int to, nxt; ll dis; &#125;e[MAXN &lt;&lt; 1]; void adde(int u, int v, ll w) &#123; e[++cnte].to = v; e[cnte].dis = w; e[cnte].nxt = head[u]; head[u] = cnte; &#125;&#125;using namespace F_star;struct query&#123; int k, ans;&#125;que[105];int n,m;int siz[MAXN];int root, sixz, sum;ll dis[MAXN];bool vis[MAXN];bool t[MAXK+5];void get_zx(int u) //找重心&#123; int msiz = 0; // 不能定义成全局变量 siz[u] = 1; vis[u] = true; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(vis[v]) continue; get_zx(v); siz[u] += siz[v]; msiz = max(msiz, siz[v]); &#125; msiz = max(msiz, sum - siz[u]); if(msiz &lt; sixz) &#123;sixz = msiz; root = u;&#125; vis[u] = false;&#125;ll sta1[MAXN], top1;ll sta2[MAXN], top2;int debug;void get_dis(int u) //处理子树内个节点到当前根的路径权值&#123; if(dis[u] &gt; MAXK) return; vis[u] = true; sta1[++top1] = dis[u]; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(vis[v]) continue; dis[v] = dis[u] + e[i].dis; get_dis(v); &#125; vis[u] = false;&#125;void get_ans(int u) //统计答案&#123; t[0] = 1; top2 = 0; vis[u] = true; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(vis[v]) continue; top1 = 0; dis[v] = e[i].dis; get_dis(v); for(int j = 1; j &lt;= top1; j++) &#123; for(int k = 1; k &lt;= m; k++) //分别统计每个询问 &#123; if(sta1[j] &lt;= que[k].k) que[k].ans |= t[que[k].k - sta1[j]]; &#125; &#125;//先统计在加入贡献，保证统计的是不同子树的两点的贡献 for(int j = 1; j &lt;= top1; j++) sta2[++top2] = sta1[j], t[sta1[j]] = 1; //加入子树贡献 &#125; for(int i = 1; i &lt;= top2; i++) //清楚贡献 t[sta2[i]] = 0; vis[u] = false;&#125;void solve(int u) //分治函数&#123; get_ans(u); vis[u] = true; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(vis[v]) continue; sum = siz[v]; sixz = cjb; get_zx(v); solve(root); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n, &amp;m); for(int i = 1; i &lt; n; i++) &#123; int u, v, w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); adde(u, v, w); adde(v, u, w); &#125; for(int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;,&amp;que[i].k); sum = n; sixz = cjb; get_zx(1); solve(root); for(int i = 1; i &lt;= m; i++) printf(que[i].ans ? &quot;AYE\\n&quot; : &quot;NAY\\n&quot;); return 0;&#125; P4178 Tree 经典题给定一个 nnn 个节点的树，求树上两点距离小于等于 kkk 的点对数量 和板子题相比，询问从是否存在变为了查询点对数量，而且不再等于而是小于等于 小于等于的话，我们对桶求一个前缀和，就可以做到 O(1)O(1)O(1) 查询 发现加贡献实际上是单点修改，查询是区间查询，使用数据结构维护桶即可。 时间复杂度 O(nlog2n)O(nlog^2n)O(nlog2n) 推荐使用树状数组 P2634 国家集训队 聪聪可可 给定一个 nnn 个节点的树，求树上两点距离的是 333 的倍数的点对数量 处理权值是 % 3\\% \\ 3% 3 ，正常维护即可","categories":[],"tags":[{"name":"点分治","slug":"点分治","permalink":"https://ve1bae.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"}]},{"title":"树的同构","slug":"树的同构","date":"2022-08-17T13:29:48.000Z","updated":"2022-11-08T10:40:03.519Z","comments":true,"path":"2022/08/17/树的同构/","link":"","permalink":"https://ve1bae.github.io/2022/08/17/%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/","excerpt":"某不知名的 AHU 算法 和 树哈希","text":"某不知名的 AHU 算法 和 树哈希 树同构问题 定义 有根树同构 对于两颗有根树 T1(V1,E1,r1)T_1(V_1,E_1,r_1)T1​(V1​,E1​,r1​) 和 T2(V2,E2,r2)T_2(V_2,E_2,r_2)T2​(V2​,E2​,r2​) 存在一个双射 φ:V1→V2\\varphi: V_1 \\rightarrow V_2φ:V1​→V2​ ，使得 ∀u,v∈V1,(u,v)∈E1 ⟺ (φ(u),φ(v))∈E2\\forall u,v \\in V_1,(u,v) \\in E_1 \\iff (\\varphi(u),\\varphi(v)) \\in E_2 ∀u,v∈V1​,(u,v)∈E1​⟺(φ(u),φ(v))∈E2​ 且 φ(r1)=r2\\varphi(r_1) = r_2φ(r1​)=r2​ 成立，那么称有根树 T1T_1T1​ 和 T2T_2T2​ 同构。 无根树同构 对于两颗无根树 T1(V1,E1)T_1(V_1,E_1)T1​(V1​,E1​) 和 T2(V2,E2)T_2(V_2,E_2)T2​(V2​,E2​) 存在一个双射 φ:V1→V2\\varphi: V_1 \\rightarrow V_2φ:V1​→V2​ ，使得 ∀u,v∈V1,(u,v)∈E1 ⟺ (φ(u),φ(v))∈E2\\forall u,v \\in V_1,(u,v) \\in E_1 \\iff (\\varphi(u),\\varphi(v)) \\in E_2 ∀u,v∈V1​,(u,v)∈E1​⟺(φ(u),φ(v))∈E2​ 那么称有根树 T1T_1T1​ 和 T2T_2T2​ 同构。 映射指两个元素的集之间元素相互对映的关系 设 fff 是从集合 AAA 到集合 bbb 的映射，若 f(A)=Bf(A) = Bf(A)=B ，即 BBB 中任一元素 bbb 都是 AAA 中某元素的像，则称 fff 为 AAA 到 BBB 上的满射； 若对 AAA 中任意两个不同元素 a1≠a2a_1 \\ne a_2a1​=a2​，它们的像 f1≠f2f_1 \\ne f_2f1​=f2​，则称 fff 为 AAA 到 BBB 的单射； 若映射 fff 既是单射，又是满射，那么称 fff 为 AAA 到 BBB 的双射 我看不懂 😅😅😅 但是无关紧要 如果把 T1T_1T1​ 上的节点重新标号使得 T1T_1T1​ 与 T2T_2T2​ 完全相同，那么两树同构 还有就是有根树同构，无根树同构 有根树同构显然更简单，考虑无根树转换成有根树同构，没有根我们就整一个根 看到从树上取出一个点来，考虑找树的重心 我们知道一棵树可能有一个或两个重心，所以分为这几种情况 两棵树重心数量不同，那么不同构 重心数量都为 1️⃣ 那么两棵树分别以它们的重心为根的有根树同构的话，这两颗树就构 否则不同构 中心数量都为 2️⃣ 那么两棵树分别以他们的重心为有根树中，有一对同构的话，这两棵 树就同构（或的关系），否则不同构 AHU算法 前置：括号序 把一棵树用括号表示，每棵子树用一对括号括起来 这颗树的括号序就是( () (()) () ()) 标上号就是(1 (0) (4(5)) (8) (9)) 所以一颗有根树存在一个唯一的括号序，而且这个括号序可以看成由他的字数的括号序拼接而来的，所以我们改变一下子树拼接的顺序，得到的新括号序对应的树与原树同构 递归求括号序时，把子树的括号序排个序再拼接，比较这样得到的括号序就行了 O(nlogn)O(nlogn)O(nlogn) 用这种方式需要比较两个字符串，而且当树是一条链时字符串会很长，最坏时间复杂度 O(n2)O(n^2)O(n2) 考虑把括号序换成数值，对于一个节点，它的括号序只与他的儿子节点，也就是它的深度+1的节点有关，所以可以把树分层，然后用节点在它所在的层的排名代替括号，这样之后，每个节点的括号序变成了一个大小是节点字数大小的数组，对数组进行比较就行辣 算法流程 找重心，重心数量不同 return false DFS处理出节点深度，把深度相同的节点放到一个数组中 从小到大枚举深度，合并儿子括号序，排序，处理当前括号序 123456789101112131415161718192021222324252627282930313233void AHU()&#123; for(int i = n-1; i &gt;= 0; i--) &#123; for(int j = 0; j &lt; lv[i].size(); j++) &#123; int v = lv[i+1][j]; f[fa[v]].push_back(dis[v]); &#125; sort(lv[i].begin(), lv[i].end(), cmp); int cnt = 0; for(int j = 0; j &lt; lv[i].size(); j++) &#123; if(g[lv[i][j]] != g[lv[i][j - 1]]) cnt++; dis[lv[i][j]] = cnt; &#125; &#125;&#125; //建边，找重心,预处理深度和父亲 if(rt1.size() != rt2.size()) &#123;printf(&quot;NO&quot;); return 0;&#125; fa[rt1[0]] = 0; fa[rt2[0]] = 0; dfs(rt1[0]); dfs(rt2[0]); AHU(); if(g[rt1[0]] == g[rt2[0]]) &#123;printf(&quot;YES&quot;); return 0;&#125; if(rt2.size() == 1) &#123;printf(&quot;NO&quot;); retuen 0;&#125; fa[rt[2]] = 0; dfs(rt2[1]); AHU(); printf(g[rt1[0]] == g[rt2[0]] ? &quot;YES&quot; : &quot;NO&quot;); 树哈希 把树映射成一个哈希值，主要有三种方法 方法一 fu=sizeu×∑fson(u,i)×seedi−1f_u = size_u \\times \\sum f_{son(u,i)} \\times seed^{i-1} fu​=sizeu​×∑fson(u,i)​×seedi−1 fuf_ufu​ 表示 uuu 为根的子树的 hash 值 sizesizesize 是以 uuu 为根的子树大小 son(u,i)son(u,i)son(u,i) 表示 uuu 的儿子们按 fff 排序后第 iii 个儿子 seedseedseed 是一个大质数 方法二 fu=⨁fson(u,i)×seed+sizeson(u,i)f_{u}=\\bigoplus f_{son(u,i)}\\times seed+size_{son(u,i)} fu​=⨁fson(u,i)​×seed+sizeson(u,i)​ son(u,i)son(u,i)son(u,i) 表示儿子节点（不排序） ⨁\\bigoplus⨁ 疑惑和 因为是异或，当存在多棵本质相同的子树时，这种子树出现次数1，3，5…时无法区分 方法三 fu=1+∑fson(u,i)×prime(sizeson(u,i))f_{u}=1+\\sum f_{son(u,i)} \\times prime(size_{son(u,i)}) fu​=1+∑fson(u,i)​×prime(sizeson(u,i)​) prime(i)prime(i)prime(i) 第 iii 个质数 使用这种方法需要先判定一下子树大小 我们求出的是子树的 hash 值，也就是说当选取的根对劲时两棵树才会判为同构 一种方法是暴力枚举以每个节点为根时的 hash 另一种方法是找重心，以重心为根进行 hash 平常使用也可以找重心来减少冲突 比如树是一条链，计算 hash 值时发现乘以 seedseedseed 的次数会很少","categories":[],"tags":[{"name":"树同构","slug":"树同构","permalink":"https://ve1bae.github.io/tags/%E6%A0%91%E5%90%8C%E6%9E%84/"}]},{"title":"Dsu on tree","slug":"Dsu-on-tree","date":"2022-08-17T10:46:59.000Z","updated":"2022-11-08T10:40:14.667Z","comments":true,"path":"2022/08/17/Dsu-on-tree/","link":"","permalink":"https://ve1bae.github.io/2022/08/17/Dsu-on-tree/","excerpt":"树上莫队（迫真","text":"树上莫队（迫真 树上启发式合并 dsu on 🌳 一般用来处理一些带有如下特征的树上问题 不带修 对于子树的询问 考虑 O(n2)O(n^2)O(n2) 暴力，遍历节点子树统计答案，然后清除子树的贡献防止对它的兄弟造成影响 我们发现有一棵子树的贡献可以不清空，直接递归加到当前节点的贡献里 显然是不清空的子树越大越好，所以考虑重链剖分，保留节点重儿子所在的子树 算法流程： 预处理出每个节点的重儿子 递归统计轻儿子答案，清除 统计重儿子的答案，不清除贡献 最后统计当前节点的答案，因为清楚了轻儿子的贡献，要再加回来 dsu on tree 就是版子，统计和清除贡献需要灵活运用 CF375D 给定一棵 nnn 个节点的树，根节点为 111。每个节点上有一个颜色 cic_ici​。mmm 次操作。每次询问在以 uuu 为根的子树中，出现次数 ≥k\\ge k≥k 的颜色有多少种 纯纯滴板子，维护两个桶 cnt[i] 表示颜色 i 的出现次数 cntt[i] 表示出现次数大于等于 i 的颜色有多少个 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int n, m, c[MAXN];int siz[MAXN], son[MAXN];int cnt[MAXN], cntt[MAXN];int ans[MAXN], Ans;namespace F_star&#123; int cnte = 0, head[MAXN]; struct edge &#123; int to, nxt; &#125;e[MAXN &lt;&lt; 1]; void adde(int u, int v) &#123; e[++cnte].to = v; e[cnte].nxt = head[u]; head[u] = cnte; &#125;&#125;using namespace F_star;struct query&#123; int id, val;&#125;;vector &lt;query&gt; v[MAXN];void dfs(int u, int fa)&#123; siz[u] = 1; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; dfs(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;//加单点贡献，删单点贡献void add(int u)&#123; cnt[c[u]]++; cntt[cnt[c[u]]]++;&#125;void del(int u)&#123; cntt[cnt[c[u]]]--; cnt[c[u]]--;&#125;//加子树贡献，删子树贡献void adds(int u, int fa)&#123; add(u); for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; adds(v, u); &#125;&#125;void clannad(int u, int fa)&#123; del(u); for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; clannad(v, u); &#125;&#125;void dsu(int u, int fa)&#123; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa || v == son[u]) continue; dsu(v, u); clannad(v, u); //递归统计轻儿子答案，并清除贡献 &#125; if(son[u]) dsu(son[u], u); //统计重儿子答案 for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa || v == son[u]) continue; adds(v, u); // 把轻儿子贡献加进来 &#125; add(u); //加入当前节点 for(int i = 0; i &lt; v[u].size(); i++) ans[v[u][i].id] = cntt[v[u][i].val];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;,&amp;c[i]); for(int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); adde(u, v); adde(v, u); &#125; for(int i = 1; i &lt;= m; i++) &#123; int u, k; scanf(&quot;%d%d&quot;,&amp;u,&amp;k); v[u].push_back(query&#123;i, k&#125;); &#125; dfs(1, 0); dsu(1, 0); for(int i = 1; i &lt;= m; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; CF600E 给定一棵 nnn 个节点的树，根节点为 111。每个节点上有一个颜色 cic_ici​。询问子树内出现次数最多的颜色的编号和 稍微不是那么板，但还是该咋办咋办，用一个栈维护出现了哪些颜色，动态维护最大值即可 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define MAXN 100005#define ll long longusing namespace std;int n;int c[MAXN], cnt[MAXN], maxt;ll ans[MAXN], Ans;namespace F_star&#123; int cnte = 0, head[MAXN]; struct edge &#123; int to, nxt; &#125;e[MAXN &lt;&lt; 1]; void adde(int u, int v) &#123; e[++cnte].to = v; e[cnte].nxt = head[u]; head[u] = cnte; &#125; &#125;using namespace F_star;int siz[MAXN], son[MAXN];void dfs(int u, int fa)&#123; siz[u] = 1; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; dfs(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;int sta[MAXN], top;//清空贡献void clannad()&#123; while(top) cnt[sta[top--]] = 0; maxt = Ans = 0;&#125;void add(int u)&#123; ++cnt[c[u]]; sta[++top] = c[u]; //加入贡献并处理答案 if(cnt[c[u]] &gt; maxt) &#123; maxt = cnt[c[u]]; Ans = c[u]; &#125; else if(cnt[c[u]] == maxt) Ans += c[u]; &#125;void adds(int u, int fa)&#123; add(u); for(int i = head[u]; i; i = e[i].nxt) &#123; if(e[i].to != fa) adds(e[i].to, u); &#125;&#125;void dsu(int u, int fa)&#123; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == son[u] || v == fa) continue; dsu(v, u); clannad(); &#125; if(son[u]) dsu(son[u], u); for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == son[u] || v == fa) continue; adds(v, u); &#125; add(u); ans[u] = Ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;,&amp;c[i]); for(int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); adde(u, v); adde(v, u); &#125; dfs(1, 0); dsu(1, 0); for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;,ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"https://ve1bae.github.io/tags/dsu-on-tree/"}]},{"title":"树基础","slug":"树基础","date":"2022-08-17T10:45:00.000Z","updated":"2022-11-08T10:40:05.930Z","comments":true,"path":"2022/08/17/树基础/","link":"","permalink":"https://ve1bae.github.io/2022/08/17/%E6%A0%91%E5%9F%BA%E7%A1%80/","excerpt":"🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳","text":"🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳🌳 🌳相关 定义 森林，父亲，祖先，深度，二叉树，满二叉树 遍历 先序遍历 根 →\\rightarrow→ 左 →\\rightarrow→ 右 123456void prebl(int now)&#123; printf(&quot;%d &quot;,now) prebl(ls(now)); prebl(rs(now));&#125; 中序遍历 左 →\\rightarrow→ 根 →\\rightarrow→ 右 123456void midbl(int now)&#123; printf(&quot;%d &quot;,now) midbl(ls(now)); midbl(rs(now));&#125; 后序遍历 左 →\\rightarrow→ 右 →\\rightarrow→ 根 123456void nxtbl(int now)&#123; nxtbl(ls(now)); nxtbl(rs(now)); printf(&quot;%d &quot;,now)&#125; 树的直径 树上任意两个点之间最长的简单路径 两次DFS 先从任意一个节点 uuu 出发，找到距离它最远的 vvv 再找到距离 vvv 最远的 zzz ，那么 (u,z)(u, z)(u,z) 就是树的一条直径 证明 当存在负边权时，第一次dfs找到的 vvv 不一定是直径的端点，所以这个方法不能处理负边 123456789101112131415161718void dfs(int u, int fa)&#123; for(int i = head[u]; i; i = e[i].nxt) &#123; int x = e[i].to; if(x == fa) continue; dis[x] = dis[u] + e[i].dis; if(dis[x] &gt; dis[v]) v = x; dfs(x, u); &#125;&#125;int main()&#123; dfs(u, 0); dis[v] = 0; dfs(v, 0); printf(&quot;%d&quot;, dis[v]);&#125; 树形DP 1234567891011121314151617int d1[MAXN], d2[MAXN], d;void dfs(int u, int fa)&#123; d1[u] = d2[u] = 0; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; dfs(v, u); if(d1[v] + e[i].dis &gt; d1[u]) &#123; d2[u] = d1[u]; d1[u] = d1[v] + e[i].dis; &#125;else if(d1[v] + e[i].dis &gt; d2[u]) d2[u] = d1[v] + e[i].dis; &#125; d = max(d, d1[u] + d2[u]);&#125; 时间复杂度都是 O(n)O(n)O(n) P3629 k = 1时，只要把直径的两个端点连起来就行 ans=(n−1)∗2−(d−1ans = (n-1)*2 - (d-1ans=(n−1)∗2−(d−1) 加一条边就会形成一个环，我们考虑第二条边形成的环与第一条边有没有重叠的部分 如果没有的话，直接加上就行，如果有的话，重叠部分就需要多走一次 如果我们第一次跑直径时，未来会重叠的边跑了一次，但是需要多跑一次 所以我们可以在第二次跑直径时，把重叠的边的权值设成 -1 ans=(n−1)∗2−(d1−1)−(d2−1)=n∗2−d1−d2ans = (n - 1)*2 - (d_1-1) - (d_2 -1) = n*2 - d_1 - d_2ans=(n−1)∗2−(d1​−1)−(d2​−1)=n∗2−d1​−d2​ 树的重心 当以树上一点为根时，他的所有子树的结点数的最大值最小，那么这个点就是树的重心 也就是说重心把树相对平均的分为了几个部分 性质 一棵树最多有两个重心，如果有两个，这两个重心是相邻的 从重心到所有点的距离和是最小的 新加一个节点或删去一个节点，重心最多移动一条边 两棵树合并，新的重心在原来俩个重心的连线上 不会证，感性理解 我们选一个点为根dfs，记录每个节点下方的子树大小和点上方的子树大小 1234567891011121314151617181920int zx, sizx = 1145141919;int siz[MAXN], msiz[MAXN];//siz[u] u下方子树大小，msiz[u]u最大的子树大小void dfs(int u, int fa)&#123; siz[u] = 1; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; dfs(v, u); siz[u] += siz[v]; msiz[u] = max(msiz[u], siz[v]); &#125; msiz[u] = max(msiz[u], n - siz[u]); if(msiz[u] &lt; sizx) sizx = msiz[u];&#125;for(int i = 1; i &lt;= n; i++)&#123; if(msiz[i] == sizx) rt[++cnt] = i;&#125; 🌳 上问题 最近公共祖先LCA 倍增 12345678910111213141516171819void dfs(int u, int dad)&#123; dep[u] = dep[dad] + 1; fa[u][0] = dad; for(int i = 1; i &lt;= l2g[dep[u]]; i++) fa[u][i] = fa[fa[u][i-1]][i-1]; for(int i = head[u]; i; i = e[i].nxt) if(e[i].to != dad) dfs(e[i].to, u);&#125;int lca(int x, int y)&#123; if(dep[x] &lt; dep[y]) swap(x, y); while(dep[x] &gt; dep[y]) x = fa[x][l2g[dep[x] - dep[y]] - 1]; if(x == y) return x; for(int k = l2g[dep[x]] - 1; k &gt;= 0; k--) &#123; if(fa[x][k] != fa[y][k]) x = fa[x][k], y = fa[y][k]; &#125; return fa[x][0];&#125; RMQ dfs遍历这棵树，每到达一个节点就记录下来（包括回溯），得到的序列称为欧拉序 欧拉序 1 2 4 2 5 2 1 3 1 ididid 记录节点第一次出现在欧拉序的编号 所以从 uuu 到 vvv 一定经过 lca(u,v)lca(u, v)lca(u,v) 但不会经过 lca(u,v)lca(u, v)lca(u,v) 的父亲，所以 它们路径重 ididid 最小的就是 lcalcalca 先dfs求出欧拉序再维护区间最值就行辣 12345678910111213141516171819202122232425int dfn[N &lt;&lt; 1], dep[N &lt;&lt; 1], T = 0;void dfs(int u, int dp)&#123; dfn[++T] = u; pos[u] = T; dep[T] = dp; for(int i = head[u]; i; i = e[i].nxt) &#123; dfs(e[i].to, dp + 1); dfn[++T] = u; dep[T] = dp; &#125;&#125;void initst()&#123; lg[0] = -1; for(int i = 1; i &lt;= (N &lt;&lt; 1); ++i) lg[i] = lg[i &gt;&gt; 1] + 1; for(int i = 1; i &lt;= (N &lt;&lt; 1) - 1; ++i) st[0][i] = dfn[i]; for(int i = 1; i &lt;= lg[(N &lt;&lt; 1) - 1]; ++i) for(int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= ((N &lt;&lt; 1) - 1); j++) st[i][j] = dep[st[i - 1][j]] &lt; dep[st[i - 1][j + (1 &lt;&lt; i - 1)]] ? st[i - 1][j] : st[i - 1][j + (1 &lt;&lt; i - 1)];&#125; 树剖 重链剖分 按子树大小分成轻儿子和重儿子，通向重儿子的边构成重链，这样把树整成了线性结构 图片来自oi-wiki 两次dfs 1234567891011121314151617181920212223242526int fa[MAXN], dep[MAXN], siz[MAXN], son[MAXN];// 节点父亲 节点深度 子树大小 重儿子int id[MAXN], top[MAXN], cnt;// 节点新编号 链顶节点void dfs1(int u, int dad)&#123; siz[u] = 1; fa[u] = dad; dep[u] = dep[dad]+1; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == dad) continue; dfs(v, u); siz[u] += siz[v]; if(siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; id[u] = ++cnt; if(son[u]) dfs2(son[u], tup); for(int i = head[u]; i; i = e[i].to) &#123; int v = e[i].to; if(v == son[u] || v == fa[u]) continue; dfs2(v, v); &#125;&#125; LCA 树剖求出 depdepdep 和 toptoptop 对于 uuu 和 vvv ，如果他们在一条链上，那么它们重深度小的那个就是 lcalcalca 如果不在一条链上，那就把所在链的链顶深度深的向上跳，直到在一条链上 123456789int lca(int u, int v)&#123; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) u = fa[top[u]]; else v = fa[top[v]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125; P3384 树剖之后线段树维护，区间修改，区间求和 P2146","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://ve1bae.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"点分治","slug":"点分治","permalink":"https://ve1bae.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"树同构","slug":"树同构","permalink":"https://ve1bae.github.io/tags/%E6%A0%91%E5%90%8C%E6%9E%84/"}]},{"title":"莫队学习笔记","slug":"莫队学习笔记","date":"2022-08-14T00:04:32.000Z","updated":"2022-11-14T11:16:13.036Z","comments":true,"path":"2022/08/14/莫队学习笔记/","link":"","permalink":"https://ve1bae.github.io/2022/08/14/%E8%8E%AB%E9%98%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"提莫队长算法","text":"提莫队长算法 莫队是一种 离线 数据结构，解决区间问题的数据结构，主要的思想是通过对区间离线下来，排序减少左右端点指针的移动次数，从而达到优雅的暴力的目的 当我们看到区间问题无法用线段树等常规数据结构很难维护时，不妨考虑莫队 算法流程大概就是： 对询问离线，然后排序 移动左右端点处理询问 普通莫队 算法本身很简单，所以我们通过例题讲解 对询问分块，块长 n\\sqrt{n}n​ 把询问按左端点所在块排序，在一个块内的按右端点排序，当区间移动计算贡献是 O(1)O(1)O(1) 时，整体算法复杂度 O(nn)O(n \\sqrt{n})O(nn​) 超 🐔 基础 P3901 数列找不同 给定一个长度为 nnn 的序列 a1,a2,…,ana_1, a_2, \\dots , a_na1​,a2​,…,an​，每次询问 [l,r][l, r][l,r] 的区间内 al,al+1,…,ara_l, a_l+1, \\dots, a_ral​,al​+1,…,ar​ 是否互不相同 莫队入门题，开一个桶记录当前区间每一个数字的出现次数，然后在统计只出现一次的数的个数，如果这个这个次数等于区间长度就 Yes ，否则 No code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int n,m,q,a[MAXN];int size,ans[MAXN];struct node&#123; int l,r,num; friend bool operator &lt; (node x,node y) &#123; if(x.l /size != y.l /size) return x.l/size &lt; y.l/size; else return x.r &lt; y.r; &#125;&#125;que[MAXN];int L,R,cnt,t[MAXN];void add(int x)&#123; if(!t[a[x]]) cnt++; t[a[x]]++;&#125;void del(int x)&#123; if(t[a[x]]==1) cnt--; t[a[x]]--;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); size = pow(n, 0.5); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= m; i++) &#123; que[i].num = i; scanf(&quot;%d%d&quot;, &amp;que[i].l, &amp;que[i].r); &#125; sort(que + 1, que + 1 + m); L = 1; R = 0; for(int i = 1; i &lt;= m; i++) &#123; int l = que[i].l , r = que[i].r; while(L &gt; l) add(--L); while(R &lt; r) add(++R); while(L &lt; l) del(L++); while(R &gt; r) del(R--); if(cnt == (r - l + 1)) ans[que[i].num] = 1; &#125; for(int i = 1; i &lt;= m; i++) &#123; if(ans[i]) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; return 0;&#125; 注意处理端点移动时的顺序，有很多正确的写法，但一般保证先加后删 SP3267 DQUERY - D-query 给定一个长度为 nnn 的序列 a1,a2,…,ana_1, a_2, \\dots , a_na1​,a2​,…,an​，每次询问 [l,r][l, r][l,r] 的区间内有多少不同的数字 和上一道题双倍经验，只要输出只出现一次的数的个数就行辣 还是基础 P2709 小B的询问 给定一个长度为 nnn 的序列 a1,a2,…,ana_1, a_2, \\dots, a_na1​,a2​,…,an​，值域为 kkk ，每次给定一个区间 [l,r][l, r][l,r]，求： ∑i=1kcnti2\\sum\\limits_{i = 1}^k cnt_i^2 i=1∑k​cnti2​ cnticnt_icnti​ 指数字 iii 在 [l,r][l, r][l,r] 区间内出现的次数 稍微需要一点思考，没什么好说的 (a+b)2=a2+2ab+b2(ci+1)2−(ci)2=2×ci+1(a+b)^2 = a^2 + 2ab + b^2 \\\\ (c_i + 1)^2 - (c_i)^2 = 2 \\times c_i + 1 (a+b)2=a2+2ab+b2(ci​+1)2−(ci​)2=2×ci​+1 code 12345678910void add(int pos)&#123; cnt[a[pos]]++; ANS += 2*cnt[a[pos]]-1;&#125;void del(int pos)&#123; cnt[a[pos]]--; ANS -= 2*cnt[a[pos]]+1;&#125; P1494 小 Z 的袜子 给定一个长度为 nnn 的序列，每一个元素对应一个颜色，每次询问区间 [l,r][l, r][l,r] 内随机选出两个元素，它颜色相同的概率 首先，选出一🐑颜色的方案数 ​∑i=lrcnt[i]∗(cnt[i]−1)，cnt[i]&gt;=2​ \\sum\\limits_{i = l}^{r} cnt[i]∗(cnt[i]−1)，cnt[i]&gt;=2 ​i=l∑r​cnt[i]∗(cnt[i]−1)，cnt[i]&gt;=2 总方案数 C2lenC_{2}^{len} C2len​ 然后考虑区间移动造成的影响 code AnsAnsAns 表示选出相同颜色的方案数12345678910111213void add(int pos)&#123; ANS -= cnt[a[pos]]*(cnt[a[pos]]-1); cnt[a[pos]]++; ANS += cnt[a[pos]]*(cnt[a[pos]]-1);&#125;void del(int pos)&#123; ANS -= cnt[a[pos]]*(cnt[a[pos]]-1); cnt[a[pos]]--; ANS += cnt[a[pos]]*(cnt[a[pos]]-1);&#125; 乱七八糟 P4462 CQOI2018异或序列 给定一个长度为 nnn 序列和 kkk ，每次查询区间 [l,r][l, r][l,r] 内有多少子区间异或和等于 kkk 因为要处理区间的异或和，考虑前缀和，这样 ⊕lr=⊕1r∧⊕1l−1\\oplus_l^r = \\oplus_1^r \\land \\oplus_1^{l-1}⊕lr​=⊕1r​∧⊕1l−1​ 那么每加入一个数 xxx ，与它对答案有贡献的数的前缀和 yyy ，一定是 x⊕y=kx \\oplus y = kx⊕y=k ，所以找出这样的数有几个就好了 code sumsumsum 表示异或和12345678910void add(int pos)&#123; ANS += cnt[sum[pos]^k]; cnt[sum[pos]]++;&#125;void del(int pos)&#123; cnt[sum[pos]]--; ANS -= cnt[sum[pos]^k];&#125; 双倍经验 CF617E P3730 这里用到了莫队常常会一起用的一个东西，值域分块。常常用来优化查询的复杂度 统计答案时，如果一个一个枚举的话，肯定不行，所以对桶也分个块，一块一块的枚举来找到答案在哪个块。 Code cnt 表示经典桶 cntt 表示对出现次数cnt开的桶。cnbt 是对 cnt 的值域分块开的桶1234567891011121314151617181920212223242526272829303132void add(int x)&#123; cntt[cnt[x]]--; cnbt[bel[cnt[x]]]--; cnt[x]++; cnbt[bel[cnt[x]]]++; cntt[cnt[x]]++;&#125;void del(int x)&#123; cntt[cnt[x]]--; cnbt[bel[cnt[x]]]--; cnt[x]--; cnbt[bel[cnt[x]]]++; cntt[cnt[x]]++;&#125;int get_ans(int k)&#123; int i; for (i = 1; i &lt;= cntb; i++) &#123; if (k - cnbt[i] &lt;= 0) break; k -= cnbt[i]; &#125; if (i == cntb + 1) return -1; for (int j = L[i]; j &lt;= R[i]; j++) &#123; if (k - cntt[j] &lt;= 0) return j; k -= cntt[j]; &#125; return 114514;&#125; 同样可以 莫队+值域分块 的题 P4147 P4396 AHOI2013 同样可以值域分块，但是这里介绍多个 logloglog 的做法 经典桶，然后整俩值域树状数组分别维护两个答案。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int n, m, a[MAXN], SIZE;#define bel(i) (i / SIZE + 1)struct query&#123; int l, r, a, b, id;&#125;que[MAXN];struct BIt&#123; int lim, t[MAXN]; #define lowbit(i) (i &amp; -i) void init(int x) &#123;lim = x;&#125; void add(int i, int val) &#123; if (!i) return; while (i &lt;= lim) t[i] += val, i += lowbit(i); &#125; int query(int i, int res = 0) &#123; while (i) res += t[i], i -= lowbit(i); return res; &#125;&#125;t1, t2;int cnt[MAXN];void add(int pos)&#123; if (cnt[a[pos]] == 0) t2.add(a[pos], 1); cnt[a[pos]]++; t1.add(a[pos], 1);&#125;void del(int pos)&#123; if (cnt[a[pos]] == 1) t2.add(a[pos], -1); cnt[a[pos]]--; t1.add(a[pos], -1);&#125;int ans1[MAXN], ans2[MAXN];int main()&#123; read(n, m); SIZE = sqrt(n); int mxz = 0; for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt;= m; i++) &#123; int l, r, a, b; read(l, r, a, b); que[i] = &#123;l, r, a - 1, b, i&#125;; mxz = max(&#123;mxz, a, b&#125;); &#125; t1.init(mxz); t2.init(mxz); sort(que + 1, que + 1 + m, [&amp;](query a, query b) &#123; if (bel(a.l) != bel(b.l)) return a.l &lt; b.l; return bel(a.l) &amp; 1 ? a.r &lt; b.r : a.r &gt; b.r; &#125;); int L = 1, R = 0; for (int i = 1; i &lt;= m; i++) &#123; int l = que[i].l, r = que[i].r; while (L &gt; l) add(--L); while (R &lt; r) add(++R); while (L &lt; l) del(L++); while (R &gt; r) del(R--); ans1[que[i].id] = t1.query(que[i].b) - t1.query(que[i].a); ans2[que[i].id] = t2.query(que[i].b) - t2.query(que[i].a); &#125; for (int i = 1; i &lt;= m; i++) print(ans1[i], &#x27; &#x27;), print(ans2[i], &#x27;\\n&#x27;); return 0;&#125; tips 一个有点用的优化。 考虑我们正常排序的结果，右端点排了序大概是这样的。 这样子左端点到了新块之后，右端点大概会移动图中红色的距离 换一个方式排序，如果左端点是奇数，按右端点升序，右端点是偶数，按右端点降序。这样以后大概是这样的 有点时候优化还挺明显的，一般叫这个奇偶优化 带修莫队 我们知道一般离线算法是不能带修的，但是如果修改产生的影响可以方便删除的添加到答案中也不是不行 一般莫队的询问都有两维，带修莫队就多了一个按修改决定的时间维度，排序时把时间作为第三关键字排序即可 还有和普通莫队的不一样的就是，这次块长为 n23n^{\\frac{2}{3}}n32​ ，排序是先按左端点所在块排序，再按右端点所在块排序，最后按时间排序，至于为什么 我不到啊 时间复杂度 O(n53)O(n^{\\frac{5}{3}})O(n35​) P1903 数颜色 给定一个长度为 nnn 的序列 a1,a2,…,ana_1, a_2, \\dots , a_na1​,a2​,…,an​，每次询问 [l,r][l, r][l,r] 的区间内有多少不同的数字，单点修改 和 SP3267 相比，就是多了一个修改操作 考虑如何实现修改，实际上我们只要把原来位置数字的贡献删掉，再加入新数字产生的贡献就行辣还要考虑的就是我们排序时，时间是第三关键字，所以会出现修改完再修改回去的情况，如何实现这样一个回溯的过程呢，有一个巧妙的做法 code 1234567891011121314151617181920212223242526272829303132333435363738394041for(int i = 1;i &lt;= m;i++)&#123; char o; int a,b; scanf(&quot;%c %d %d&quot;, &amp;o, &amp;a, &amp;b); if(o == &#x27;Q&#x27;) &#123; cntq++; que[cntq].l = a; que[cntq].r = b; que[cntq].num = cntq; que[cntq].t = cntc; &#125; else &#123; cntc++; c[cntc].pos = a; c[cntc].val = b; &#125;&#125;void change(int now)&#123; if(c[now].pos &gt;= L &amp;&amp; c[now].pos &lt;= R) //如果修改位置对答案有贡献 &#123; del(a[c[now].pos]); //删去原来贡献 add(c[now].val); //添加现在贡献 &#125; swap(c[now].val,a[c[now].pos]); //把现在的值和要修改的值交换，以便回溯&#125;for(int i = 1;i &lt;= cntq;i++)&#123; int l = que[i].l , r = que[i].r , t = que[i].t; while(L &gt; l) add(a[--L]); while(R &lt; r) add(a[++R]); while(L &lt; l) del(a[L++]); while(R &gt; r) del(a[R--]); while(T &lt; t) change(++T); //修改时间维度 while(T &gt; t) change(T--); ans[que[i].num] = ANS;&#125; 双倍经验 UVA12345 CF940F Machine Learning 给定一个长度为 nnn 的序列 a1,a2,…,ana_1, a_2, \\dots , a_na1​,a2​,…,an​，每次询问 [l,r][l, r][l,r] 区间数字出现次数的 mexmexmex ，单点修改 mexmexmex 指的是一些数字里没有出现的最小的自然数 和上面有道题一样，您也可以值域分块，但是这个题数据比较水。可以直接暴力求 mexmexmex for(ANS = 1;cntt[ANS] &gt; 0;ANS++); ans[que[i].num] = ANS; 还有就是记得离散化一下 回滚莫队 回滚莫队，只不删除或不添加的莫队比如说这道题 JOISC2014 给定一个长度为 nnn 的序列 a1,a2,…,ana_1, a_2, \\dots , a_na1​,a2​,…,an​，每次询问 [l,r][l, r][l,r] 区间数字最大的重要度。定义一个数字 xxx 的重要度为 x×cntxx \\times cnt_xx×cntx​ 明显不能像普通莫队一样直接区间移动，因为删除一个数的贡献很难维护，所以考虑避免删除操作。 我们可以备份一个版本的答案，然后通过回溯到这个版本来实现删除 于是有了这样一个思路： 对询问分块，左端点一个块内按右端点排序，否则按左端点所在块排序 如果询问在一个块内，直接暴力，因为块长最多 n\\sqrt{n}n​ ，单次询问 O(n)O(\\sqrt n)O(n​) 每当左端点移动一个整块，就初始化 L 为块的左端点，R 为块的左端点减一，原理和普通莫队的 L = 1, R = 0 一样 我们询问保证了同一个块内的右端点单调增，所以不用删除右端点移动产生的贡献，但是左端点不一样，所以备份左端点答案，添加后回溯 。也可以说创造一个工具人存档，用它去处理左端点的移动 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103int n, m, SIZE;int a[MAXN], h[MAXN];int bel[MAXN];namespace BLOCK //分块预处理&#123; int cnt; int L[MAXN], R[MAXN]; void pre_block() &#123; SIZE = sqrt(n); cnt = n / SIZE; for (int i = 1; i &lt;= cnt; i++) &#123; L[i] = R[i-1]+1; R[i] = i * SIZE; &#125; if(R[cnt] &lt; n) &#123; L[cnt+1] = R[cnt]+1; R[cnt+1] = n; cnt++; &#125; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = L[i]; j &lt;= R[i]; j++) bel[j] = i; &#125; &#125; #define BK BLOCK&#125;int L = 1, R = 0; ll Ans; ll ans[MAXN];int cnt[MAXN], cut[MAXN];// 一个维护区间移动，一个维护同一个块内的暴力void pre_lsh()// 值域 1e9,经典离散化&#123; sort(h + 1, h + 1 + n); int len = unique(h+1, h+1+n) - h - 1; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(h+1, h+1+len, a[i]) - h;&#125;void add(int pos, ll &amp;res)// 加贡献&#123; cnt[a[pos]]++; res = max(res, cnt[a[pos]] * 1LL * h[a[pos]]);&#125;void del(int pos)// 删贡献&#123; cnt[a[pos]]--;&#125;int main()&#123; n = read(); m = read(); for (int i = 1; i &lt;= n; i++) a[i] = h[i] = read(); BK::pre_block(); pre_lsh(); for (int i = 1; i &lt;= m; i++) &#123; q[i].l = read(); q[i].r = read(); q[i].id = i; &#125; sort(q + 1, q + 1 + m, cmp); int last = 0; // 上一个询问左端点所在块 for (int i = 1; i &lt;= m; i++) &#123; int l = q[i].l, r = q[i].r; if (bel[l] == bel[r]) // 一个块内，直接暴力 &#123; for (int j = l; j &lt;= r; j++) &#123; cut[a[j]]++; ans[q[i].id] = max(ans[q[i].id], h[a[j]]*1LL*cut[a[j]]); &#125; for (int j = l; j &lt;= r; j++) cut[a[j]]--; continue; &#125; if (bel[l] != last) // 到达新块，初始化 &#123; while(R &gt; BK::R[bel[l]]) del(R--); while(L &lt; BK::R[bel[l]]+1) del(L++); Ans = 0; last = bel[l]; &#125; while (R &lt; r) add(++R, Ans); // 添加右端点 int LL = L; ll res = Ans; // 备份答案，处理左端点的移动 while (LL &gt; l) add(--LL, res); while (LL &lt; L) del(LL++); // 删除左端点 ans[q[i].id] = res; &#125; for (int i = 1 ; i &lt;= m; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;&#125; 树上莫队 这里介绍使用括号序的树上莫队 我们知道莫队和关键所在是区间端点的移动，所以得把数整到序列上去，考虑一棵树的括号序 这棵树的括号序是 1 3 5 5 7 7 6 6 3 4 8 8 4 2 2 1 可以发现的是每个节点都在括号序上出现了两次，而且它出现的两个位置之间是它的子树。 那么两个节点括号序之间可能会出现查询的节点的兄弟节点，而这些节点是不需要的。但是是 dfs 序，那么这些节点要么不会出现，要么出现恰好两次。而且两个节点之间括号序是不含有他们的 LCA 的 比如说我们要查询节点 7 和 节点 4 之间，反映到括号序上就是 7 6 6 3 4 但实际上应该有 7 3 1 4 这些节点 缺少了它们的 LCA ，而且多了节点 6 ，发现像 6 这样多出来的节点一定会出现两次，不妨将计就计，可以打一个标记，第一次出现就加贡献，第二次出现就删贡献，然后再特判 LCA 还有就是如果询问的两个节点之一就是他们的 LCA 的话，括号序上是包含 LCA 的，特判一下 SP10707 Count on a tree II 给定 nnn 个结点的树，每个结点有一种颜色。 mmm 次询问，每次询问给出 u,vu,vu,v ，回答 u,vu,vu,v 之间的路径上的结点的不同颜色数。 纯纯滴板子题结合代码理解 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138int n, m, SIZE;int a[MAXN], b[MAXN];int bel[MAXN];struct query&#123; int l, r, u, v, id, lca;&#125;que[MAXM];bool cmp(query a, query b)&#123; if (bel[a.l] != bel[b.l]) return bel[a.l] &lt; bel[b.l]; if (bel[a.l] % 2) return a.r &lt; b.r; else return a.r &gt; b.r; &#125;vector &lt;int&gt; e[MAXN];int euler_cnt;int euler[MAXN*2], in[MAXN], out[MAXN];int siz[MAXN], dep[MAXN], fa[MAXN], top[MAXN], son[MAXN];// dfs 整括号序，顺便树剖LCAvoid dfs1(int u, int dad)&#123; euler[in[u] = ++euler_cnt] = u; // 括号序中第一次出现 fa[u] = dad; siz[u] = 1; dep[u] = dep[dad] + 1; for (int v : e[u]) if (v != dad) &#123; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; &#125; euler[out[u] = ++euler_cnt] = u; // 括号序中第二次出现&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if (son[u]) dfs2(son[u], tup); for (int v : e[u]) if (v != son[u] &amp;&amp; v != fa[u]) &#123; dfs2(v, v); &#125;&#125;int LCA(int u, int v)&#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;int L = 1, R = 0, Ans;int cnt[MAXM];int vis[MAXN]; // 记录第一次还是第二次void add(int pos)&#123; cnt[a[pos]]++; if (cnt[a[pos]] == 1) Ans++;&#125;void del(int pos)&#123; cnt[a[pos]]--; if (cnt[a[pos]] == 0) Ans--;&#125;void change(int pos)&#123; int u = euler[pos]; vis[u] ? del(u) : add(u); vis[u] ^= 1;&#125;int ans[MAXM];int main()&#123; read(n, m); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); b[i] = a[i]; &#125; // 离散化 sort(b + 1, b + 1 + n); int len = unique(b + 1, b + 1 + n) - b - 1; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b; for (int i = 1; i &lt; n; i++) &#123; int u, v; read(u, v); e[u].push_back(v); e[v].push_back(u); &#125; dfs1(1, 0); dfs2(1, 1); SIZE = pow(euler_cnt, 0.5); // 括号序上莫队，注意块长 for (int i = 1; i &lt;=euler_cnt; i++) bel[i] = i / SIZE + 1; for (int i = 1; i &lt;= m; i++) &#123; int u, v; read(u, v); que[i].id = i; if (in[u] &gt; in[v]) swap(u, v); // 先后顺序 que[i].u = u; que[i].v = v; // 根据 LCA 分情况 if (u == LCA(u, v)) &#123; que[i].l = in[u]; que[i].r = in[v]; que[i].lca = 0; &#125; else &#123; que[i].l = out[u]; que[i].r = in[v]; que[i].lca = LCA(u, v); &#125; &#125; sort(que+1, que+1+m, cmp); for (int i = 1; i &lt;= m; i++) &#123; int l = que[i].l, r = que[i].r; while (L &gt; l) change(--L); while (L &lt; l) change(L++); while (R &lt; r) change(++R); while (R &gt; r) change(R--); // 特判 LCA if (que[i].lca) change(in[que[i].lca]); ans[que[i].id] = Ans; if (que[i].lca) change(in[que[i].lca]); &#125; for (int i = 1; i &lt;= m; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; P4074 WC2013 糖果公园 糖果公园的结构十分奇特，形式化为一棵 nnn 个节点的树，一共有 mmm 种糖果，每个节点都有一种糖果 CiC_iCi​来到公园里游玩的游客都不喜欢走回头路，他们总是从某个特定的游览点出发前往另一个特定的游览点，并游览途中的景点，这条路线一定是唯一的。他们经过每个游览点，都可以品尝到一颗对应种类的糖果。根据游客们的反馈打分，我们得到了糖果的美味指数， 第 iii 种糖果的美味指数为 ViV_iVi​。另外，如果一位游客反复地品尝同一种类的糖果，他肯定会觉得有一些腻。根据量化统计，我们得到了游客第 iii 次品尝某类糖果的新奇指数 WiW_iWi​。如果一位游客第 iii 次品尝第 jjj 种糖果，那么他的愉悦指数 HHH 将会增加对应的美味指数与新奇指数的乘积，即 VjV_jVj​×WiW_iWi​。这位游客游览公园的愉悦指数最终将是这些乘积的和。糖果公园的工作人员小 A 接到了一个任务，那就是根据公园最近的数据统计出每位游客游玩公园的愉悦指数。但数学不好的小 A 一看到密密麻麻的数字就觉得头晕，作为小 A 最好的朋友，你决定帮他一把。 形式化一下，查询一条路径上的 ∑itotvi×∑jcntiwj\\sum\\limits_{i}^{tot} v_i \\times \\sum\\limits_{j}^{cnt_i}w_ji∑tot​vi​×j∑cnti​​wj​ tottottot 表示路径上一共出现了几种颜色，cnticnt_icnti​ 表示第 iii 种颜色出现了几次 树上带修莫队，当作板子吧 单点的贡献加减也很好维护 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112int n, m, q, SIZE;int a[MAXN];int v[MAXN], w[MAXN], c[MAXN];vector &lt;int&gt; e[MAXN];int euler[MAXN * 2], euler_cnt;int in[MAXN], out[MAXN];int siz[MAXN], son[MAXN], dep[MAXN];int top[MAXN], fa[MAXN];void dfs1(int u, int dad)&#123; fa[u] = dad; dep[u] = dep[dad] + 1; siz[u] = 1; euler[in[u] = ++euler_cnt] = u; for (int v : e[u]) if (v != dad) &#123; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; &#125; euler[out[u] = ++euler_cnt] = u;&#125;void dfs2(int u, int tup)&#123; top[u] = tup; if(son[u]) dfs2(son[u], tup); for (int v : e[u]) if (v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v);&#125;int LCA(int u, int v)&#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;int cntq, cntc;struct query &#123; int l, r, u, v, lca, t, id; &#125;que[MAXN];struct modify &#123; int pos, val; &#125;mdf[MAXN];bool cmp (query a, query b)&#123; if (a.l / SIZE != b.l / SIZE) return a.l / SIZE &lt; b.l / SIZE; if (a.r / SIZE != b.r / SIZE) return a.r &lt; b.r; return a.t &lt; b.t;&#125;int cnt[MAXN], vis[MAXN];int L = 1, R = 0, T;ll Ans, ans[MAXN];void add(int pos) &#123; Ans += 1LL * v[c[pos]] * w[++cnt[c[pos]]]; &#125;void del(int pos) &#123; Ans -= 1LL * v[c[pos]] * w[cnt[c[pos]]--]; &#125;void work(int pos) &#123; vis[pos] ? del(pos) : add(pos); vis[pos] ^= 1; &#125;void change(int T)&#123; int pos = mdf[T].pos; if (vis[pos]) &#123; work(pos); swap(mdf[T].val, c[pos]); work(pos); &#125; else swap(mdf[T].val, c[pos]);&#125;int main()&#123; read(n, m, q); for (int i = 1; i &lt;= m; i++) read(v[i]); for (int i = 1; i &lt;= n; i++) read(w[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); e[u].push_back(v); e[v].push_back(u); &#125; for (int i = 1; i &lt;= n; i++) read(c[i]); dfs1(1, 0); dfs2(1, 1); SIZE = pow(euler_cnt, 0.66666667); for (int i = 1; i &lt;= q; i++) &#123; int op, x, y; read(op, x, y); if (op == 1) &#123; cntq++; if (in[x] &gt; in[y]) swap(x, y); int lca = LCA(x, y); if (x == lca) que[cntq] = &#123; in[x], in[y], x, y, 0 , cntc, cntq&#125;; else que[cntq] = &#123; out[x], in[y], x, y, lca, cntc, cntq&#125;; &#125; else &#123; mdf[++cntc] = &#123;x, y&#125;; &#125; &#125; sort(que+1, que+1+cntq, cmp); for (int i = 1; i &lt;= q; i++) &#123; int l = que[i].l, r = que[i].r, t = que[i].t; while (L &gt; l) work(euler[--L]); while (L &lt; l) work(euler[L++]); while (R &lt; r) work(euler[++R]); while (R &gt; r) work(euler[R--]); while (T &lt; t) change(++T); while (T &gt; t) change(T--); if (que[i].lca) work(que[i].lca); ans[que[i].id] = Ans; if (que[i].lca) work(que[i].lca); &#125; for (int i = 1; i &lt;= cntq; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"多项式","slug":"多项式","date":"2022-07-21T00:05:20.000Z","updated":"2022-11-08T07:43:39.627Z","comments":true,"path":"2022/07/21/多项式/","link":"","permalink":"https://ve1bae.github.io/2022/07/21/%E5%A4%9A%E9%A1%B9%E5%BC%8F/","excerpt":"多项式多项式多项式多像💩多项式多项式多项式","text":"多项式多项式多项式多像💩多项式多项式多项式 一些定义 单位根 xn=1x^n = 1xn=1 在复数域内的n个解，我们把这些解称为单位根 wnkw_{n}^{k}wnk​ 其中 k∈[0,n−1]k \\in [0, n-1]k∈[0,n−1] ，单位根把单位圆n等分 单位根的性质 wnn=1w_n^n = 1wnn​=1 wnk+n=wnkw_n^{k+n} = w_n^{k}wnk+n​=wnk​ 画图理解 wnk+n2=−wnkw_n^{k+\\frac{n}{2}} = -w_n^kwnk+2n​​=−wnk​ 画图理解 wdkdk=wnkw_{dk}^{dk} = w_n^{k}wdkdk​=wnk​ 约分？ 单位根反演 [k∣n]=1k∑i=0k−1wkni[k \\mid n] = \\frac{1}{k}\\sum\\limits_{i = 0}^{k-1} w_k^{ni} [k∣n]=k1​i=0∑k−1​wkni​ 多项式的表示 对于一个多项式 f(x)=∑i=0naixif(x) = \\sum\\limits_{i = 0}^n a_ix^if(x)=i=0∑n​ai​xi 我们可以通过系数即 (a0,a1,a2,..,an)(a_0,a_1,a_2,..,a_n)(a0​,a1​,a2​,..,an​) 表示这个多项式 称为 系数表示 还有一种表示，叫做 点值表示 我们知道对于一个 nnn 次多项式 它可以由 n+1n+1n+1 个多项式上的点值确定 就是用这 n+1n+1n+1 个点值来表示这个多项式 FFT 可以快速解决多项式乘法问题 例如 A(x)∗B(x)=C(x)A(x)*B(x) = C(x)A(x)∗B(x)=C(x) 那么 C(x)C(x)C(x) 的次数就是 AAA 和 bbb 加起来 先整点朴素的嗷 一项一项乘上去的复杂度为 O(n2)O(n^2)O(n2) 我们需要进行一些优化 考虑用点值来操作 用点痣表示 AAA 和 BBB A(x)={(x0,A(x0)),(x1,A(x0)),(x2,A(x2)),...,(xn,A(xn))}B(x)={(x0,B(x0)),(x1,B(x0)),(x2,B(x2)),...,(xn,B(xn))}A(x) = \\left\\{ (x_0,A(x_0)), (x_1,A(x_0)), (x_2,A(x_2)), ...,(x_n,A(x_n))\\right\\}\\\\ B(x) = \\left\\{ (x_0,B(x_0)), (x_1,B(x_0)), (x_2,B(x_2)), ...,(x_n,B(x_n)) \\right\\} A(x)={(x0​,A(x0​)),(x1​,A(x0​)),(x2​,A(x2​)),...,(xn​,A(xn​))}B(x)={(x0​,B(x0​)),(x1​,B(x0​)),(x2​,B(x2​)),...,(xn​,B(xn​))} 那么 C(x)={(x0,A(x0)∗B(x0)),...,((xn+m),A(xn+m)∗B(xn+m))}C(x) = \\left\\{ (x_0,A(x_0)*B(x_0)),...,((x_{n+m}),A(x_{n+m})*B(x_{n+m})) \\right\\} C(x)={(x0​,A(x0​)∗B(x0​)),...,((xn+m​),A(xn+m​)∗B(xn+m​))} 所以我们现在可以在 O(n)O(n)O(n) 的时间内计算了 我们还需要把系数表示换位点值表示 再把结果的点值表示换位系数表示 第一步 DFT 系数 →\\rightarrow→ 点值 把项数按奇偶分开考虑 \\begin{align} A(x) &amp;= \\sum\\limits_{i = 0}^n a_ix^i\\nonumber \\\\ &amp;=(a_0 + a_2x^2 +a_4x^4+\\dots+a_{n-2}x^{n-2})\\nonumber \\\\ &amp;+(a_1x+a_3{x^3}+a_5{x^5}+ \\dots+a_{n-1}x^{n-1})\\nonumber \\end{align} 令 \\begin{align} A_1(x) &amp;= (a_0 + a_2x +a_4x^2+\\dots+a_{n-2}x^{\\frac{n}{2}-1})\\nonumber\\\\ A_2(x) &amp;= (a_1x+a_3x+a_5{x^2}+ \\dots+a_{n-1}x^{\\frac{n}{2}-1})\\nonumber \\end{align} 那么 A(x)=A1(x2)+xA2(x2)A(x) = A_1(x^2) + xA2(x^2) A(x)=A1​(x2)+xA2(x2) 我们把 x=wnkx = w_n^kx=wnk​ 代入 A(wnk)=A1(wn2k)+wnkA2(wn2k)A(w_n^k) = A_1(w_n^{2k}) + w_n^kA_2(w_n^{2k}) A(wnk​)=A1​(wn2k​)+wnk​A2​(wn2k​) 再带个 x=wnk+n2x = w_n^{k+\\frac{n}{2}}x=wnk+2n​​ \\begin{align} A(w_n^{k+\\frac{n}{2}}) &amp;= A_1(w_n^{2k+n}) + w_n^{k+\\frac{n}{2}}A_2(w_n^{2k+n})\\nonumber\\\\ &amp;=A_1(w_n^{2k}) - w_n^kA_2(w_n^{2k})\\nonumber \\end{align} wnn=1w_n^n = 1wnn​=1 wnk+n2=−wnkw_n^{k+\\frac{n}{2}} = -w_n^kwnk+2n​​=−wnk​ 我们观察得到的两个狮子，发现只有 A2A_2A2​ 的系数不同 我们可以递归求出 wnkw_n^kwnk​ 的 A1A_1A1​ 和 A2A_2A2​ 来计算 AAA 第二步 IDFT 点值 →\\rightarrow→ 系数 IDFT(Inv_DFT) DFT的逆过程 从定义出发 Ci=Aj∗Bi=∑j=0i−1aj∗bi−j−1C_i = A_j*B_i = \\sum\\limits_{j=0}^{i-1} a_j *b_{i-j-1}Ci​=Aj​∗Bi​=j=0∑i−1​aj​∗bi−j−1​ 令 q=j,p=i−j−1q = j, p = i-j-1q=j,p=i−j−1 则 Ci=∑p∑qap∗bq[p+q==n]C_i = \\sum\\limits_{p}\\sum\\limits_{q} a_p *b_q [p+q == n]Ci​=p∑​q∑​ap​∗bq​[p+q==n] =∑p∑qap∗bq[n∣p+q−i]=\\sum\\limits_{p}\\sum\\limits_{q} a_p *b_q [n\\mid p+q-i]=p∑​q∑​ap​∗bq​[n∣p+q−i] 单位根反演 =∑p∑qap∗bq∑j=01nwn(p+q−i)j= \\sum_p\\sum_qa_p*b_q \\sum\\limits_{j=0}\\frac{1}{n}w_n^{(p+q-i)j}=∑p​∑q​ap​∗bq​j=0∑​n1​wn(p+q−i)j​ 那么 nCi=∑p∑qap∗bq∑j=0wn(p+q−i)jnC_i =\\sum_p\\sum_qa_p*b_q \\sum\\limits_{j=0}w_n^{(p+q-i)j}nCi​=∑p​∑q​ap​∗bq​j=0∑​wn(p+q−i)j​ 把 p,q,ip, q, ip,q,i 分配一下，再把 jjj 提到前边去 nCi=∑jwn−ij(∑pwnjpap)(∑qwnjqbq)nC_i = \\sum_j w_n^{-ij}(\\sum_p w_n^{jp} a_p)(\\sum_q w_n^{jq} b_q)nCi​=∑j​wn−ij​(∑p​wnjp​ap​)(∑q​wnjq​bq​) 后面两个 ∑\\sum∑ 貌似就是 AAA 和 BBB 在 wnjw_n^jwnj​ 的点值？就是我们 DFT 的结果 于是我们代入 wnjw_n^jwnj​ 再DFT一遍就能得到 A−1A^{-1}A−1 还有更酷炫的 O(n)O(n)O(n) 方法 观察我们按奇偶拆开时的结果 恰好是原序列下标的二进制反转一下，我们就可以省去按奇偶分类的时间但是不会写 Code 递归版本儿 蒟蒻不会写非递归的捏 cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cmath&gt;#define MAXN 3000005using namespace std;struct complex&#123; double x,y; complex operator + (complex b) &#123;return complex&#123;x+b.x, y+b.y&#125;;&#125; complex operator - (complex b) &#123;return complex&#123;x-b.x, y-b.y&#125;;&#125; complex operator * (complex b) &#123;return complex&#123;x*b.x - y*b.y, x*b.y + y*b.x&#125;;&#125;&#125;A[MAXN],B[MAXN];int n,m;const double pi = acos(-1.0);void FFT(int limit, complex *a, int opt)&#123; if(limit == 1) return; complex a1[limit&gt;&gt;1], a2[limit&gt;&gt;1]; for(int i = 0; i &lt; limit; i += 2) &#123; a1[i&gt;&gt;1] = a[i]; a2[i&gt;&gt;1] = a[i+1]; &#125; FFT(limit&gt;&gt;1, a1, opt); FFT(limit&gt;&gt;1, a2, opt); complex wn = complex&#123;cos(2.0 * pi/limit), opt*sin(2.0*pi/limit)&#125;; complex w = complex&#123;1, 0&#125;; for(int i = 0; i &lt; (limit&gt;&gt;1); i++, w = w*wn) &#123; a[i] = a1[i] + w*a2[i]; a[i + (limit&gt;&gt;1)] = a1[i] - w*a2[i]; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 0; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;A[i].x); for(int i = 0; i &lt;= m; i++) scanf(&quot;%lf&quot;, &amp;B[i].x); int lmt = 1; while(lmt &lt;= n+m) lmt &lt;&lt;= 1; FFT(lmt, A, 1); FFT(lmt, B, 1); for(int i = 0; i &lt;= lmt; i++) A[i] = A[i] * B[i]; FFT(lmt, A, -1); for(int i = 0; i &lt;= n+m; i++) printf(&quot;%d &quot;, (int)(A[i].x/lmt+0.5));&#125; NTT 我们看到在 FFT 中，复数和三角函数会损失很大的精度，也有了不能取模的限制，所以也有另一个做法–NTT 原根 的性质和单位根很相似 令 ggg 为 模 ppp 下的原根，我们有 gp−1≡1 (mod p)g^{p-1} \\equiv 1 \\ (mod\\ p)gp−1≡1 (mod p) ，所以可以把单位根 wnkw_n^kwnk​ 换成 gnkg_n^kgnk​ 一般的 NTT 模数 998244353 的原根为 3 看到别的模数需要考虑一下原根是几或者写多模数 NTT ，但我不会，所以选择寄掉 NTT 123456789101112131415161718192021void NtT(ll *A, int opt)&#123; for(int i = 0; i &lt; limit; i++) if(i &lt; r[i]) swap(A[i], A[r[i]]); for(int mid = 1; mid &lt; limit; mid &lt;&lt;= 1) &#123; ll wn = ksm(opt == 1 ? yp : zp, (p-1)/(mid &lt;&lt; 1)); for(int j = 0; j &lt; limit; j += (mid &lt;&lt; 1)) &#123; ll w = 1; for(int k = 0; k &lt; mid; k++, w = w*wn%p) &#123; ll x = A[j + k], y = w * A[j + k + mid]%p; A[j + k] = (x + y)%p; A[j + k + mid] = (x - y +p)%p; &#125; &#125; &#125;&#125; 多项式求逆 对于一个多项式 FFF 如果有 F∗G≡1 (mod xn)F * G \\equiv 1 \\ (mod \\ x^n) F∗G≡1 (mod xn) 那么称 GGG 即 F−1F^{-1}F−1 为 FFF 的逆元 既然有 F∗G≡1 (mod xn)F * G \\equiv 1 \\ (mod \\ x^n) F∗G≡1 (mod xn) 那么同样 \\begin{align} F * H &amp;\\equiv 1 \\ (mod \\; x^{\\frac{n}{2}}) \\nonumber\\\\ G &amp;\\equiv H (mod \\; x^{\\frac{n}{2}}) \\nonumber\\\\ (G - H) &amp;\\equiv 0 (mod \\; x^{\\frac{n}{2}}) \\nonumber\\\\ (G - H)^2 &amp;\\equiv 0 (mod \\; x^n) \\nonumber\\\\ G^2 + H^2 - 2GH &amp;\\equiv 0 (mod \\; x^n) \\nonumber\\\\ F(G^2 + H^2 - 2GH) &amp;\\equiv 0 (mod \\; x^n) \\nonumber\\\\ G + FH^2 - 2H &amp;\\equiv 0 (mod \\; x^n) \\nonumber\\\\ G &amp;\\equiv 2H - FH^2 (mod \\; x^n) \\nonumber \\end{align} 推出式子递归 🆘 完了 多项式对数函数 (多项式 ln⁡\\lnln ) 多项式 F(x)F(x)F(x) 和 G(x)G(x)G(x) ， G≡ln⁡F(mod xn)G \\equiv \\ln F (mod \\; x^n)G≡lnF(modxn) ，求 GGG 得 🔪 一下 \\begin{align} G &amp;\\equiv \\ln F \\; (mod \\; x^n) \\nonumber\\\\ G&#039; &amp;\\equiv \\ln F&#039; \\; (mod \\; x^n) \\nonumber\\\\ G &amp;\\equiv \\ln(F)&#039; F&#039; \\; (mod \\; x^n) \\nonumber\\\\ G &amp;\\equiv \\frac{F&#039;}{F} \\; (mod \\; x^n) \\nonumber \\end{align} 所以求个导再整一个 FFF 的逆元得到 G′G&#x27;G′ 再寄回去就行辣 多项式指数函数 （多项式 exp⁡\\expexp aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","categories":[],"tags":[{"name":"数学，数论","slug":"数学，数论","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"}]},{"title":"类欧几里得","slug":"类欧几里得","date":"2022-07-18T00:04:31.000Z","updated":"2022-11-08T07:43:44.521Z","comments":true,"path":"2022/07/18/类欧几里得/","link":"","permalink":"https://ve1bae.github.io/2022/07/18/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"真多啊麻麻地","text":"真多啊麻麻地 Begin f(a,b,c,n)=∑i=0n⌊ai+bc⌋f(a,b,c,n) = \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{a_i + b}{c}\\right \\rfloor f(a,b,c,n)=i=0∑n​⌊cai​+b​⌋ 先考虑 a⩾ca \\geqslant ca⩾c 或 b⩾cb \\geqslant cb⩾c 时的情况，直接把除拆开 f(a,b,c,n)=∑i=0n⌊ai+bc⌋=∑i=0n⌊aic⌋+∑i=0n⌊bc⌋+∑i=0n⌊ai%c+b%cc⌋f(a,b,c,n) = \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor\\\\ = \\sum\\limits_{i = 0}^n \\lfloor \\frac{ai}c \\rfloor + \\sum\\limits_{i = 0}^n \\lfloor \\frac bc \\rfloor + \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{ai \\% c + b\\%c}{c}\\right \\rfloor f(a,b,c,n)=i=0∑n​⌊cai+b​⌋=i=0∑n​⌊cai​⌋+i=0∑n​⌊cb​⌋+i=0∑n​⌊cai%c+b%c​⌋ 发现左边是等差数列，右边是递归的形式 f(a,b,c,n)=n(n+1)2⌊aic⌋+n⌊bc⌋+f(a%c,b%c,c,n)f(a,b,c,n) = \\frac{n(n+1)}{2} \\lfloor \\frac{ai}c \\rfloor + n\\lfloor \\frac bc \\rfloor + f(a\\%c,b\\%c,c,n) f(a,b,c,n)=2n(n+1)​⌊cai​⌋+n⌊cb​⌋+f(a%c,b%c,c,n) 再来考虑 a&lt;ca \\lt ca&lt;c 和 b&lt;cb &lt; cb&lt;c 的情况，我们变一下 f(a,b,c,n)=∑i=0n⌊ai+bc⌋=∑i=0n∑j=0⌊ai+bc⌋−11f(a,b,c,n) = \\sum\\limits_{i=0}^n \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor = \\sum\\limits_{i=0}^n \\sum\\limits_{j=0}^{\\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor -1} 1 f(a,b,c,n)=i=0∑n​⌊cai+b​⌋=i=0∑n​j=0∑⌊cai+b​⌋−1​1 然后把 jjj 移到 iii 前面去，令 m=⌊an+bc⌋m = \\left \\lfloor \\frac{an + b}{c}\\right \\rfloorm=⌊can+b​⌋ =∑j=0m−1∑i=0n[j&lt;⌊ai+bc⌋]=\\sum\\limits_{j=0}^{m -1} \\sum\\limits_{i=0}^n \\left[j &lt; \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor \\right] =j=0∑m−1​i=0∑n​[j&lt;⌊cai+b​⌋] 尝试把条件变一变 \\begin{align} [j &lt; \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor] &amp;= [j+1 \\leqslant \\frac{ai + b}{c}] = [jc+c \\leqslant ai+b] \\nonumber\\\\ &amp;= [ai \\geqslant jc+c-b] = [ai \\geqslant jc+c-b-1]\\nonumber \\end{align} 这样 \\begin{align} f(a,b,c,n) &amp;= \\sum\\limits_{j=0}^{m-1}\\sum\\limits_{i=0}^n \\left[i &gt;= \\frac{jc+c-b-1}{a} \\right] \\nonumber\\\\ &amp;= \\sum\\limits_{j=0}^{m-1} \\left ( n-\\frac{jc+c-b-1}{a} \\right ) \\nonumber\\\\ &amp;= nm - f(c,c-b-1,a,m-1) \\nonumber \\end{align} 然后发现可求 可以发现我们递归的过程类似于辗转相除，因此这个算法叫做 ‘’类欧几里得‘’。 拓展 g(a,b,c,n)=∑i=0n⌊ai+bc⌋ih(a,b,c,n)=∑i=0n⌊ai+bc⌋2g(a,b,c,n) = \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{a_i + b}{c}\\right \\rfloor i \\\\ h(a,b,c,n) = \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{a_i + b}{c}\\right \\rfloor^2 g(a,b,c,n)=i=0∑n​⌊cai​+b​⌋ih(a,b,c,n)=i=0∑n​⌊cai​+b​⌋2 g 经典分情况 a⩾ca \\geqslant ca⩾c 或 b⩾cb \\geqslant cb⩾c 时 \\begin{align} g(a,b,c,n) &amp;= \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor i \\nonumber\\\\ &amp;= \\sum\\limits_{i = 0}^n \\lfloor \\frac{ai}c \\rfloor i + \\sum\\limits_{i = 0}^n \\lfloor \\frac bc \\rfloor i+ \\sum\\limits_{i = 0}^n \\left \\lfloor \\frac{ai \\% c + b\\%c}{c}\\right \\rfloor i \\nonumber\\\\ &amp;= \\lfloor \\frac{a}{c} \\rfloor \\frac{n(n+1)(2n+1)}{6} + \\lfloor \\frac{b}{c} \\rfloor \\frac{n(n+1)}{2}\\nonumber\\\\ &amp;+ g(a\\%c, b \\% c, c, n)\\nonumber \\end{align} a&lt;ca \\lt ca&lt;c 和 b&lt;cb &lt; cb&lt;c 时 令 m=⌊an+bc⌋m = \\lfloor \\frac{an + b}{c} \\rfloorm=⌊can+b​⌋ \\begin{align} g(a,b,c,n) &amp;= \\sum\\limits_{j=0}^{m -1} \\sum\\limits_{i=0}^n \\left[j &lt; \\left \\lfloor \\frac{ai + b}{c}\\right \\rfloor \\right]i \\nonumber\\\\ &amp;=\\sum\\limits_{j=0}^{m -1} \\sum\\limits_{i=0}^n \\left[i &gt;= \\frac{jc+c-b-1}{a} \\right]i \\nonumber \\end{align} 令 t=jc+b−c−1t = jc+b-c-1t=jc+b−c−1 \\begin{align} g(a,b,c,n) &amp;= \\sum\\limits_{j=0}^{m-1} \\frac{1}{2} (t+n+1)(n-t) \\nonumber\\\\ &amp;= \\frac{1}{2} \\left [ nm(m+1) - \\sum_{j=0}^{m-1}t^2 - \\sum_{j=0}^{m-1}t \\right ] \\nonumber\\\\ &amp;= \\frac{1}{2} \\left [ mn(n+1) - h(c, c-b-1, a, m-1) - f(c, c-b-1, a, m-1) \\right] \\nonumber \\end{align} h 真 🐔 8️⃣ 🐴 🍚 ，不推了 注意 n2n^2n2 换成 2n(n+1)2−n2 \\frac{n(n+1)}{2} - n22n(n+1)​−n 也就是 (2∑i=0n)−n\\left( 2\\sum\\limits_{i=0}^{n} \\right) - n(2i=0∑n​)−n 这样子就没有 ∑×∑\\sum \\times \\sum∑×∑ 了 a⩾ca \\geqslant ca⩾c 或 b⩾cb \\geqslant cb⩾c 时 \\begin{align} h(a,b,c,n) &amp;= h(a \\% c, b \\% c, c, n)\\nonumber\\\\ &amp;+ 2 \\lfloor \\frac{b}{c} \\rfloor f(a \\%c, b\\%c,c,n) + 2 \\lfloor \\frac{b}{c} \\rfloor g(a \\%c, b\\%c,c,n)\\nonumber\\\\ &amp;+ \\lfloor \\frac{a}{c} \\rfloor^2 \\frac{n(n+1)(2n+1)}{6} + \\lfloor \\frac{b}{c} \\rfloor^2(n+1) + \\lfloor \\frac{a}{c} \\rfloor\\lfloor \\frac{b}{c} \\rfloor n(n+1)\\nonumber \\end{align} a&lt;ca \\lt ca&lt;c 和 b&lt;cb &lt; cb&lt;c 时 \\begin{align} h(a,b,c,n) &amp;= nm(m+1) \\nonumber\\\\ &amp;- 2g(c, c-b-1, a, m-1) - 2f(c, c-b-1, a, m-1) - f(a, b, c, n)\\nonumber \\end{align} cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int t;ll n,a,b,c;const ll p = 998244353;const ll inv2 = 499122177;const ll inv6 = 166374059;struct node&#123; ll f, g, h;&#125;;node work(ll a, ll b, ll c, ll n)&#123; ll ac = a/c, bc = b/c, m = (a*n+b)/c, n1 = n+1, n2 = n*2+1; node x; if(a == 0) &#123; x.f = bc*n1%p; x.g = bc*n%p * n1%p * inv2%p; x.h = bc*bc%p * n1%p; return x; &#125; if(a &gt;= c || b &gt;= c) &#123; x.f = n*n1%p * inv2%p * ac%p + bc*n1%p; x.g = ac*n%p * n1%p * n2%p * inv6%p + bc * n%p * n1%p *inv2%p; x.h = ac*ac%p * n%p * n1%p * n2%p *inv6%p + bc*bc%p * n1%p + ac*bc%p * n%p * n1%p; x.f %= p; x.g %= p; x.h %= p; node e = work(a%c, b%c, c, n); x.h = (x.h + e.h + 2 * bc%p * e.f%p + 2 * e.g%p * ac%p)%p; x.f = (x.f + e.f)%p; x.g = (x.g + e.g)%p; x.h %= p; return x; &#125; node e = work(c, c-b-1, a, m-1); x.f = ((n * m%p - e.f)%p + p)%p; x.g = ((n * m%p * n1%p - e.h - e.f) * inv2%p +p) %p; x.h = ((n * m%p * (m+1)%p - 2*e.g - 2*e.f - x.f)%p + p)%p; return x;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;a,&amp;b,&amp;c); node ans = work(a, b, c, n); printf(&quot;%lld %lld %lld\\n&quot;,ans.f, ans.h, ans.g); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学，数论","slug":"数学，数论","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"}]},{"title":"二次剩余","slug":"二次剩余","date":"2022-07-13T00:01:28.000Z","updated":"2022-11-08T07:43:42.438Z","comments":true,"path":"2022/07/13/二次剩余/","link":"","permalink":"https://ve1bae.github.io/2022/07/13/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/","excerpt":"解如下的方程 x2≡ n (mod p)x^2 \\equiv \\, n \\ (mod \\; p) x2≡n (modp)","text":"解如下的方程 x2≡ n (mod p)x^2 \\equiv \\, n \\ (mod \\; p) x2≡n (modp) 前置 我们引入 LegendreLegendreLegendre 记号 (pn)={1 p 为 n 的二次剩余−1 p 为 n 非二次剩余0n≡0(\\frac p n) = \\begin{cases} 1 &amp;\\text { $p$ 为 $n$ 的二次剩余} \\\\ -1 &amp;\\text { $p$ 为 $n$ 非二次剩余} \\\\ 0 &amp;\\text{$n \\equiv 0$} \\end{cases} (np​)=⎩⎪⎪⎨⎪⎪⎧​1−10​ p 为 n 的二次剩余 p 为 n 非二次剩余n≡0​ 引理一： (np)≡np−12 (mod p)(\\frac{n}{p}) \\equiv n^{\\frac{p-1}{2}} \\ (mod \\ p) (pn​)≡n2p−1​ (mod p) 证明： 若 nnn 为 ppp 的 二次剩余，则 x2≡ nx^2 \\equiv \\ nx2≡ n 所以 xp−1≡1x^{p-1} \\equiv1xp−1≡1 费马小定理显然 反之则 xp−1≡−1x^{p-1} \\equiv -1xp−1≡−1 , xxx显然不存在 引理二： 对于 aaa 与 aaa 互质的奇素数 ppp 有 ap−12 ≡±1 (mod p)a^{\\frac{p-1}{2}} \\; \\equiv \\pm1 \\;(mod \\; p) a2p−1​≡±1(modp) 证明： 由费马小定理知： ap−1≡1 (mod p)a^{p-1} \\equiv 1\\;(mod\\;p) ap−1≡1(modp) 令 2q=p−12q = p-12q=p−1 则有 \\begin{align} a^{2q} &amp;\\equiv 1 \\ (mod \\; p)\\nonumber\\\\ a^{2q}-1 &amp;\\equiv 0 \\;\\nonumber\\\\ (a^q+1)(a^q-1) &amp;\\equiv 0\\;\\nonumber\\\\ a^q &amp;\\equiv \\pm1\\nonumber\\\\ a^{p-1} &amp;\\equiv 1\\nonumber\\\\ a^{\\frac{p-1}{2}} &amp;\\equiv \\pm 1 (mod \\ p)\\nonumber \\end{align} 开摆 令 w=a2−nw = a^2 - nw=a2−n 为 mod pmod\\;pmodp 的二次非生育 ， 则 x=(a+w)p+12x = (a + \\sqrt{w})^{\\frac{p+1}{2}}x=(a+w​)2p+1​ 为方程的解 证明： x2≡n≡a2−w≡(a+w)(a−w)x^2 \\equiv n \\equiv a^2 - w \\\\ \\equiv (a + \\sqrt{w})(a - \\sqrt{w}) x2≡n≡a2−w≡(a+w​)(a−w​) 费马小定理 ap≡aa^p \\equiv aap≡a ∴a2≡ap+1\\therefore a^2 \\equiv a^{p+1}∴a2≡ap+1 引理一知 wp−1≡−1\\sqrt {w}^{p-1} \\equiv -1w​p−1≡−1 在模 ppp 意义一下二项式定理 (a+b)p≡ap+bp(a + b)^p \\equiv a^p + b^p (a+b)p≡ap+bp 所以 \\begin{align} x^2 &amp;\\equiv (a + \\sqrt{w})(a - \\sqrt{w}) \\nonumber \\\\ \\nonumber &amp;\\equiv (a + \\sqrt{w})(a^p + \\sqrt {w}^{p-1}\\times \\sqrt{w}) \\\\\\nonumber &amp;\\equiv (a + \\sqrt{w})(a^p + \\sqrt {w}^{p}) \\nonumber \\\\ \\nonumber &amp;\\equiv (a + \\sqrt{w})^{p+1}\\\\ \\nonumber x&amp;\\equiv (a+\\sqrt{w})^{\\frac{p+1}{2}} \\end{align} 所以我们随机化整 www 求解即可 cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int t;ll n,p,w;struct dot&#123; ll x,y; dot operator * (dot b) &#123; dot ans; ans.x = ((x*b.x%p + y*b.y%p*w%p) + p)%p; ans.y = ((x*b.y%p + y*b.x%p) + p)%p; return ans; &#125; &#125;;ll ksm(ll a,ll b)&#123; ll ans = 1; while(b) &#123; if(b&amp;1) ans =a*ans%p; a = a*a%p; b &gt;&gt;= 1; &#125; return ans;&#125;ll ksm_w(dot a,ll b)&#123; dot ans = &#123;1,0&#125;; while(b) &#123; if(b&amp;1) ans = a*ans; a = a*a; b &gt;&gt;= 1; &#125; return ans.x%p;&#125;ll solve(ll n)&#123; n %= p; if(p == 2) return n; if(ksm(n,(p-1)/2) == p-1) return -1; ll a; while(1) &#123; a = rand()%p; w = (ksm(a,2)-n +p)%p; if(ksm(w,(p-1)/2) == p-1) break; &#125; dot x = &#123;a,1&#125;; return ksm_w(x,(p+1)/2);&#125;int main()&#123; srand(time(0)); scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;p); if(!n) &#123; printf(&quot;0\\n&quot;); continue; &#125; ll ans1 = solve(n),ans2; if(ans1 == -1) printf(&quot;Hola!\\n&quot;); else &#123; ans2 = p-ans1; if(ans2 &lt; ans1) swap(ans1,ans2); if(ans1 == ans2) printf(&quot;%lld\\n&quot;,ans1); else printf(&quot;%lld %lld\\n&quot;,ans1,ans2); &#125; &#125; return 0;&#125; 注意 www 类似于复数 要重载 ∗*∗ 运算 wssb","categories":[],"tags":[{"name":"数学，数论","slug":"数学，数论","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-06-28T07:05:20.000Z","updated":"2022-11-08T10:41:14.547Z","comments":true,"path":"2022/06/28/hello-world/","link":"","permalink":"https://ve1bae.github.io/2022/06/28/hello-world/","excerpt":"😃 😅","text":"😃 😅 φ\\varphiφ 😆 test Test AwA qwq &gt;w&lt; ∑qwqawa×Kon\\sum\\limits{qwq}^{awa} \\times Kon ∑qwqawa×Kon","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"https://ve1bae.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"动态规划","slug":"动态规划","permalink":"https://ve1bae.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://ve1bae.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数学，数论","slug":"数学，数论","permalink":"https://ve1bae.github.io/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E8%AE%BA/"},{"name":"图论","slug":"图论","permalink":"https://ve1bae.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"https://ve1bae.github.io/tags/dsu-on-tree/"},{"name":"虚树","slug":"虚树","permalink":"https://ve1bae.github.io/tags/%E8%99%9A%E6%A0%91/"},{"name":"点分治","slug":"点分治","permalink":"https://ve1bae.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"树同构","slug":"树同构","permalink":"https://ve1bae.github.io/tags/%E6%A0%91%E5%90%8C%E6%9E%84/"}]}